---
title: "RANDOM_FOREST_ML"
output: html_document
date: "2025-04-23"
---


Load packages
```{r}
library(sp)
library(terra)
library(randomForest)
library(caret)
library(ggplot2)
library(terra)
library(sf)
library(pdp)
library(gridExtra)  
library(dismo)
library(tmap)
library(rpart)
library(rpart.plot)
library(MASS)
library(dplyr)
library(tidyr)
library(raster)
library(tidyverse)
library(metR)
library(grid)
library(eulerr)
library(VennDiagram)
library(rnaturalearth)
library(gridGraphics)
library(purrr)
library(ggforce)
library(ggspatial) 
```

Load data files
```{r}

Elevation <- raster("Elevation_5km.tif")
  
Market_Proximity <- raster("Market_Proximity_2020_5km.tif")
  
Road_Proximity <- raster("Road_Proximity_2020_5km.tif")
  
Population <- raster("Population_2020_5km.tif")
  
RWI <- raster("RWI_2020_5km.tif")
  
Wheat_leaf_rust <- raster("Wheat_leaf_rust_2020_5km.tif")

Wheat_stem_rust <- raster("Wheat_stem_rust_2020_5km.tif")

Wheat_yellow_rust <- raster("Wheat_yellow_rust_2020_5km.tif")

FSR <- read.csv("Extracted_Food_Security_Data.csv")


Food_security_values = read.csv("Socio-economic-survey-ETH_2020_FSI.csv")

View(Food_security_values)
plot(Elevation)
plot(Market_Proximity)
plot(Road_Proximity)
plot(Population)
plot(RWI)
plot(Wheat_leaf_rust)
plot(Wheat_stem_rust)
plot(Wheat_yellow_rust)

#Yeild
tiff_file_2b_noirr_rcp26_20 <- rast("/Users/maiawatson-hearne/Desktop/UCL Geography Y3/Dissertation/Data/ML Data/TIFF Rename/Ethiopia_wheat_RCP26_noirrigation_5km_2020 copy.tif") 

print(tiff_file_2b_noirr_rcp26_20)
plot(tiff_file_2b_noirr_rcp26_20)  

#soil moisture
tiff_file_2b_soilmoist_rcp26_20 <- rast("/Users/maiawatson-hearne/Desktop/UCL Geography Y3/Dissertation/Data/ML Data/TIFF Rename/CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2020 copy.tif")

print(tiff_file_2b_soilmoist_rcp26_20)
plot(tiff_file_2b_soilmoist_rcp26_20)  
```
```{r}
Elevation <- rast("Elevation_5km.tif")
  
Market_Proximity <- rast("Market_Proximity_2020_5km.tif")
  
Road_Proximity <- rast("Road_Proximity_2020_5km.tif")
  
Population <- rast("Population_2020_5km.tif")
  
RWI <- rast("RWI_2020_5km.tif")
  
plot(Elevation)
plot(Market_Proximity)
plot(Road_Proximity)
plot(Population)
plot(RWI)

```


Random Forest Model
```{r}
head(FSR)
#Convert FSI_Bool to factor
FSR$FSI_Bool <- as.factor(FSR$FSI_Bool)

#Train-Test Split
set.seed(20030415)
train_index_RFa <- sample(1:nrow(FSR), size = 0.7 * nrow(FSR))
train_data_RFa <- FSR[train_index_RFa, ]
test_data_RFa <- FSR[-train_index_RFa, ]

#Train Random Forest Model with Additional Predictors
RFa_model <- randomForest(
  FSI_Bool ~ Yield + Soil_Moisture + Market_Proximity + Road_Proximity + 
              Population + Elevation + RWI, 
  data = train_data_RFa, 
  ntree = 200,  
  mtry = 3, 
  importance = TRUE  
)
#Predictions
predictions_RFa <- predict(RFa_model, test_data_RFa)

#Confusion Matrix
confusion_matrix_RFa <- confusionMatrix(predictions_RFa, test_data_RFa$FSI_Bool)
print(confusion_matrix_RFa)
```

Random Forest Model Confusion Matrix
```{r}

#Convert confusion matrix table to a data frame
confusion_matrix_RFa_df <- as.data.frame(confusion_matrix_RFa$table)

#Rename columns for clarity
colnames(confusion_matrix_RFa_df) <- c("Actual", "Predicted", "Count")

#Plot the confusion matrix heatmap
ggplot(confusion_matrix_RFa_df, aes(x = Actual, y = Predicted, fill = Count)) +
  geom_tile(color = "black") + 
  geom_text(aes(label = Count), color = "white", size = 6) +  
  scale_fill_gradient(low = "lightblue", high = "darkblue") +  
  theme_minimal() +
  labs(
    title = "Confusion Matrix (Random Forest Model)",
    x = "Actual Class",
    y = "Predicted Class",
    fill = "Count"
  ) +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
        plot.title = element_text(hjust = 0.5, size = 14))
```
```{r}
#Variable Importance Plot
varImpPlot(RFa_model, main = "Variable Importance in Predicting FSR")

#Store Variable Importance Data
importance_data <- data.frame(Variable = rownames(importance(RFa_model)), 
                              Importance = importance(RFa_model)[, "MeanDecreaseGini"])

#Plot Feature Importance Using ggplot2
ggplot(importance_data, aes(x = reorder(Variable, Importance), y = Importance)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Most Important Predictors for FSR",
       x = "Predictor Variables",
       y = "Mean Decrease in Gini Index")
```


```{r}
tree1 <- getTree(RFa_model, k = 1, labelVar = TRUE)  
print(tree1)
```

```{r}


#Train Decision Tree Model using rpart
rpart_model <- rpart(FSI_Bool ~ Yield + Soil_Moisture + Market_Proximity + 
                     Road_Proximity + Population + Elevation + RWI, 
                     data = train_data_RFa, 
                     method = "class", 
                     control = rpart.control(cp = 0.01))  

rpart.plot(rpart_model, 
           type = 4, 
           extra = 104, 
           box.palette = "Blues", 
           fallen.leaves = TRUE,
           cex = 0.7) 
```

```{r}
rpart.plot(rpart_model, 
           type = 2,  
           extra = 104,  
           box.palette = "RdBu", 
           shadow.col = "gray", 
           branch.lty = 1,  
           tweak = 1.2,  
           cex = 1.2,  
           split.cex = 1.3,  
           faclen = 0,  
           font = 2) 
```




```{r}
rpart.plot(rpart_model, 
           type = 2,           
           extra = 104,   
           box.palette = "RdBu", 
           shadow.col = "gray",  
           branch.lty = 1,    
           tweak = 1.1,   
           cex = 0.9,  
           split.cex = 1.1,  
           faclen = 0,   
           font = 1,  
           main = "Decision Tree for Food Security Prediction") 
```



```{r}
# Define Predictor Variables to Plot
variables_to_plot <- c("Elevation", "Market_Proximity", "Road_Proximity", 
                       "Population", "RWI", "Yield", "Soil_Moisture")

# Generate Partial Dependence Data for Each Variable
pdp_plots <- lapply(variables_to_plot, function(var) {
  partial(RFa_model, pred.var = var, train = train_data_RFa, plot = FALSE)
})
names(pdp_plots) <- variables_to_plot  

# Create PDP Plots for Each Predictor Variable
plot_list <- lapply(variables_to_plot, function(var) {
  ggplot(pdp_plots[[var]], aes_string(x = var, y = "yhat")) +
    geom_line(color = "red", size = 1) +
    theme_minimal() +
    labs(title = var, x = var, y = "Predicted Value")
})

# Arrange Plots in a Grid Layout
grid.arrange(grobs = plot_list, ncol = 3) 
```

Model cross validation:
```{r}
# Define positive and negative test cases
positive_test <- test_data_RFa[test_data_RFa$FSI_Bool == 1, ]
negative_test <- test_data_RFa[test_data_RFa$FSI_Bool == 0, ]

# Get model predictions for test data
predictions <- predict(RFa_model, newdata = test_data_RFa, type = "prob")[,2]  

# Run Cross-Validation Using `evaluate()`
cross_validation <- evaluate(
  p = predictions[test_data_RFa$FSI_Bool == 1],  
  a = predictions[test_data_RFa$FSI_Bool == 0], 
  model = RFa_model
)

# Print Evaluation Results
print(cross_validation)

plot(cross_validation, 'ROC', cex=1.2)

#0.7749 
#The optimal probability threshold at which our model maximizes the True Positive Rate and the True Negative Rate is 0.7749 (77.49%). Hence, we will use predicted probability > 0.7749 to delineate areas of suitability (or trigger points) for Food insecurity
```

```{r}


#Define the predictors from your dataset
predictors <- colnames(train_data_RFa)

#Create a list to store threshold values
thresholds <- list()

for (var in predictors) {
  pd <- partial(RFa_model, pred.var = var, train = train_data_RFa, plot = FALSE)
  
  #Find the closest value where food insecurity probability is ≥ 0.775
  threshold_value <- pd[which.min(abs(pd$y - 0.775)), var]
  
  #Store the result
  thresholds[[var]] <- threshold_value
}

#Convert to data frame
thresholds_df <- as.data.frame(do.call(rbind, thresholds))
colnames(thresholds_df) <- c("Threshold")
thresholds_df
```

```{r}

#Define file paths for predictor rasters
predictor_files <- list(
  "Elevation" = "Elevation_5km.tif",
  "Market_Proximity" = "Market_Proximity_2020_5km.tif",
  "Road_Proximity" = "Road_Proximity_2020_5km.tif",
  "Population" = "Population_2020_5km.tif",
  "RWI" = "RWI_2020_5km.tif",
  "Yield" = "Ethiopia_wheat_RCP26_noirrigation_5km_2020 copy.tif",
  "Soil_Moisture" = "CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2020 copy.tif")

#Extract thresholds
thresholds <- list(
  "Elevation" = 458.5267,
  "Market_Proximity" = 27363.68,
  "Road_Proximity" = 50.7375,
  "Population" = 480.2990,
  "RWI" = -0.6120,
  "Yield" = 0.1522,
  "Soil_Moisture" = 144.6190
)

#Create a list to store classified rasters
classified_rasters <- list()

for (var in names(predictor_files)) {
  #Load raster
  raster_layer <- rast(predictor_files[[var]])
  
  #Apply threshold, Areas above threshold are considered food insecure (1), otherwise (0)
  classified_raster <- raster_layer >= thresholds[[var]]
  
  #Save classified raster
  output_filename <- paste0("Food_Insecurity_", var, "_5km.tif")
  writeRaster(classified_raster, output_filename, overwrite = TRUE)
  
  #Store for visualization if needed
  classified_rasters[[var]] <- classified_raster
}

#Plot an example raster 
plot(classified_rasters[["Yield"]], main = "Food Insecurity: Yield Threshold")
```

```{r}
#Convert logical rasters to numeric (1 for TRUE, 0 for FALSE)
classified_rasters_numeric <- list()

for (var in names(classified_rasters)) {
  #Convert logical to numeric (TRUE -> 1, FALSE -> 0)
  classified_rasters_numeric[[var]] <- classify(classified_rasters[[var]], matrix(c(0, 0, 1, 1), ncol = 2, byrow = TRUE))

  #Save the binary raster
  output_filename <- paste0("Binary_Food_Insecurity_", var, "_5km.tif")
  writeRaster(classified_rasters_numeric[[var]], output_filename, overwrite = TRUE)
}

#Plot all binary rasters in a grid layout for verification
par(mfrow = c(3, 3)) 

plot(classified_rasters_numeric[["Elevation"]], main = "Food Insecurity: Elevation", col = c("white", "black"))
plot(classified_rasters_numeric[["Market_Proximity"]], main = "Food Insecurity: Market Proximity", col = c("white", "black"))
plot(classified_rasters_numeric[["Road_Proximity"]], main = "Food Insecurity: Road Proximity", col = c("white", "black"))
plot(classified_rasters_numeric[["Population"]], main = "Food Insecurity: Population", col = c("white", "black"))
plot(classified_rasters_numeric[["RWI"]], main = "Food Insecurity: RWI", col = c("white", "black"))
plot(classified_rasters_numeric[["Yield"]], main = "Food Insecurity: Yield", col = c("white", "black"))
plot(classified_rasters_numeric[["Soil_Moisture"]], main = "Food Insecurity: Soil Moisture", col = c("white", "black"))

par(mfrow = c(1,1))  
```

Predicting RCP 26

ISIMIP2B RCP26 2020 no irr
```{r}

#Load the environmental predictor rasters for 2020 (RCP26 with no irrigation)
yield_2020_noirr_RCP26 <- rast("Ethiopia_wheat_RCP26_noirrigation_5km_2020 copy.tif")
soil_moisture_2020_noirr_RCP26 <- rast("CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2020 copy.tif")
population_2020_noirr_RCP26 <- rast("population_2020.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_RCP26 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_RCP26 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_RCP26 <- rast("Elevation_5km.tif")
rwi_2020_RCP26 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2020_RCP26 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2020_RCP26))) {
  st_crs(ethiopia_outline_2020_RCP26) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2020_noirr_RCP26 <- crs(yield_2020_noirr_RCP26)
target_res_2020_noirr_RCP26 <- res(yield_2020_noirr_RCP26)
target_ext_2020_noirr_RCP26 <- ext(yield_2020_noirr_RCP26)  

#List of rasters to align
rasters_list_2020_noirr_RCP26 <- list(soil_moisture_2020_noirr_RCP26, market_proximity_2020_RCP26, 
                                      road_proximity_2020_RCP26, population_2020_noirr_RCP26, 
                                      elevation_2020_RCP26, rwi_2020_RCP26)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2020_noirr_RCP26)) {
  rasters_list_2020_noirr_RCP26[[i]] <- project(rasters_list_2020_noirr_RCP26[[i]], target_crs_2020_noirr_RCP26) 
  rasters_list_2020_noirr_RCP26[[i]] <- resample(rasters_list_2020_noirr_RCP26[[i]], yield_2020_noirr_RCP26, method = "bilinear") 
  rasters_list_2020_noirr_RCP26[[i]] <- crop(rasters_list_2020_noirr_RCP26[[i]], target_ext_2020_noirr_RCP26) 
  rasters_list_2020_noirr_RCP26[[i]] <- mask(rasters_list_2020_noirr_RCP26[[i]], yield_2020_noirr_RCP26)  
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2020_noirr_RCP26 <- c(yield_2020_noirr_RCP26, rasters_list_2020_noirr_RCP26[[1]], 
                                      rasters_list_2020_noirr_RCP26[[2]], rasters_list_2020_noirr_RCP26[[3]],
                                      rasters_list_2020_noirr_RCP26[[4]], rasters_list_2020_noirr_RCP26[[5]], 
                                      rasters_list_2020_noirr_RCP26[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2020_noirr_RCP26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2020_noirr_RCP26 <- as.data.frame(predictor_stack_2020_noirr_RCP26, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2020_noirr_RCP26)[-c(1,2)]) {  
  predictor_df_2020_noirr_RCP26[[var]][is.na(predictor_df_2020_noirr_RCP26[[var]])] <- mean(predictor_df_2020_noirr_RCP26[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2020_noirr_RCP26 <- predict(RFa_model, newdata = predictor_df_2020_noirr_RCP26, type = "response")

#Convert predictions to numeric
predictor_df_2020_noirr_RCP26$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2020_noirr_RCP26))

#Convert Predictions Back to Raster Format
fsi_raster_2020_noirr_RCP26 <- rast(yield_2020_noirr_RCP26) 

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2020_noirr_RCP26) == ncell(fsi_raster_2020_noirr_RCP26)) {  
  values(fsi_raster_2020_noirr_RCP26) <- predictor_df_2020_noirr_RCP26$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2020_noirr_RCP26), "got", nrow(predictor_df_2020_noirr_RCP26)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2020_noirr_RCP26 <- mask(fsi_raster_2020_noirr_RCP26, vect(ethiopia_outline_2020_RCP26))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2020_noirr_RCP26, "FSI_2020_RCP26_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2020_noirr_RCP26, main = "Predicted Food Security (2020, RCP26 without Irrigation)")
```

ISIMIP2B RCP26 2020 irr
```{r}

#Load the environmental predictor rasters for 2020 (RCP26 with irrigation)
yield_2020_irr_RCP26 <- rast("Ethiopia_Wheat_RCP26_Irrigation_5km_2020 copy.tif")
soil_moisture_2020_irr_RCP26 <- rast("CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2020 copy.tif")
population_2020_irr_RCP26 <- rast("population_2020.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_RCP26 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_RCP26 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_RCP26 <- rast("Elevation_5km.tif")
rwi_2020_RCP26 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2020_RCP26 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2020_RCP26))) {
  st_crs(ethiopia_outline_2020_RCP26) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2020_RCP26 <- crs(yield_2020_irr_RCP26)
target_res_2020_RCP26 <- res(yield_2020_irr_RCP26)
target_ext_2020_RCP26 <- ext(yield_2020_irr_RCP26)  

#List of rasters to align
rasters_list_2020_RCP26 <- list(soil_moisture_2020_irr_RCP26, market_proximity_2020_RCP26, 
                                road_proximity_2020_RCP26, population_2020_irr_RCP26, 
                                elevation_2020_RCP26, rwi_2020_RCP26)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2020_RCP26)) {
  rasters_list_2020_RCP26[[i]] <- project(rasters_list_2020_RCP26[[i]], target_crs_2020_RCP26)  
  rasters_list_2020_RCP26[[i]] <- resample(rasters_list_2020_RCP26[[i]], yield_2020_irr_RCP26, method = "bilinear") 
  rasters_list_2020_RCP26[[i]] <- crop(rasters_list_2020_RCP26[[i]], target_ext_2020_RCP26) 
  rasters_list_2020_RCP26[[i]] <- mask(rasters_list_2020_RCP26[[i]], yield_2020_irr_RCP26)  
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2020_irr_RCP26 <- c(yield_2020_irr_RCP26, rasters_list_2020_RCP26[[1]], rasters_list_2020_RCP26[[2]], 
                                    rasters_list_2020_RCP26[[3]], rasters_list_2020_RCP26[[4]], 
                                    rasters_list_2020_RCP26[[5]], rasters_list_2020_RCP26[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2020_irr_RCP26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                           "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2020_irr_RCP26 <- as.data.frame(predictor_stack_2020_irr_RCP26, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2020_irr_RCP26)[-c(1,2)]) { 
  predictor_df_2020_irr_RCP26[[var]][is.na(predictor_df_2020_irr_RCP26[[var]])] <- mean(predictor_df_2020_irr_RCP26[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2020_irr_RCP26 <- predict(RFa_model, newdata = predictor_df_2020_irr_RCP26, type = "response")

#Convert predictions to numeric
predictor_df_2020_irr_RCP26$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2020_irr_RCP26))

#Convert Predictions Back to Raster Format
fsi_raster_2020_irr_RCP26 <- rast(yield_2020_irr_RCP26) 

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2020_irr_RCP26) == ncell(fsi_raster_2020_irr_RCP26)) {  
  values(fsi_raster_2020_irr_RCP26) <- predictor_df_2020_irr_RCP26$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2020_irr_RCP26), "got", nrow(predictor_df_2020_irr_RCP26)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2020_irr_RCP26 <- mask(fsi_raster_2020_irr_RCP26, vect(ethiopia_outline_2020_RCP26))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2020_irr_RCP26, "FSI_2020_RCP26_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2020_irr_RCP26, main = "Predicted Food Security (2020, RCP26 with Irrigation)")
```


ISIMIP2B RCP26 2030 no irr
```{r}

#Load the environmental predictor rasters for 2030 (RCP26)
yield_2030 <- rast("Ethiopia_wheat_RCP26_noirrigation_5km_2030 copy.tif")
soil_moisture_2030 <- rast("CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2030 copy.tif")
population_2030 <- rast("population_2030.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity <- rast("Market_Proximity_2020_5km.tif")
road_proximity <- rast("Road_Proximity_2020_5km.tif")
elevation <- rast("Elevation_5km.tif")
rwi <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline))) {
  st_crs(ethiopia_outline) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs <- crs(yield_2030)
target_res <- res(yield_2030)
target_ext <- ext(yield_2030)  

#List of rasters to align
rasters_list <- list(soil_moisture_2030, market_proximity, road_proximity, 
                     population_2030, elevation, rwi)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list)) {
  rasters_list[[i]] <- project(rasters_list[[i]], target_crs) 
  rasters_list[[i]] <- resample(rasters_list[[i]], yield_2030, method = "bilinear")
  rasters_list[[i]] <- crop(rasters_list[[i]], target_ext) 
  rasters_list[[i]] <- mask(rasters_list[[i]], yield_2030)
}

#Stack the rasters into a single multi-layer raster
predictor_stack <- c(yield_2030, rasters_list[[1]], rasters_list[[2]], rasters_list[[3]],
                     rasters_list[[4]], rasters_list[[5]], rasters_list[[6]])

#Rename the layers to match the model variable names
names(predictor_stack) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                            "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df <- as.data.frame(predictor_stack, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df)[-c(1,2)]) { 
  predictor_df[[var]][is.na(predictor_df[[var]])] <- mean(predictor_df[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi <- predict(RFa_model, newdata = predictor_df, type = "response")

#Convert predictions to numeric
predictor_df$FSI_Predicted <- as.numeric(as.character(predicted_fsi))

#Convert Predictions Back to Raster Format
fsi_raster <- rast(yield_2030)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df) == ncell(fsi_raster)) {  
  values(fsi_raster) <- predictor_df$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster), "got", nrow(predictor_df)))
}

#Mask the raster to Ethiopia boundary
fsi_raster <- mask(fsi_raster, vect(ethiopia_outline))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster, "FSI_2030_RCP26_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster, main = "Predicted Food Security (2030, no irrigation, RCP26)")
```
ISIMIP2B RCP26 2030 irrigation
```{r}
#Load the environmental predictor rasters for 2030 (RCP26 with irrigation)
yield_2030_irr_RCP26 <- rast("Ethiopia_Wheat_RCP26_Irrigation_5km_2030 copy.tif")
soil_moisture_2030_irr_RCP26 <- rast("CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2030 copy.tif")
population_2030_irr_RCP26 <- rast("population_2030.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_RCP26 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_RCP26 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_RCP26 <- rast("Elevation_5km.tif")
rwi_2020_RCP26 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_RCP26 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_RCP26))) {
  st_crs(ethiopia_outline_RCP26) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_RCP26 <- crs(yield_2030_irr_RCP26)
target_res_RCP26 <- res(yield_2030_irr_RCP26)
target_ext_RCP26 <- ext(yield_2030_irr_RCP26) 

#List of rasters to align
rasters_list_RCP26 <- list(soil_moisture_2030_irr_RCP26, market_proximity_2020_RCP26, road_proximity_2020_RCP26, 
                           population_2030_irr_RCP26, elevation_2020_RCP26, rwi_2020_RCP26)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_RCP26)) {
  rasters_list_RCP26[[i]] <- project(rasters_list_RCP26[[i]], target_crs_RCP26) 
  rasters_list_RCP26[[i]] <- resample(rasters_list_RCP26[[i]], yield_2030_irr_RCP26, method = "bilinear")
  rasters_list_RCP26[[i]] <- crop(rasters_list_RCP26[[i]], target_ext_RCP26) 
  rasters_list_RCP26[[i]] <- mask(rasters_list_RCP26[[i]], yield_2030_irr_RCP26)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2030_irr_RCP26 <- c(yield_2030_irr_RCP26, rasters_list_RCP26[[1]], rasters_list_RCP26[[2]], rasters_list_RCP26[[3]],
                                    rasters_list_RCP26[[4]], rasters_list_RCP26[[5]], rasters_list_RCP26[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2030_irr_RCP26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                           "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2030_irr_RCP26 <- as.data.frame(predictor_stack_2030_irr_RCP26, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2030_irr_RCP26)[-c(1,2)]) { 
  predictor_df_2030_irr_RCP26[[var]][is.na(predictor_df_2030_irr_RCP26[[var]])] <- mean(predictor_df_2030_irr_RCP26[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2030_irr_RCP26 <- predict(RFa_model, newdata = predictor_df_2030_irr_RCP26, type = "response")

#Convert predictions to numeric
predictor_df_2030_irr_RCP26$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2030_irr_RCP26))

#Convert Predictions Back to Raster Format
fsi_raster_2030_irr_RCP26 <- rast(yield_2030_irr_RCP26)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2030_irr_RCP26) == ncell(fsi_raster_2030_irr_RCP26)) {  
  values(fsi_raster_2030_irr_RCP26) <- predictor_df_2030_irr_RCP26$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2030_irr_RCP26), "got", nrow(predictor_df_2030_irr_RCP26)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2030_irr_RCP26 <- mask(fsi_raster_2030_irr_RCP26, vect(ethiopia_outline_RCP26))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2030_irr_RCP26, "FSI_2030_RCP26_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2030_irr_RCP26, main = "Predicted Food Security (2030, RCP26 with Irrigation)")
```
ISIMIP2B RCP26 2050 no irrigation
```{r}
#Load the environmental predictor rasters for 2050 (RCP26 with no irrigation)
yield_2050_noirr_RCP26 <- rast("Ethiopia_wheat_RCP26_noirrigation_5km_2050 copy.tif")
soil_moisture_2050_noirr_RCP26 <- rast("CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2050 copy.tif")
population_2050_noirr_RCP26 <- rast("population_2050.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_RCP26 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_RCP26 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_RCP26 <- rast("Elevation_5km.tif")
rwi_2020_RCP26 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2050_RCP26 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2050_RCP26))) {
  st_crs(ethiopia_outline_2050_RCP26) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2050_noirr_RCP26 <- crs(yield_2050_noirr_RCP26)
target_res_2050_noirr_RCP26 <- res(yield_2050_noirr_RCP26)
target_ext_2050_noirr_RCP26 <- ext(yield_2050_noirr_RCP26) 

#List of rasters to align
rasters_list_2050_noirr_RCP26 <- list(soil_moisture_2050_noirr_RCP26, market_proximity_2020_RCP26, 
                                      road_proximity_2020_RCP26, population_2050_noirr_RCP26, 
                                      elevation_2020_RCP26, rwi_2020_RCP26)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2050_noirr_RCP26)) {
  rasters_list_2050_noirr_RCP26[[i]] <- project(rasters_list_2050_noirr_RCP26[[i]], target_crs_2050_noirr_RCP26) 
  rasters_list_2050_noirr_RCP26[[i]] <- resample(rasters_list_2050_noirr_RCP26[[i]], yield_2050_noirr_RCP26, method = "bilinear")
  rasters_list_2050_noirr_RCP26[[i]] <- crop(rasters_list_2050_noirr_RCP26[[i]], target_ext_2050_noirr_RCP26) 
  rasters_list_2050_noirr_RCP26[[i]] <- mask(rasters_list_2050_noirr_RCP26[[i]], yield_2050_noirr_RCP26)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2050_noirr_RCP26 <- c(yield_2050_noirr_RCP26, rasters_list_2050_noirr_RCP26[[1]], 
                                      rasters_list_2050_noirr_RCP26[[2]], rasters_list_2050_noirr_RCP26[[3]],
                                      rasters_list_2050_noirr_RCP26[[4]], rasters_list_2050_noirr_RCP26[[5]], 
                                      rasters_list_2050_noirr_RCP26[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2050_noirr_RCP26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2050_noirr_RCP26 <- as.data.frame(predictor_stack_2050_noirr_RCP26, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2050_noirr_RCP26)[-c(1,2)]) { 
  predictor_df_2050_noirr_RCP26[[var]][is.na(predictor_df_2050_noirr_RCP26[[var]])] <- mean(predictor_df_2050_noirr_RCP26[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2050_noirr_RCP26 <- predict(RFa_model, newdata = predictor_df_2050_noirr_RCP26, type = "response")

#Convert predictions to numeric
predictor_df_2050_noirr_RCP26$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2050_noirr_RCP26))

#Convert Predictions Back to Raster Format
fsi_raster_2050_noirr_RCP26 <- rast(yield_2050_noirr_RCP26)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2050_noirr_RCP26) == ncell(fsi_raster_2050_noirr_RCP26)) {  
  values(fsi_raster_2050_noirr_RCP26) <- predictor_df_2050_noirr_RCP26$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2050_noirr_RCP26), "got", nrow(predictor_df_2050_noirr_RCP26)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2050_noirr_RCP26 <- mask(fsi_raster_2050_noirr_RCP26, vect(ethiopia_outline_2050_RCP26))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2050_noirr_RCP26, "FSI_2050_RCP26_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2050_noirr_RCP26, main = "Predicted Food Security (2050, RCP26 without Irrigation)")
```

ISIMIP2B RCP26 2050 irrigation
```{r}

#Load the environmental predictor rasters for 2050 (RCP26 with irrigation)
yield_2050_irr_RCP26 <- rast("Ethiopia_Wheat_Irrigation_5km_2050.tif")
soil_moisture_2050_irr_RCP26 <- rast("CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2050 copy.tif")
population_2050_irr_RCP26 <- rast("population_2050.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_RCP26 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_RCP26 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_RCP26 <- rast("Elevation_5km.tif")
rwi_2020_RCP26 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2050_RCP26 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2050_RCP26))) {
  st_crs(ethiopia_outline_2050_RCP26) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2050_irr_RCP26 <- crs(yield_2050_irr_RCP26)
target_res_2050_irr_RCP26 <- res(yield_2050_irr_RCP26)
target_ext_2050_irr_RCP26 <- ext(yield_2050_irr_RCP26) 

#List of rasters to align
rasters_list_2050_irr_RCP26 <- list(soil_moisture_2050_irr_RCP26, market_proximity_2020_RCP26, 
                                    road_proximity_2020_RCP26, population_2050_irr_RCP26, 
                                    elevation_2020_RCP26, rwi_2020_RCP26)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2050_irr_RCP26)) {
  rasters_list_2050_irr_RCP26[[i]] <- project(rasters_list_2050_irr_RCP26[[i]], target_crs_2050_irr_RCP26) 
  rasters_list_2050_irr_RCP26[[i]] <- resample(rasters_list_2050_irr_RCP26[[i]], yield_2050_irr_RCP26, method = "bilinear")
  rasters_list_2050_irr_RCP26[[i]] <- crop(rasters_list_2050_irr_RCP26[[i]], target_ext_2050_irr_RCP26) 
  rasters_list_2050_irr_RCP26[[i]] <- mask(rasters_list_2050_irr_RCP26[[i]], yield_2050_irr_RCP26)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2050_irr_RCP26 <- c(yield_2050_irr_RCP26, rasters_list_2050_irr_RCP26[[1]], 
                                    rasters_list_2050_irr_RCP26[[2]], rasters_list_2050_irr_RCP26[[3]],
                                    rasters_list_2050_irr_RCP26[[4]], rasters_list_2050_irr_RCP26[[5]], 
                                    rasters_list_2050_irr_RCP26[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2050_irr_RCP26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                           "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2050_irr_RCP26 <- as.data.frame(predictor_stack_2050_irr_RCP26, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2050_irr_RCP26)[-c(1,2)]) { 
  predictor_df_2050_irr_RCP26[[var]][is.na(predictor_df_2050_irr_RCP26[[var]])] <- mean(predictor_df_2050_irr_RCP26[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2050_irr_RCP26 <- predict(RFa_model, newdata = predictor_df_2050_irr_RCP26, type = "response")

#Convert predictions to numeric
predictor_df_2050_irr_RCP26$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2050_irr_RCP26))

#Convert Predictions Back to Raster Format
fsi_raster_2050_irr_RCP26 <- rast(yield_2050_irr_RCP26)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2050_irr_RCP26) == ncell(fsi_raster_2050_irr_RCP26)) {  
  values(fsi_raster_2050_irr_RCP26) <- predictor_df_2050_irr_RCP26$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2050_irr_RCP26), "got", nrow(predictor_df_2050_irr_RCP26)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2050_irr_RCP26 <- mask(fsi_raster_2050_irr_RCP26, vect(ethiopia_outline_2050_RCP26))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2050_irr_RCP26, "FSI_2050_RCP26_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2050_irr_RCP26, main = "Predicted Food Security (2050, RCP26 with Irrigation)")
```

ISIMIP2B RCP26 2080 no irrigation
```{r}

#Load the environmental predictor rasters for 2080 (RCP26 without irrigation)
yield_2080_noirr_RCP26 <- rast("Ethiopia_wheat_RCP26_noirrigation_5km_2080 copy.tif")
soil_moisture_2080_noirr_RCP26 <- rast("CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2080 copy.tif")
population_2080_noirr_RCP26 <- rast("population_2080.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_RCP26 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_RCP26 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_RCP26 <- rast("Elevation_5km.tif")
rwi_2020_RCP26 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2080_RCP26 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2080_RCP26))) {
  st_crs(ethiopia_outline_2080_RCP26) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2080_noirr_RCP26 <- crs(yield_2080_noirr_RCP26)
target_res_2080_noirr_RCP26 <- res(yield_2080_noirr_RCP26)
target_ext_2080_noirr_RCP26 <- ext(yield_2080_noirr_RCP26) 

#List of rasters to align
rasters_list_2080_noirr_RCP26 <- list(soil_moisture_2080_noirr_RCP26, market_proximity_2020_RCP26, 
                                    road_proximity_2020_RCP26, population_2080_noirr_RCP26, 
                                    elevation_2020_RCP26, rwi_2020_RCP26)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2080_noirr_RCP26)) {
  rasters_list_2080_noirr_RCP26[[i]] <- project(rasters_list_2080_noirr_RCP26[[i]], target_crs_2080_noirr_RCP26) 
  rasters_list_2080_noirr_RCP26[[i]] <- resample(rasters_list_2080_noirr_RCP26[[i]], yield_2080_noirr_RCP26, method = "bilinear")
  rasters_list_2080_noirr_RCP26[[i]] <- crop(rasters_list_2080_noirr_RCP26[[i]], target_ext_2080_noirr_RCP26) 
  rasters_list_2080_noirr_RCP26[[i]] <- mask(rasters_list_2080_noirr_RCP26[[i]], yield_2080_noirr_RCP26)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2080_noirr_RCP26 <- c(yield_2080_noirr_RCP26, rasters_list_2080_noirr_RCP26[[1]], 
                                    rasters_list_2080_noirr_RCP26[[2]], rasters_list_2080_noirr_RCP26[[3]],
                                    rasters_list_2080_noirr_RCP26[[4]], rasters_list_2080_noirr_RCP26[[5]], 
                                    rasters_list_2080_noirr_RCP26[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2080_noirr_RCP26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                           "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2080_noirr_RCP26 <- as.data.frame(predictor_stack_2080_noirr_RCP26, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2080_noirr_RCP26)[-c(1,2)]) { 
  predictor_df_2080_noirr_RCP26[[var]][is.na(predictor_df_2080_noirr_RCP26[[var]])] <- mean(predictor_df_2080_noirr_RCP26[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2080_noirr_RCP26 <- predict(RFa_model, newdata = predictor_df_2080_noirr_RCP26, type = "response")

#Convert predictions to numeric
predictor_df_2080_noirr_RCP26$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2080_noirr_RCP26))

#Convert Predictions Back to Raster Format
fsi_raster_2080_noirr_RCP26 <- rast(yield_2080_noirr_RCP26)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2080_noirr_RCP26) == ncell(fsi_raster_2080_noirr_RCP26)) {  
  values(fsi_raster_2080_noirr_RCP26) <- predictor_df_2080_noirr_RCP26$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2080_noirr_RCP26), "got", nrow(predictor_df_2080_noirr_RCP26)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2080_noirr_RCP26 <- mask(fsi_raster_2080_noirr_RCP26, vect(ethiopia_outline_2080_RCP26))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2080_noirr_RCP26, "FSI_2080_RCP26_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2080_noirr_RCP26, main = "Predicted Food Security (2080, RCP26 without Irrigation)")
```


ISIMIP2B RCP26 2080 irrigation
```{r}
#Load the environmental predictor rasters for 2080 (RCP26 with irrigation)
yield_2080_irr_RCP26 <- rast("Ethiopia_RCP26_Wheat_Irrigation_5km_2080.tif")
soil_moisture_2080_irr_RCP26 <- rast("CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2080 copy.tif")
population_2080_irr_RCP26 <- rast("population_2080.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_RCP26 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_RCP26 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_RCP26 <- rast("Elevation_5km.tif")
rwi_2020_RCP26 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2080_RCP26 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2080_RCP26))) {
  st_crs(ethiopia_outline_2080_RCP26) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2080_irr_RCP26 <- crs(yield_2080_irr_RCP26)
target_res_2080_irr_RCP26 <- res(yield_2080_irr_RCP26)
target_ext_2080_irr_RCP26 <- ext(yield_2080_irr_RCP26) 

#List of rasters to align
rasters_list_2080_irr_RCP26 <- list(soil_moisture_2080_irr_RCP26, market_proximity_2020_RCP26, 
                                    road_proximity_2020_RCP26, population_2080_irr_RCP26, 
                                    elevation_2020_RCP26, rwi_2020_RCP26)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2080_irr_RCP26)) {
  rasters_list_2080_irr_RCP26[[i]] <- project(rasters_list_2080_irr_RCP26[[i]], target_crs_2080_irr_RCP26) 
  rasters_list_2080_irr_RCP26[[i]] <- resample(rasters_list_2080_irr_RCP26[[i]], yield_2080_irr_RCP26, method = "bilinear")
  rasters_list_2080_irr_RCP26[[i]] <- crop(rasters_list_2080_irr_RCP26[[i]], target_ext_2080_irr_RCP26) 
  rasters_list_2080_irr_RCP26[[i]] <- mask(rasters_list_2080_irr_RCP26[[i]], yield_2080_irr_RCP26)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2080_irr_RCP26 <- c(yield_2080_irr_RCP26, rasters_list_2080_irr_RCP26[[1]], 
                                    rasters_list_2080_irr_RCP26[[2]], rasters_list_2080_irr_RCP26[[3]],
                                    rasters_list_2080_irr_RCP26[[4]], rasters_list_2080_irr_RCP26[[5]], 
                                    rasters_list_2080_irr_RCP26[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2080_irr_RCP26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                           "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2080_irr_RCP26 <- as.data.frame(predictor_stack_2080_irr_RCP26, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2080_irr_RCP26)[-c(1,2)]) { 
  predictor_df_2080_irr_RCP26[[var]][is.na(predictor_df_2080_irr_RCP26[[var]])] <- mean(predictor_df_2080_irr_RCP26[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2080_irr_RCP26 <- predict(RFa_model, newdata = predictor_df_2080_irr_RCP26, type = "response")

#Convert predictions to numeric
predictor_df_2080_irr_RCP26$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2080_irr_RCP26))

#Convert Predictions Back to Raster Format
fsi_raster_2080_irr_RCP26 <- rast(yield_2080_irr_RCP26)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2080_irr_RCP26) == ncell(fsi_raster_2080_irr_RCP26)) {  
  values(fsi_raster_2080_irr_RCP26) <- predictor_df_2080_irr_RCP26$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2080_irr_RCP26), "got", nrow(predictor_df_2080_irr_RCP26)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2080_irr_RCP26 <- mask(fsi_raster_2080_irr_RCP26, vect(ethiopia_outline_2080_RCP26))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2080_irr_RCP26, "FSI_2080_RCP26_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2080_irr_RCP26, main = "Predicted Food Security (2080, RCP26 with Irrigation)")
```
ISIMIP2B RCP60 2030 NO irrigation
```{r}

#Load the environmental predictor rasters for 2030 (RCP60, No Irrigation)
yield_2030_noirr_RCP60 <- rast("Ethiopia_Wheat_RCP60_Irrigation_5km_2030 copy.tif") 
soil_moisture_2030_noirr_RCP60 <- rast("CLM45_RPC_60_Weighted_Average_Soil_Moisture_5km_2030 copy.tif")
population_2030_noirr_RCP60 <- rast("population_2030.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_RCP60 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_RCP60 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_RCP60 <- rast("Elevation_5km.tif")
rwi_2020_RCP60 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2030_RCP60 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2030_RCP60))) {
  st_crs(ethiopia_outline_2030_RCP60) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2030_noirr_RCP60 <- crs(yield_2030_noirr_RCP60)
target_res_2030_noirr_RCP60 <- res(yield_2030_noirr_RCP60)
target_ext_2030_noirr_RCP60 <- ext(yield_2030_noirr_RCP60) 

#List of rasters to align
rasters_list_2030_noirr_RCP60 <- list(soil_moisture_2030_noirr_RCP60, market_proximity_2020_RCP60, 
                                      road_proximity_2020_RCP60, population_2030_noirr_RCP60, 
                                      elevation_2020_RCP60, rwi_2020_RCP60)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2030_noirr_RCP60)) {
  rasters_list_2030_noirr_RCP60[[i]] <- project(rasters_list_2030_noirr_RCP60[[i]], target_crs_2030_noirr_RCP60) 
  rasters_list_2030_noirr_RCP60[[i]] <- resample(rasters_list_2030_noirr_RCP60[[i]], yield_2030_noirr_RCP60, method = "bilinear")
  rasters_list_2030_noirr_RCP60[[i]] <- crop(rasters_list_2030_noirr_RCP60[[i]], target_ext_2030_noirr_RCP60) 
  rasters_list_2030_noirr_RCP60[[i]] <- mask(rasters_list_2030_noirr_RCP60[[i]], yield_2030_noirr_RCP60)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2030_noirr_RCP60 <- c(yield_2030_noirr_RCP60, rasters_list_2030_noirr_RCP60[[1]], 
                                      rasters_list_2030_noirr_RCP60[[2]], rasters_list_2030_noirr_RCP60[[3]],
                                      rasters_list_2030_noirr_RCP60[[4]], rasters_list_2030_noirr_RCP60[[5]], 
                                      rasters_list_2030_noirr_RCP60[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2030_noirr_RCP60) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2030_noirr_RCP60 <- as.data.frame(predictor_stack_2030_noirr_RCP60, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2030_noirr_RCP60)[-c(1,2)]) { 
  predictor_df_2030_noirr_RCP60[[var]][is.na(predictor_df_2030_noirr_RCP60[[var]])] <- mean(predictor_df_2030_noirr_RCP60[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2030_noirr_RCP60 <- predict(RFa_model, newdata = predictor_df_2030_noirr_RCP60, type = "response")

#Convert predictions to numeric
predictor_df_2030_noirr_RCP60$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2030_noirr_RCP60))

#Convert Predictions Back to Raster Format
fsi_raster_2030_noirr_RCP60 <- rast(yield_2030_noirr_RCP60)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2030_noirr_RCP60) == ncell(fsi_raster_2030_noirr_RCP60)) {  
  values(fsi_raster_2030_noirr_RCP60) <- predictor_df_2030_noirr_RCP60$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2030_noirr_RCP60), "got", nrow(predictor_df_2030_noirr_RCP60)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2030_noirr_RCP60 <- mask(fsi_raster_2030_noirr_RCP60, vect(ethiopia_outline_2030_RCP60))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2030_noirr_RCP60, "FSI_2030_RCP60_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2030_noirr_RCP60, main = "Predicted Food Security (2030, RCP60, No Irrigation)")
```


ISIMIP2B RCP60 2030 irrigation
```{r}
#Load the environmental predictor rasters for 2030 (RCP60, With Irrigation)
yield_2030_irr_RCP60 <- rast("Ethiopia_Wheat_RCP60_Irrigation_5km_2030 copy.tif") 
soil_moisture_2030_irr_RCP60 <- rast("CLM45_RPC_60_Weighted_Average_Soil_Moisture_5km_2030 copy.tif")
population_2030_irr_RCP60 <- rast("population_2030.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_RCP60 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_RCP60 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_RCP60 <- rast("Elevation_5km.tif")
rwi_2020_RCP60 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2030_RCP60 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2030_RCP60))) {
  st_crs(ethiopia_outline_2030_RCP60) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2030_irr_RCP60 <- crs(yield_2030_irr_RCP60)
target_res_2030_irr_RCP60 <- res(yield_2030_irr_RCP60)
target_ext_2030_irr_RCP60 <- ext(yield_2030_irr_RCP60) 

#List of rasters to align
rasters_list_2030_irr_RCP60 <- list(soil_moisture_2030_irr_RCP60, market_proximity_2020_RCP60, 
                                    road_proximity_2020_RCP60, population_2030_irr_RCP60, 
                                    elevation_2020_RCP60, rwi_2020_RCP60)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2030_irr_RCP60)) {
  rasters_list_2030_irr_RCP60[[i]] <- project(rasters_list_2030_irr_RCP60[[i]], target_crs_2030_irr_RCP60) 
  rasters_list_2030_irr_RCP60[[i]] <- resample(rasters_list_2030_irr_RCP60[[i]], yield_2030_irr_RCP60, method = "bilinear")
  rasters_list_2030_irr_RCP60[[i]] <- crop(rasters_list_2030_irr_RCP60[[i]], target_ext_2030_irr_RCP60) 
  rasters_list_2030_irr_RCP60[[i]] <- mask(rasters_list_2030_irr_RCP60[[i]], yield_2030_irr_RCP60)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2030_irr_RCP60 <- c(yield_2030_irr_RCP60, rasters_list_2030_irr_RCP60[[1]], 
                                    rasters_list_2030_irr_RCP60[[2]], rasters_list_2030_irr_RCP60[[3]],
                                    rasters_list_2030_irr_RCP60[[4]], rasters_list_2030_irr_RCP60[[5]], 
                                    rasters_list_2030_irr_RCP60[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2030_irr_RCP60) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                           "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2030_irr_RCP60 <- as.data.frame(predictor_stack_2030_irr_RCP60, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2030_irr_RCP60)[-c(1,2)]) { 
  predictor_df_2030_irr_RCP60[[var]][is.na(predictor_df_2030_irr_RCP60[[var]])] <- mean(predictor_df_2030_irr_RCP60[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2030_irr_RCP60 <- predict(RFa_model, newdata = predictor_df_2030_irr_RCP60, type = "response")

#Convert predictions to numeric
predictor_df_2030_irr_RCP60$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2030_irr_RCP60))

#Convert Predictions Back to Raster Format
fsi_raster_2030_irr_RCP60 <- rast(yield_2030_irr_RCP60)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2030_irr_RCP60) == ncell(fsi_raster_2030_irr_RCP60)) {  
  values(fsi_raster_2030_irr_RCP60) <- predictor_df_2030_irr_RCP60$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2030_irr_RCP60), "got", nrow(predictor_df_2030_irr_RCP60)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2030_irr_RCP60 <- mask(fsi_raster_2030_irr_RCP60, vect(ethiopia_outline_2030_RCP60))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2030_irr_RCP60, "FSI_2030_RCP60_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2030_irr_RCP60, main = "Predicted Food Security (2030, RCP60, With Irrigation)")
```

ISIMIP2B RCP60 2050 NO irrigation
```{r}

#Load the environmental predictor rasters for 2050 (RCP60, No Irrigation)
yield_2050_noirr_RCP60 <- rast("Ethiopia_wheat_RCP60_noirrigation_5km_2050 copy.tif") 
soil_moisture_2050_noirr_RCP60 <- rast("CLM45_RPC_60_Weighted_Average_Soil_Moisture_5km_2050 copy.tif")
population_2050_noirr_RCP60 <- rast("population_2050.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_RCP60 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_RCP60 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_RCP60 <- rast("Elevation_5km.tif")
rwi_2020_RCP60 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2050_RCP60 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2050_RCP60))) {
  st_crs(ethiopia_outline_2050_RCP60) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2050_noirr_RCP60 <- crs(yield_2050_noirr_RCP60)
target_res_2050_noirr_RCP60 <- res(yield_2050_noirr_RCP60)
target_ext_2050_noirr_RCP60 <- ext(yield_2050_noirr_RCP60) 

#List of rasters to align
rasters_list_2050_noirr_RCP60 <- list(soil_moisture_2050_noirr_RCP60, market_proximity_2020_RCP60, 
                                      road_proximity_2020_RCP60, population_2050_noirr_RCP60, 
                                      elevation_2020_RCP60, rwi_2020_RCP60)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2050_noirr_RCP60)) {
  rasters_list_2050_noirr_RCP60[[i]] <- project(rasters_list_2050_noirr_RCP60[[i]], target_crs_2050_noirr_RCP60) 
  rasters_list_2050_noirr_RCP60[[i]] <- resample(rasters_list_2050_noirr_RCP60[[i]], yield_2050_noirr_RCP60, method = "bilinear")
  rasters_list_2050_noirr_RCP60[[i]] <- crop(rasters_list_2050_noirr_RCP60[[i]], target_ext_2050_noirr_RCP60) 
  rasters_list_2050_noirr_RCP60[[i]] <- mask(rasters_list_2050_noirr_RCP60[[i]], yield_2050_noirr_RCP60)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2050_noirr_RCP60 <- c(yield_2050_noirr_RCP60, rasters_list_2050_noirr_RCP60[[1]], 
                                      rasters_list_2050_noirr_RCP60[[2]], rasters_list_2050_noirr_RCP60[[3]],
                                      rasters_list_2050_noirr_RCP60[[4]], rasters_list_2050_noirr_RCP60[[5]], 
                                      rasters_list_2050_noirr_RCP60[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2050_noirr_RCP60) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2050_noirr_RCP60 <- as.data.frame(predictor_stack_2050_noirr_RCP60, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2050_noirr_RCP60)[-c(1,2)]) { 
  predictor_df_2050_noirr_RCP60[[var]][is.na(predictor_df_2050_noirr_RCP60[[var]])] <- mean(predictor_df_2050_noirr_RCP60[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2050_noirr_RCP60 <- predict(RFa_model, newdata = predictor_df_2050_noirr_RCP60, type = "response")

#Convert predictions to numeric
predictor_df_2050_noirr_RCP60$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2050_noirr_RCP60))

#Convert Predictions Back to Raster Format
fsi_raster_2050_noirr_RCP60 <- rast(yield_2050_noirr_RCP60)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2050_noirr_RCP60) == ncell(fsi_raster_2050_noirr_RCP60)) {  
  values(fsi_raster_2050_noirr_RCP60) <- predictor_df_2050_noirr_RCP60$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2050_noirr_RCP60), "got", nrow(predictor_df_2050_noirr_RCP60)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2050_noirr_RCP60 <- mask(fsi_raster_2050_noirr_RCP60, vect(ethiopia_outline_2050_RCP60))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2050_noirr_RCP60, "FSI_2050_RCP60_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2050_noirr_RCP60, main = "Predicted Food Security (2050, RCP60, No Irrigation)")
```


ISIMIP2B RCP60 2050 irrigation
```{r}

#Load the environmental predictor rasters for 2050 (RCP60, With Irrigation)
yield_2050_irr_RCP60 <- rast("Ethiopia_Wheat_Irrigation_5km_2050.tif") 
soil_moisture_2050_irr_RCP60 <- rast("CLM45_RPC_60_Weighted_Average_Soil_Moisture_5km_2050 copy.tif")
population_2050_irr_RCP60 <- rast("population_2050.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_RCP60 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_RCP60 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_RCP60 <- rast("Elevation_5km.tif")
rwi_2020_RCP60 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2050_RCP60 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2050_RCP60))) {
  st_crs(ethiopia_outline_2050_RCP60) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2050_irr_RCP60 <- crs(yield_2050_irr_RCP60)
target_res_2050_irr_RCP60 <- res(yield_2050_irr_RCP60)
target_ext_2050_irr_RCP60 <- ext(yield_2050_irr_RCP60) 

#List of rasters to align
rasters_list_2050_irr_RCP60 <- list(soil_moisture_2050_irr_RCP60, market_proximity_2020_RCP60, 
                                    road_proximity_2020_RCP60, population_2050_irr_RCP60, 
                                    elevation_2020_RCP60, rwi_2020_RCP60)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2050_irr_RCP60)) {
  rasters_list_2050_irr_RCP60[[i]] <- project(rasters_list_2050_irr_RCP60[[i]], target_crs_2050_irr_RCP60) 
  rasters_list_2050_irr_RCP60[[i]] <- resample(rasters_list_2050_irr_RCP60[[i]], yield_2050_irr_RCP60, method = "bilinear")
  rasters_list_2050_irr_RCP60[[i]] <- crop(rasters_list_2050_irr_RCP60[[i]], target_ext_2050_irr_RCP60) 
  rasters_list_2050_irr_RCP60[[i]] <- mask(rasters_list_2050_irr_RCP60[[i]], yield_2050_irr_RCP60)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2050_irr_RCP60 <- c(yield_2050_irr_RCP60, rasters_list_2050_irr_RCP60[[1]], 
                                    rasters_list_2050_irr_RCP60[[2]], rasters_list_2050_irr_RCP60[[3]],
                                    rasters_list_2050_irr_RCP60[[4]], rasters_list_2050_irr_RCP60[[5]], 
                                    rasters_list_2050_irr_RCP60[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2050_irr_RCP60) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                           "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2050_irr_RCP60 <- as.data.frame(predictor_stack_2050_irr_RCP60, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2050_irr_RCP60)[-c(1,2)]) { 
  predictor_df_2050_irr_RCP60[[var]][is.na(predictor_df_2050_irr_RCP60[[var]])] <- mean(predictor_df_2050_irr_RCP60[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2050_irr_RCP60 <- predict(RFa_model, newdata = predictor_df_2050_irr_RCP60, type = "response")

#Convert predictions to numeric
predictor_df_2050_irr_RCP60$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2050_irr_RCP60))

#Convert Predictions Back to Raster Format
fsi_raster_2050_irr_RCP60 <- rast(yield_2050_irr_RCP60)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2050_irr_RCP60) == ncell(fsi_raster_2050_irr_RCP60)) {  
  values(fsi_raster_2050_irr_RCP60) <- predictor_df_2050_irr_RCP60$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2050_irr_RCP60), "got", nrow(predictor_df_2050_irr_RCP60)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2050_irr_RCP60 <- mask(fsi_raster_2050_irr_RCP60, vect(ethiopia_outline_2050_RCP60))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2050_irr_RCP60, "FSI_2050_RCP60_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2050_irr_RCP60, main = "Predicted Food Security (2050, RCP60, With Irrigation)")
```

ISIMIP2B RCP60 2080 NO irrigation
```{r}

#Load the environmental predictor rasters for 2080 (RCP60, No Irrigation)
yield_2080_noirr_RCP60 <- rast("Ethiopia_wheat_RCP60_noirrigation_5km_2080 copy.tif") 
soil_moisture_2080_noirr_RCP60 <- rast("CLM45_RPC_60_Weighted_Average_Soil_Moisture_5km_2080 copy.tif")
population_2080_noirr_RCP60 <- rast("population_2080.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_RCP60 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_RCP60 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_RCP60 <- rast("Elevation_5km.tif")
rwi_2020_RCP60 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2080_RCP60 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2080_RCP60))) {
  st_crs(ethiopia_outline_2080_RCP60) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2080_noirr_RCP60 <- crs(yield_2080_noirr_RCP60)
target_res_2080_noirr_RCP60 <- res(yield_2080_noirr_RCP60)
target_ext_2080_noirr_RCP60 <- ext(yield_2080_noirr_RCP60) 

#List of rasters to align
rasters_list_2080_noirr_RCP60 <- list(soil_moisture_2080_noirr_RCP60, market_proximity_2020_RCP60, 
                                      road_proximity_2020_RCP60, population_2080_noirr_RCP60, 
                                      elevation_2020_RCP60, rwi_2020_RCP60)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2080_noirr_RCP60)) {
  rasters_list_2080_noirr_RCP60[[i]] <- project(rasters_list_2080_noirr_RCP60[[i]], target_crs_2080_noirr_RCP60) 
  rasters_list_2080_noirr_RCP60[[i]] <- resample(rasters_list_2080_noirr_RCP60[[i]], yield_2080_noirr_RCP60, method = "bilinear")
  rasters_list_2080_noirr_RCP60[[i]] <- crop(rasters_list_2080_noirr_RCP60[[i]], target_ext_2080_noirr_RCP60) 
  rasters_list_2080_noirr_RCP60[[i]] <- mask(rasters_list_2080_noirr_RCP60[[i]], yield_2080_noirr_RCP60)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2080_noirr_RCP60 <- c(yield_2080_noirr_RCP60, rasters_list_2080_noirr_RCP60[[1]], 
                                      rasters_list_2080_noirr_RCP60[[2]], rasters_list_2080_noirr_RCP60[[3]],
                                      rasters_list_2080_noirr_RCP60[[4]], rasters_list_2080_noirr_RCP60[[5]], 
                                      rasters_list_2080_noirr_RCP60[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2080_noirr_RCP60) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2080_noirr_RCP60 <- as.data.frame(predictor_stack_2080_noirr_RCP60, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2080_noirr_RCP60)[-c(1,2)]) { 
  predictor_df_2080_noirr_RCP60[[var]][is.na(predictor_df_2080_noirr_RCP60[[var]])] <- mean(predictor_df_2080_noirr_RCP60[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2080_noirr_RCP60 <- predict(RFa_model, newdata = predictor_df_2080_noirr_RCP60, type = "response")

#Convert predictions to numeric
predictor_df_2080_noirr_RCP60$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2080_noirr_RCP60))

#Convert Predictions Back to Raster Format
fsi_raster_2080_noirr_RCP60 <- rast(yield_2080_noirr_RCP60)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2080_noirr_RCP60) == ncell(fsi_raster_2080_noirr_RCP60)) {  
  values(fsi_raster_2080_noirr_RCP60) <- predictor_df_2080_noirr_RCP60$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2080_noirr_RCP60), "got", nrow(predictor_df_2080_noirr_RCP60)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2080_noirr_RCP60 <- mask(fsi_raster_2080_noirr_RCP60, vect(ethiopia_outline_2080_RCP60))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2080_noirr_RCP60, "FSI_2080_RCP60_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2080_noirr_RCP60, main = "Predicted Food Security (2080, RCP60, No Irrigation)")
```


ISIMIP2B RCP60 2080 irrigation
```{r}

#Load the environmental predictor rasters for 2080 (RCP60, With Irrigation)
yield_2080_irr_RCP60 <- rast("Ethiopia_RCP60_Wheat_Irrigation_5km_2080.tif") 
soil_moisture_2080_irr_RCP60 <- rast("CLM45_RPC_60_Weighted_Average_Soil_Moisture_5km_2080 copy.tif")
population_2080_irr_RCP60 <- rast("population_2080.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_RCP60 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_RCP60 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_RCP60 <- rast("Elevation_5km.tif")
rwi_2020_RCP60 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2080_RCP60 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2080_RCP60))) {
  st_crs(ethiopia_outline_2080_RCP60) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2080_irr_RCP60 <- crs(yield_2080_irr_RCP60)
target_res_2080_irr_RCP60 <- res(yield_2080_irr_RCP60)
target_ext_2080_irr_RCP60 <- ext(yield_2080_irr_RCP60) 

#List of rasters to align
rasters_list_2080_irr_RCP60 <- list(soil_moisture_2080_irr_RCP60, market_proximity_2020_RCP60, 
                                    road_proximity_2020_RCP60, population_2080_irr_RCP60, 
                                    elevation_2020_RCP60, rwi_2020_RCP60)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2080_irr_RCP60)) {
  rasters_list_2080_irr_RCP60[[i]] <- project(rasters_list_2080_irr_RCP60[[i]], target_crs_2080_irr_RCP60) 
  rasters_list_2080_irr_RCP60[[i]] <- resample(rasters_list_2080_irr_RCP60[[i]], yield_2080_irr_RCP60, method = "bilinear")
  rasters_list_2080_irr_RCP60[[i]] <- crop(rasters_list_2080_irr_RCP60[[i]], target_ext_2080_irr_RCP60) 
  rasters_list_2080_irr_RCP60[[i]] <- mask(rasters_list_2080_irr_RCP60[[i]], yield_2080_irr_RCP60)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2080_irr_RCP60 <- c(yield_2080_irr_RCP60, rasters_list_2080_irr_RCP60[[1]], 
                                    rasters_list_2080_irr_RCP60[[2]], rasters_list_2080_irr_RCP60[[3]],
                                    rasters_list_2080_irr_RCP60[[4]], rasters_list_2080_irr_RCP60[[5]], 
                                    rasters_list_2080_irr_RCP60[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2080_irr_RCP60) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                           "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2080_irr_RCP60 <- as.data.frame(predictor_stack_2080_irr_RCP60, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2080_irr_RCP60)[-c(1,2)]) { 
  predictor_df_2080_irr_RCP60[[var]][is.na(predictor_df_2080_irr_RCP60[[var]])] <- mean(predictor_df_2080_irr_RCP60[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2080_irr_RCP60 <- predict(RFa_model, newdata = predictor_df_2080_irr_RCP60, type = "response")

#Convert predictions to numeric
predictor_df_2080_irr_RCP60$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2080_irr_RCP60))

#Convert Predictions Back to Raster Format
fsi_raster_2080_irr_RCP60 <- rast(yield_2080_irr_RCP60)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2080_irr_RCP60) == ncell(fsi_raster_2080_irr_RCP60)) {  
  values(fsi_raster_2080_irr_RCP60) <- predictor_df_2080_irr_RCP60$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2080_irr_RCP60), "got", nrow(predictor_df_2080_irr_RCP60)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2080_irr_RCP60 <- mask(fsi_raster_2080_irr_RCP60, vect(ethiopia_outline_2080_RCP60))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2080_irr_RCP60, "FSI_2080_RCP60_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2080_irr_RCP60, main = "Predicted Food Security (2080, RCP60, With Irrigation)")
```

ISIMIP3B SSP1 26 2030 no irrigation
```{r}
#Load the environmental predictor rasters for 2030 (SSP1-26, No Irrigation)
yield_2030_noirr_SSP1_26 <- rast("Ethiopia_swheat_SSP1_26_3b_noirrigation_5km_2030 copy.tif") 
soil_moisture_2030_noirr_SSP1_26 <- rast("CLASSIC_SSP1_26_Weighted_Average_Soil_Moisture_5km_2030 copy.tif")
population_2030_noirr_SSP1_26 <- rast("population_2030.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP1_26 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP1_26 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP1_26 <- rast("Elevation_5km.tif")
rwi_2020_SSP1_26 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2030_SSP1_26 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2030_SSP1_26))) {
  st_crs(ethiopia_outline_2030_SSP1_26) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2030_noirr_SSP1_26 <- crs(yield_2030_noirr_SSP1_26)
target_res_2030_noirr_SSP1_26 <- res(yield_2030_noirr_SSP1_26)
target_ext_2030_noirr_SSP1_26 <- ext(yield_2030_noirr_SSP1_26) 

#List of rasters to align
rasters_list_2030_noirr_SSP1_26 <- list(soil_moisture_2030_noirr_SSP1_26, market_proximity_2020_SSP1_26, 
                                        road_proximity_2020_SSP1_26, population_2030_noirr_SSP1_26, 
                                        elevation_2020_SSP1_26, rwi_2020_SSP1_26)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2030_noirr_SSP1_26)) {
  rasters_list_2030_noirr_SSP1_26[[i]] <- project(rasters_list_2030_noirr_SSP1_26[[i]], target_crs_2030_noirr_SSP1_26) 
  rasters_list_2030_noirr_SSP1_26[[i]] <- resample(rasters_list_2030_noirr_SSP1_26[[i]], yield_2030_noirr_SSP1_26, method = "bilinear")
  rasters_list_2030_noirr_SSP1_26[[i]] <- crop(rasters_list_2030_noirr_SSP1_26[[i]], target_ext_2030_noirr_SSP1_26) 
  rasters_list_2030_noirr_SSP1_26[[i]] <- mask(rasters_list_2030_noirr_SSP1_26[[i]], yield_2030_noirr_SSP1_26)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2030_noirr_SSP1_26 <- c(yield_2030_noirr_SSP1_26, rasters_list_2030_noirr_SSP1_26[[1]], 
                                        rasters_list_2030_noirr_SSP1_26[[2]], rasters_list_2030_noirr_SSP1_26[[3]],
                                        rasters_list_2030_noirr_SSP1_26[[4]], rasters_list_2030_noirr_SSP1_26[[5]], 
                                        rasters_list_2030_noirr_SSP1_26[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2030_noirr_SSP1_26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                               "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2030_noirr_SSP1_26 <- as.data.frame(predictor_stack_2030_noirr_SSP1_26, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2030_noirr_SSP1_26)[-c(1,2)]) { 
  predictor_df_2030_noirr_SSP1_26[[var]][is.na(predictor_df_2030_noirr_SSP1_26[[var]])] <- mean(predictor_df_2030_noirr_SSP1_26[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2030_noirr_SSP1_26 <- predict(RFa_model, newdata = predictor_df_2030_noirr_SSP1_26, type = "response")

#Convert predictions to numeric
predictor_df_2030_noirr_SSP1_26$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2030_noirr_SSP1_26))

#Convert Predictions Back to Raster Format
fsi_raster_2030_noirr_SSP1_26 <- rast(yield_2030_noirr_SSP1_26)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2030_noirr_SSP1_26) == ncell(fsi_raster_2030_noirr_SSP1_26)) {  
  values(fsi_raster_2030_noirr_SSP1_26) <- predictor_df_2030_noirr_SSP1_26$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2030_noirr_SSP1_26), "got", nrow(predictor_df_2030_noirr_SSP1_26)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2030_noirr_SSP1_26 <- mask(fsi_raster_2030_noirr_SSP1_26, vect(ethiopia_outline_2030_SSP1_26))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2030_noirr_SSP1_26, "FSI_2030_SSP1_26_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2030_noirr_SSP1_26, main = "Predicted Food Security (2030, SSP1-26, No Irrigation)")
```
ISIMIP3B SSP1 26 2030 irrigation
```{r}
#Load the environmental predictor rasters for 2030 (SSP1-26, With Irrigation)
yield_2030_irr_SSP1_26 <- rast("Ethiopia_swheat_SSP1_26_3b_Irrigation_5km_2030 copy.tif") 
soil_moisture_2030_irr_SSP1_26 <- rast("CLASSIC_SSP1_26_Weighted_Average_Soil_Moisture_5km_2030 copy.tif")
population_2030_irr_SSP1_26 <- rast("population_2030.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP1_26 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP1_26 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP1_26 <- rast("Elevation_5km.tif")
rwi_2020_SSP1_26 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2030_SSP1_26 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2030_SSP1_26))) {
  st_crs(ethiopia_outline_2030_SSP1_26) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2030_irr_SSP1_26 <- crs(yield_2030_irr_SSP1_26)
target_res_2030_irr_SSP1_26 <- res(yield_2030_irr_SSP1_26)
target_ext_2030_irr_SSP1_26 <- ext(yield_2030_irr_SSP1_26) 

#List of rasters to align
rasters_list_2030_irr_SSP1_26 <- list(soil_moisture_2030_irr_SSP1_26, market_proximity_2020_SSP1_26, 
                                      road_proximity_2020_SSP1_26, population_2030_irr_SSP1_26, 
                                      elevation_2020_SSP1_26, rwi_2020_SSP1_26)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2030_irr_SSP1_26)) {
  rasters_list_2030_irr_SSP1_26[[i]] <- project(rasters_list_2030_irr_SSP1_26[[i]], target_crs_2030_irr_SSP1_26) 
  rasters_list_2030_irr_SSP1_26[[i]] <- resample(rasters_list_2030_irr_SSP1_26[[i]], yield_2030_irr_SSP1_26, method = "bilinear")
  rasters_list_2030_irr_SSP1_26[[i]] <- crop(rasters_list_2030_irr_SSP1_26[[i]], target_ext_2030_irr_SSP1_26) 
  rasters_list_2030_irr_SSP1_26[[i]] <- mask(rasters_list_2030_irr_SSP1_26[[i]], yield_2030_irr_SSP1_26)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2030_irr_SSP1_26 <- c(yield_2030_irr_SSP1_26, rasters_list_2030_irr_SSP1_26[[1]], 
                                      rasters_list_2030_irr_SSP1_26[[2]], rasters_list_2030_irr_SSP1_26[[3]],
                                      rasters_list_2030_irr_SSP1_26[[4]], rasters_list_2030_irr_SSP1_26[[5]], 
                                      rasters_list_2030_irr_SSP1_26[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2030_irr_SSP1_26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2030_irr_SSP1_26 <- as.data.frame(predictor_stack_2030_irr_SSP1_26, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2030_irr_SSP1_26)[-c(1,2)]) { 
  predictor_df_2030_irr_SSP1_26[[var]][is.na(predictor_df_2030_irr_SSP1_26[[var]])] <- mean(predictor_df_2030_irr_SSP1_26[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2030_irr_SSP1_26 <- predict(RFa_model, newdata = predictor_df_2030_irr_SSP1_26, type = "response")

#Convert predictions to numeric
predictor_df_2030_irr_SSP1_26$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2030_irr_SSP1_26))

#Convert Predictions Back to Raster Format
fsi_raster_2030_irr_SSP1_26 <- rast(yield_2030_irr_SSP1_26)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2030_irr_SSP1_26) == ncell(fsi_raster_2030_irr_SSP1_26)) {  
  values(fsi_raster_2030_irr_SSP1_26) <- predictor_df_2030_irr_SSP1_26$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2030_irr_SSP1_26), "got", nrow(predictor_df_2030_irr_SSP1_26)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2030_irr_SSP1_26 <- mask(fsi_raster_2030_irr_SSP1_26, vect(ethiopia_outline_2030_SSP1_26))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2030_irr_SSP1_26, "FSI_2030_SSP1_26_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2030_irr_SSP1_26, main = "Predicted Food Security (2030, SSP1-26, With Irrigation)")
```

ISIMIP3B SSP1 26 2050 no irrigation
```{r}
#Load the environmental predictor rasters for 2050 (SSP1-26, No Irrigation)
yield_2050_noirr_SSP1_26 <- rast("Ethiopia_SSP1_26_3b_swheat_noirrigation_5km_2050 copy.tif") 
soil_moisture_2050_noirr_SSP1_26 <- rast("CLASSIC_SSP1_26_Weighted_Average_Soil_Moisture_5km_2050 copy.tif")
population_2050_noirr_SSP1_26 <- rast("population_2050.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP1_26 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP1_26 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP1_26 <- rast("Elevation_5km.tif")
rwi_2020_SSP1_26 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2050_SSP1_26 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2050_SSP1_26))) {
  st_crs(ethiopia_outline_2050_SSP1_26) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2050_noirr_SSP1_26 <- crs(yield_2050_noirr_SSP1_26)
target_res_2050_noirr_SSP1_26 <- res(yield_2050_noirr_SSP1_26)
target_ext_2050_noirr_SSP1_26 <- ext(yield_2050_noirr_SSP1_26) 

#List of rasters to align
rasters_list_2050_noirr_SSP1_26 <- list(soil_moisture_2050_noirr_SSP1_26, market_proximity_2020_SSP1_26, 
                                        road_proximity_2020_SSP1_26, population_2050_noirr_SSP1_26, 
                                        elevation_2020_SSP1_26, rwi_2020_SSP1_26)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2050_noirr_SSP1_26)) {
  rasters_list_2050_noirr_SSP1_26[[i]] <- project(rasters_list_2050_noirr_SSP1_26[[i]], target_crs_2050_noirr_SSP1_26) 
  rasters_list_2050_noirr_SSP1_26[[i]] <- resample(rasters_list_2050_noirr_SSP1_26[[i]], yield_2050_noirr_SSP1_26, method = "bilinear")
  rasters_list_2050_noirr_SSP1_26[[i]] <- crop(rasters_list_2050_noirr_SSP1_26[[i]], target_ext_2050_noirr_SSP1_26) 
  rasters_list_2050_noirr_SSP1_26[[i]] <- mask(rasters_list_2050_noirr_SSP1_26[[i]], yield_2050_noirr_SSP1_26)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2050_noirr_SSP1_26 <- c(yield_2050_noirr_SSP1_26, rasters_list_2050_noirr_SSP1_26[[1]], 
                                        rasters_list_2050_noirr_SSP1_26[[2]], rasters_list_2050_noirr_SSP1_26[[3]],
                                        rasters_list_2050_noirr_SSP1_26[[4]], rasters_list_2050_noirr_SSP1_26[[5]], 
                                        rasters_list_2050_noirr_SSP1_26[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2050_noirr_SSP1_26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                               "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2050_noirr_SSP1_26 <- as.data.frame(predictor_stack_2050_noirr_SSP1_26, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2050_noirr_SSP1_26)[-c(1,2)]) { 
  predictor_df_2050_noirr_SSP1_26[[var]][is.na(predictor_df_2050_noirr_SSP1_26[[var]])] <- mean(predictor_df_2050_noirr_SSP1_26[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2050_noirr_SSP1_26 <- predict(RFa_model, newdata = predictor_df_2050_noirr_SSP1_26, type = "response")

#Convert predictions to numeric
predictor_df_2050_noirr_SSP1_26$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2050_noirr_SSP1_26))

#Convert Predictions Back to Raster Format
fsi_raster_2050_noirr_SSP1_26 <- rast(yield_2050_noirr_SSP1_26)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2050_noirr_SSP1_26) == ncell(fsi_raster_2050_noirr_SSP1_26)) {  
  values(fsi_raster_2050_noirr_SSP1_26) <- predictor_df_2050_noirr_SSP1_26$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2050_noirr_SSP1_26), "got", nrow(predictor_df_2050_noirr_SSP1_26)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2050_noirr_SSP1_26 <- mask(fsi_raster_2050_noirr_SSP1_26, vect(ethiopia_outline_2050_SSP1_26))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2050_noirr_SSP1_26, "FSI_2050_SSP1_26_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2050_noirr_SSP1_26, main = "Predicted Food Security (2050, SSP1-26, No Irrigation)")
```

ISIMIP3B SSP1 26 2050 irrigation
```{r}
#Load the environmental predictor rasters for 2050 (SSP1-26, With Irrigation)
yield_2050_irr_SSP1_26 <- rast("Ethiopia_SSP1_26_3b_swheat_Irrigation_5km_2050 copy.tif") 
soil_moisture_2050_irr_SSP1_26 <- rast("CLASSIC_SSP1_26_Weighted_Average_Soil_Moisture_5km_2050 copy.tif")
population_2050_irr_SSP1_26 <- rast("population_2050.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP1_26 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP1_26 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP1_26 <- rast("Elevation_5km.tif")
rwi_2020_SSP1_26 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2050_SSP1_26 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2050_SSP1_26))) {
  st_crs(ethiopia_outline_2050_SSP1_26) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2050_irr_SSP1_26 <- crs(yield_2050_irr_SSP1_26)
target_res_2050_irr_SSP1_26 <- res(yield_2050_irr_SSP1_26)
target_ext_2050_irr_SSP1_26 <- ext(yield_2050_irr_SSP1_26) 

#List of rasters to align
rasters_list_2050_irr_SSP1_26 <- list(soil_moisture_2050_irr_SSP1_26, market_proximity_2020_SSP1_26, 
                                      road_proximity_2020_SSP1_26, population_2050_irr_SSP1_26, 
                                      elevation_2020_SSP1_26, rwi_2020_SSP1_26)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2050_irr_SSP1_26)) {
  rasters_list_2050_irr_SSP1_26[[i]] <- project(rasters_list_2050_irr_SSP1_26[[i]], target_crs_2050_irr_SSP1_26) 
  rasters_list_2050_irr_SSP1_26[[i]] <- resample(rasters_list_2050_irr_SSP1_26[[i]], yield_2050_irr_SSP1_26, method = "bilinear")
  rasters_list_2050_irr_SSP1_26[[i]] <- crop(rasters_list_2050_irr_SSP1_26[[i]], target_ext_2050_irr_SSP1_26) 
  rasters_list_2050_irr_SSP1_26[[i]] <- mask(rasters_list_2050_irr_SSP1_26[[i]], yield_2050_irr_SSP1_26)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2050_irr_SSP1_26 <- c(yield_2050_irr_SSP1_26, rasters_list_2050_irr_SSP1_26[[1]], 
                                      rasters_list_2050_irr_SSP1_26[[2]], rasters_list_2050_irr_SSP1_26[[3]],
                                      rasters_list_2050_irr_SSP1_26[[4]], rasters_list_2050_irr_SSP1_26[[5]], 
                                      rasters_list_2050_irr_SSP1_26[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2050_irr_SSP1_26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2050_irr_SSP1_26 <- as.data.frame(predictor_stack_2050_irr_SSP1_26, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2050_irr_SSP1_26)[-c(1,2)]) { 
  predictor_df_2050_irr_SSP1_26[[var]][is.na(predictor_df_2050_irr_SSP1_26[[var]])] <- mean(predictor_df_2050_irr_SSP1_26[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2050_irr_SSP1_26 <- predict(RFa_model, newdata = predictor_df_2050_irr_SSP1_26, type = "response")

#Convert predictions to numeric
predictor_df_2050_irr_SSP1_26$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2050_irr_SSP1_26))

#Convert Predictions Back to Raster Format
fsi_raster_2050_irr_SSP1_26 <- rast(yield_2050_irr_SSP1_26)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2050_irr_SSP1_26) == ncell(fsi_raster_2050_irr_SSP1_26)) {  
  values(fsi_raster_2050_irr_SSP1_26) <- predictor_df_2050_irr_SSP1_26$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2050_irr_SSP1_26), "got", nrow(predictor_df_2050_irr_SSP1_26)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2050_irr_SSP1_26 <- mask(fsi_raster_2050_irr_SSP1_26, vect(ethiopia_outline_2050_SSP1_26))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2050_irr_SSP1_26, "FSI_2050_SSP1_26_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2050_irr_SSP1_26, main = "Predicted Food Security (2050, SSP1-26, With Irrigation)")
```

ISIMIP3B SSP1 26 2080 no irrigation
```{r}
#Load the environmental predictor rasters for 2080 (SSP1-26, No Irrigation)
yield_2080_noirr_SSP1_26 <- rast("Ethiopia_SSP1_26_3b_swheat_noirrigation_5km_2080 copy.tif") 
soil_moisture_2080_noirr_SSP1_26 <- rast("CLASSIC_SSP1_26_Weighted_Average_Soil_Moisture_5km_2080 copy.tif")
population_2080_noirr_SSP1_26 <- rast("population_2080.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP1_26 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP1_26 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP1_26 <- rast("Elevation_5km.tif")
rwi_2020_SSP1_26 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2080_SSP1_26 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2080_SSP1_26))) {
  st_crs(ethiopia_outline_2080_SSP1_26) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2080_noirr_SSP1_26 <- crs(yield_2080_noirr_SSP1_26)
target_res_2080_noirr_SSP1_26 <- res(yield_2080_noirr_SSP1_26)
target_ext_2080_noirr_SSP1_26 <- ext(yield_2080_noirr_SSP1_26) 

#List of rasters to align
rasters_list_2080_noirr_SSP1_26 <- list(soil_moisture_2080_noirr_SSP1_26, market_proximity_2020_SSP1_26, 
                                        road_proximity_2020_SSP1_26, population_2080_noirr_SSP1_26, 
                                        elevation_2020_SSP1_26, rwi_2020_SSP1_26)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2080_noirr_SSP1_26)) {
  rasters_list_2080_noirr_SSP1_26[[i]] <- project(rasters_list_2080_noirr_SSP1_26[[i]], target_crs_2080_noirr_SSP1_26) 
  rasters_list_2080_noirr_SSP1_26[[i]] <- resample(rasters_list_2080_noirr_SSP1_26[[i]], yield_2080_noirr_SSP1_26, method = "bilinear")
  rasters_list_2080_noirr_SSP1_26[[i]] <- crop(rasters_list_2080_noirr_SSP1_26[[i]], target_ext_2080_noirr_SSP1_26) 
  rasters_list_2080_noirr_SSP1_26[[i]] <- mask(rasters_list_2080_noirr_SSP1_26[[i]], yield_2080_noirr_SSP1_26)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2080_noirr_SSP1_26 <- c(yield_2080_noirr_SSP1_26, rasters_list_2080_noirr_SSP1_26[[1]], 
                                        rasters_list_2080_noirr_SSP1_26[[2]], rasters_list_2080_noirr_SSP1_26[[3]],
                                        rasters_list_2080_noirr_SSP1_26[[4]], rasters_list_2080_noirr_SSP1_26[[5]], 
                                        rasters_list_2080_noirr_SSP1_26[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2080_noirr_SSP1_26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                               "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2080_noirr_SSP1_26 <- as.data.frame(predictor_stack_2080_noirr_SSP1_26, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2080_noirr_SSP1_26)[-c(1,2)]) { 
  predictor_df_2080_noirr_SSP1_26[[var]][is.na(predictor_df_2080_noirr_SSP1_26[[var]])] <- mean(predictor_df_2080_noirr_SSP1_26[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2080_noirr_SSP1_26 <- predict(RFa_model, newdata = predictor_df_2080_noirr_SSP1_26, type = "response")

#Convert predictions to numeric
predictor_df_2080_noirr_SSP1_26$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2080_noirr_SSP1_26))

#Convert Predictions Back to Raster Format
fsi_raster_2080_noirr_SSP1_26 <- rast(yield_2080_noirr_SSP1_26)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2080_noirr_SSP1_26) == ncell(fsi_raster_2080_noirr_SSP1_26)) {  
  values(fsi_raster_2080_noirr_SSP1_26) <- predictor_df_2080_noirr_SSP1_26$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2080_noirr_SSP1_26), "got", nrow(predictor_df_2080_noirr_SSP1_26)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2080_noirr_SSP1_26 <- mask(fsi_raster_2080_noirr_SSP1_26, vect(ethiopia_outline_2080_SSP1_26))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2080_noirr_SSP1_26, "FSI_2080_SSP1_26_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2080_noirr_SSP1_26, main = "Predicted Food Security (2080, SSP1-26, No Irrigation)")
```

ISIMIP3B SSP1 26 2080 irrigation
```{r}
#Load the environmental predictor rasters for 2080 (SSP1-26, With Irrigation)
yield_2080_irr_SSP1_26 <- rast("Ethiopia_SSP1_26_3b_swheat_Irrigation_5km_2080 copy.tif") 
soil_moisture_2080_irr_SSP1_26 <- rast("CLASSIC_SSP1_26_Weighted_Average_Soil_Moisture_5km_2080 copy.tif")
population_2080_irr_SSP1_26 <- rast("population_2080.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP1_26 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP1_26 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP1_26 <- rast("Elevation_5km.tif")
rwi_2020_SSP1_26 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2080_SSP1_26 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2080_SSP1_26))) {
  st_crs(ethiopia_outline_2080_SSP1_26) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2080_irr_SSP1_26 <- crs(yield_2080_irr_SSP1_26)
target_res_2080_irr_SSP1_26 <- res(yield_2080_irr_SSP1_26)
target_ext_2080_irr_SSP1_26 <- ext(yield_2080_irr_SSP1_26) 

#List of rasters to align
rasters_list_2080_irr_SSP1_26 <- list(soil_moisture_2080_irr_SSP1_26, market_proximity_2020_SSP1_26, 
                                      road_proximity_2020_SSP1_26, population_2080_irr_SSP1_26, 
                                      elevation_2020_SSP1_26, rwi_2020_SSP1_26)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2080_irr_SSP1_26)) {
  rasters_list_2080_irr_SSP1_26[[i]] <- project(rasters_list_2080_irr_SSP1_26[[i]], target_crs_2080_irr_SSP1_26) 
  rasters_list_2080_irr_SSP1_26[[i]] <- resample(rasters_list_2080_irr_SSP1_26[[i]], yield_2080_irr_SSP1_26, method = "bilinear")
  rasters_list_2080_irr_SSP1_26[[i]] <- crop(rasters_list_2080_irr_SSP1_26[[i]], target_ext_2080_irr_SSP1_26) 
  rasters_list_2080_irr_SSP1_26[[i]] <- mask(rasters_list_2080_irr_SSP1_26[[i]], yield_2080_irr_SSP1_26)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2080_irr_SSP1_26 <- c(yield_2080_irr_SSP1_26, rasters_list_2080_irr_SSP1_26[[1]], 
                                      rasters_list_2080_irr_SSP1_26[[2]], rasters_list_2080_irr_SSP1_26[[3]],
                                      rasters_list_2080_irr_SSP1_26[[4]], rasters_list_2080_irr_SSP1_26[[5]], 
                                      rasters_list_2080_irr_SSP1_26[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2080_irr_SSP1_26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2080_irr_SSP1_26 <- as.data.frame(predictor_stack_2080_irr_SSP1_26, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2080_irr_SSP1_26)[-c(1,2)]) { 
  predictor_df_2080_irr_SSP1_26[[var]][is.na(predictor_df_2080_irr_SSP1_26[[var]])] <- mean(predictor_df_2080_irr_SSP1_26[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2080_irr_SSP1_26 <- predict(RFa_model, newdata = predictor_df_2080_irr_SSP1_26, type = "response")

#Convert predictions to numeric
predictor_df_2080_irr_SSP1_26$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2080_irr_SSP1_26))

#Convert Predictions Back to Raster Format
fsi_raster_2080_irr_SSP1_26 <- rast(yield_2080_irr_SSP1_26)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2080_irr_SSP1_26) == ncell(fsi_raster_2080_irr_SSP1_26)) {  
  values(fsi_raster_2080_irr_SSP1_26) <- predictor_df_2080_irr_SSP1_26$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2080_irr_SSP1_26), "got", nrow(predictor_df_2080_irr_SSP1_26)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2080_irr_SSP1_26 <- mask(fsi_raster_2080_irr_SSP1_26, vect(ethiopia_outline_2080_SSP1_26))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2080_irr_SSP1_26, "FSI_2080_SSP1_26_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2080_irr_SSP1_26, main = "Predicted Food Security (2080, SSP1-26, With Irrigation)")
```

ISIMIP3B SSP3 70 2030 no irrigation
```{r}
#Load the environmental predictor rasters for 2030 (SSP3-70, No Irrigation)
yield_2030_noirr_SSP3_70 <- rast("Ethiopia_swheat_SSP3_70_3b_noirrigation_5km_2030 copy.tif") 
soil_moisture_2030_noirr_SSP3_70 <- rast("CLASSIC_SSP3_70_Weighted_Average_Soil_Moisture_5km_2030 copy.tif")
population_2030_noirr_SSP3_70 <- rast("population_2030.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP3_70 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP3_70 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP3_70 <- rast("Elevation_5km.tif")
rwi_2020_SSP3_70 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2030_SSP3_70 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2030_SSP3_70))) {
  st_crs(ethiopia_outline_2030_SSP3_70) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2030_noirr_SSP3_70 <- crs(yield_2030_noirr_SSP3_70)
target_res_2030_noirr_SSP3_70 <- res(yield_2030_noirr_SSP3_70)
target_ext_2030_noirr_SSP3_70 <- ext(yield_2030_noirr_SSP3_70) 

#List of rasters to align
rasters_list_2030_noirr_SSP3_70 <- list(soil_moisture_2030_noirr_SSP3_70, market_proximity_2020_SSP3_70, 
                                        road_proximity_2020_SSP3_70, population_2030_noirr_SSP3_70, 
                                        elevation_2020_SSP3_70, rwi_2020_SSP3_70)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2030_noirr_SSP3_70)) {
  rasters_list_2030_noirr_SSP3_70[[i]] <- project(rasters_list_2030_noirr_SSP3_70[[i]], target_crs_2030_noirr_SSP3_70) 
  rasters_list_2030_noirr_SSP3_70[[i]] <- resample(rasters_list_2030_noirr_SSP3_70[[i]], yield_2030_noirr_SSP3_70, method = "bilinear")
  rasters_list_2030_noirr_SSP3_70[[i]] <- crop(rasters_list_2030_noirr_SSP3_70[[i]], target_ext_2030_noirr_SSP3_70) 
  rasters_list_2030_noirr_SSP3_70[[i]] <- mask(rasters_list_2030_noirr_SSP3_70[[i]], yield_2030_noirr_SSP3_70)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2030_noirr_SSP3_70 <- c(yield_2030_noirr_SSP3_70, rasters_list_2030_noirr_SSP3_70[[1]], 
                                        rasters_list_2030_noirr_SSP3_70[[2]], rasters_list_2030_noirr_SSP3_70[[3]],
                                        rasters_list_2030_noirr_SSP3_70[[4]], rasters_list_2030_noirr_SSP3_70[[5]], 
                                        rasters_list_2030_noirr_SSP3_70[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2030_noirr_SSP3_70) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                               "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2030_noirr_SSP3_70 <- as.data.frame(predictor_stack_2030_noirr_SSP3_70, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2030_noirr_SSP3_70)[-c(1,2)]) { 
  predictor_df_2030_noirr_SSP3_70[[var]][is.na(predictor_df_2030_noirr_SSP3_70[[var]])] <- mean(predictor_df_2030_noirr_SSP3_70[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2030_noirr_SSP3_70 <- predict(RFa_model, newdata = predictor_df_2030_noirr_SSP3_70, type = "response")

#Convert predictions to numeric
predictor_df_2030_noirr_SSP3_70$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2030_noirr_SSP3_70))

#Convert Predictions Back to Raster Format
fsi_raster_2030_noirr_SSP3_70 <- rast(yield_2030_noirr_SSP3_70)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2030_noirr_SSP3_70) == ncell(fsi_raster_2030_noirr_SSP3_70)) {  
  values(fsi_raster_2030_noirr_SSP3_70) <- predictor_df_2030_noirr_SSP3_70$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2030_noirr_SSP3_70), "got", nrow(predictor_df_2030_noirr_SSP3_70)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2030_noirr_SSP3_70 <- mask(fsi_raster_2030_noirr_SSP3_70, vect(ethiopia_outline_2030_SSP3_70))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2030_noirr_SSP3_70, "FSI_2030_SSP3_70_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2030_noirr_SSP3_70, main = "Predicted Food Security (2030, SSP3-70, No Irrigation)")
```

ISIMIP3B SSP3 70 2030 irrigation
```{r}
#Load the environmental predictor rasters for 2030 (SSP3-70, With Irrigation)
yield_2030_irr_SSP3_70 <- rast("Ethiopia_swheat_SSP3_70_3b_Irrigation_5km_2030 copy.tif") 
soil_moisture_2030_irr_SSP3_70 <- rast("CLASSIC_SSP3_70_Weighted_Average_Soil_Moisture_5km_2030 copy.tif")
population_2030_irr_SSP3_70 <- rast("population_2030.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP3_70 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP3_70 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP3_70 <- rast("Elevation_5km.tif")
rwi_2020_SSP3_70 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2030_SSP3_70 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2030_SSP3_70))) {
  st_crs(ethiopia_outline_2030_SSP3_70) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2030_irr_SSP3_70 <- crs(yield_2030_irr_SSP3_70)
target_res_2030_irr_SSP3_70 <- res(yield_2030_irr_SSP3_70)
target_ext_2030_irr_SSP3_70 <- ext(yield_2030_irr_SSP3_70) 

#List of rasters to align
rasters_list_2030_irr_SSP3_70 <- list(soil_moisture_2030_irr_SSP3_70, market_proximity_2020_SSP3_70, 
                                      road_proximity_2020_SSP3_70, population_2030_irr_SSP3_70, 
                                      elevation_2020_SSP3_70, rwi_2020_SSP3_70)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2030_irr_SSP3_70)) {
  rasters_list_2030_irr_SSP3_70[[i]] <- project(rasters_list_2030_irr_SSP3_70[[i]], target_crs_2030_irr_SSP3_70) 
  rasters_list_2030_irr_SSP3_70[[i]] <- resample(rasters_list_2030_irr_SSP3_70[[i]], yield_2030_irr_SSP3_70, method = "bilinear")
  rasters_list_2030_irr_SSP3_70[[i]] <- crop(rasters_list_2030_irr_SSP3_70[[i]], target_ext_2030_irr_SSP3_70) 
  rasters_list_2030_irr_SSP3_70[[i]] <- mask(rasters_list_2030_irr_SSP3_70[[i]], yield_2030_irr_SSP3_70)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2030_irr_SSP3_70 <- c(yield_2030_irr_SSP3_70, rasters_list_2030_irr_SSP3_70[[1]], 
                                      rasters_list_2030_irr_SSP3_70[[2]], rasters_list_2030_irr_SSP3_70[[3]],
                                      rasters_list_2030_irr_SSP3_70[[4]], rasters_list_2030_irr_SSP3_70[[5]], 
                                      rasters_list_2030_irr_SSP3_70[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2030_irr_SSP3_70) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2030_irr_SSP3_70 <- as.data.frame(predictor_stack_2030_irr_SSP3_70, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2030_irr_SSP3_70)[-c(1,2)]) { 
  predictor_df_2030_irr_SSP3_70[[var]][is.na(predictor_df_2030_irr_SSP3_70[[var]])] <- mean(predictor_df_2030_irr_SSP3_70[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2030_irr_SSP3_70 <- predict(RFa_model, newdata = predictor_df_2030_irr_SSP3_70, type = "response")

#Convert predictions to numeric
predictor_df_2030_irr_SSP3_70$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2030_irr_SSP3_70))

#Convert Predictions Back to Raster Format
fsi_raster_2030_irr_SSP3_70 <- rast(yield_2030_irr_SSP3_70)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2030_irr_SSP3_70) == ncell(fsi_raster_2030_irr_SSP3_70)) {  
  values(fsi_raster_2030_irr_SSP3_70) <- predictor_df_2030_irr_SSP3_70$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2030_irr_SSP3_70), "got", nrow(predictor_df_2030_irr_SSP3_70)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2030_irr_SSP3_70 <- mask(fsi_raster_2030_irr_SSP3_70, vect(ethiopia_outline_2030_SSP3_70))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2030_irr_SSP3_70, "FSI_2030_SSP3_70_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2030_irr_SSP3_70, main = "Predicted Food Security (2030, SSP3-70, With Irrigation)")
```

ISIMIP3B SSP3 70 2050 no irrigation
```{r}
#Load the environmental predictor rasters for 2050 (SSP3-70, No Irrigation)
yield_2050_noirr_SSP3_70 <- rast("Ethiopia_SSP3_70_3b_swheat_noirrigation_5km_2050 copy.tif") 
soil_moisture_2050_noirr_SSP3_70 <- rast("CLASSIC_SSP3_70_Weighted_Average_Soil_Moisture_5km_2050 copy.tif")
population_2050_noirr_SSP3_70 <- rast("population_2050.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP3_70 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP3_70 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP3_70 <- rast("Elevation_5km.tif")
rwi_2020_SSP3_70 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2050_SSP3_70 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2050_SSP3_70))) {
  st_crs(ethiopia_outline_2050_SSP3_70) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2050_noirr_SSP3_70 <- crs(yield_2050_noirr_SSP3_70)
target_res_2050_noirr_SSP3_70 <- res(yield_2050_noirr_SSP3_70)
target_ext_2050_noirr_SSP3_70 <- ext(yield_2050_noirr_SSP3_70) 

#List of rasters to align
rasters_list_2050_noirr_SSP3_70 <- list(soil_moisture_2050_noirr_SSP3_70, market_proximity_2020_SSP3_70, 
                                        road_proximity_2020_SSP3_70, population_2050_noirr_SSP3_70, 
                                        elevation_2020_SSP3_70, rwi_2020_SSP3_70)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2050_noirr_SSP3_70)) {
  rasters_list_2050_noirr_SSP3_70[[i]] <- project(rasters_list_2050_noirr_SSP3_70[[i]], target_crs_2050_noirr_SSP3_70) 
  rasters_list_2050_noirr_SSP3_70[[i]] <- resample(rasters_list_2050_noirr_SSP3_70[[i]], yield_2050_noirr_SSP3_70, method = "bilinear")
  rasters_list_2050_noirr_SSP3_70[[i]] <- crop(rasters_list_2050_noirr_SSP3_70[[i]], target_ext_2050_noirr_SSP3_70) 
  rasters_list_2050_noirr_SSP3_70[[i]] <- mask(rasters_list_2050_noirr_SSP3_70[[i]], yield_2050_noirr_SSP3_70)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2050_noirr_SSP3_70 <- c(yield_2050_noirr_SSP3_70, rasters_list_2050_noirr_SSP3_70[[1]], 
                                        rasters_list_2050_noirr_SSP3_70[[2]], rasters_list_2050_noirr_SSP3_70[[3]],
                                        rasters_list_2050_noirr_SSP3_70[[4]], rasters_list_2050_noirr_SSP3_70[[5]], 
                                        rasters_list_2050_noirr_SSP3_70[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2050_noirr_SSP3_70) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                               "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2050_noirr_SSP3_70 <- as.data.frame(predictor_stack_2050_noirr_SSP3_70, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2050_noirr_SSP3_70)[-c(1,2)]) { 
  predictor_df_2050_noirr_SSP3_70[[var]][is.na(predictor_df_2050_noirr_SSP3_70[[var]])] <- mean(predictor_df_2050_noirr_SSP3_70[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2050_noirr_SSP3_70 <- predict(RFa_model, newdata = predictor_df_2050_noirr_SSP3_70, type = "response")

#Convert predictions to numeric
predictor_df_2050_noirr_SSP3_70$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2050_noirr_SSP3_70))

#Convert Predictions Back to Raster Format
fsi_raster_2050_noirr_SSP3_70 <- rast(yield_2050_noirr_SSP3_70)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2050_noirr_SSP3_70) == ncell(fsi_raster_2050_noirr_SSP3_70)) {  
  values(fsi_raster_2050_noirr_SSP3_70) <- predictor_df_2050_noirr_SSP3_70$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2050_noirr_SSP3_70), "got", nrow(predictor_df_2050_noirr_SSP3_70)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2050_noirr_SSP3_70 <- mask(fsi_raster_2050_noirr_SSP3_70, vect(ethiopia_outline_2050_SSP3_70))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2050_noirr_SSP3_70, "FSI_2050_SSP3_70_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2050_noirr_SSP3_70, main = "Predicted Food Security (2050, SSP3-70, No Irrigation)")
```

ISIMIP3B SSP3 70 2050 irrigation
Ethiopia_SSP3_70_3b_swheat_Irrigation_5km_2050 copy.tif
```{r}
#Load the environmental predictor rasters for 2050 (SSP3-70, With Irrigation)
yield_2050_irr_SSP3_70 <- rast("Ethiopia_SSP3_70_3b_swheat_Irrigation_5km_2050 copy.tif") 
soil_moisture_2050_irr_SSP3_70 <- rast("CLASSIC_SSP3_70_Weighted_Average_Soil_Moisture_5km_2050 copy.tif")
population_2050_irr_SSP3_70 <- rast("population_2050.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP3_70 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP3_70 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP3_70 <- rast("Elevation_5km.tif")
rwi_2020_SSP3_70 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2050_SSP3_70 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2050_SSP3_70))) {
  st_crs(ethiopia_outline_2050_SSP3_70) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2050_irr_SSP3_70 <- crs(yield_2050_irr_SSP3_70)
target_res_2050_irr_SSP3_70 <- res(yield_2050_irr_SSP3_70)
target_ext_2050_irr_SSP3_70 <- ext(yield_2050_irr_SSP3_70) 

#List of rasters to align
rasters_list_2050_irr_SSP3_70 <- list(soil_moisture_2050_irr_SSP3_70, market_proximity_2020_SSP3_70, 
                                      road_proximity_2020_SSP3_70, population_2050_irr_SSP3_70, 
                                      elevation_2020_SSP3_70, rwi_2020_SSP3_70)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2050_irr_SSP3_70)) {
  rasters_list_2050_irr_SSP3_70[[i]] <- project(rasters_list_2050_irr_SSP3_70[[i]], target_crs_2050_irr_SSP3_70) 
  rasters_list_2050_irr_SSP3_70[[i]] <- resample(rasters_list_2050_irr_SSP3_70[[i]], yield_2050_irr_SSP3_70, method = "bilinear")
  rasters_list_2050_irr_SSP3_70[[i]] <- crop(rasters_list_2050_irr_SSP3_70[[i]], target_ext_2050_irr_SSP3_70) 
  rasters_list_2050_irr_SSP3_70[[i]] <- mask(rasters_list_2050_irr_SSP3_70[[i]], yield_2050_irr_SSP3_70)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2050_irr_SSP3_70 <- c(yield_2050_irr_SSP3_70, rasters_list_2050_irr_SSP3_70[[1]], 
                                      rasters_list_2050_irr_SSP3_70[[2]], rasters_list_2050_irr_SSP3_70[[3]],
                                      rasters_list_2050_irr_SSP3_70[[4]], rasters_list_2050_irr_SSP3_70[[5]], 
                                      rasters_list_2050_irr_SSP3_70[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2050_irr_SSP3_70) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2050_irr_SSP3_70 <- as.data.frame(predictor_stack_2050_irr_SSP3_70, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2050_irr_SSP3_70)[-c(1,2)]) { 
  predictor_df_2050_irr_SSP3_70[[var]][is.na(predictor_df_2050_irr_SSP3_70[[var]])] <- mean(predictor_df_2050_irr_SSP3_70[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2050_irr_SSP3_70 <- predict(RFa_model, newdata = predictor_df_2050_irr_SSP3_70, type = "response")

#Convert predictions to numeric
predictor_df_2050_irr_SSP3_70$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2050_irr_SSP3_70))

#Convert Predictions Back to Raster Format
fsi_raster_2050_irr_SSP3_70 <- rast(yield_2050_irr_SSP3_70)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2050_irr_SSP3_70) == ncell(fsi_raster_2050_irr_SSP3_70)) {  
  values(fsi_raster_2050_irr_SSP3_70) <- predictor_df_2050_irr_SSP3_70$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2050_irr_SSP3_70), "got", nrow(predictor_df_2050_irr_SSP3_70)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2050_irr_SSP3_70 <- mask(fsi_raster_2050_irr_SSP3_70, vect(ethiopia_outline_2050_SSP3_70))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2050_irr_SSP3_70, "FSI_2050_SSP3_70_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2050_irr_SSP3_70, main = "Predicted Food Security (2050, SSP3-70, With Irrigation)")
```

ISIMIP3B SSP3 70 2080 no irrigation
```{r}
#Load the environmental predictor rasters for 2080 (SSP3-70, No Irrigation)
yield_2080_noirr_SSP3_70 <- rast("Ethiopia_SSP3_70_3b_swheat_noirrigation_5km_2080 copy.tif") 
soil_moisture_2080_noirr_SSP3_70 <- rast("CLASSIC_SSP3_70_Weighted_Average_Soil_Moisture_5km_2080 copy.tif")
population_2080_noirr_SSP3_70 <- rast("population_2080.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP3_70 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP3_70 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP3_70 <- rast("Elevation_5km.tif")
rwi_2020_SSP3_70 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2080_SSP3_70 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2080_SSP3_70))) {
  st_crs(ethiopia_outline_2080_SSP3_70) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2080_noirr_SSP3_70 <- crs(yield_2080_noirr_SSP3_70)
target_res_2080_noirr_SSP3_70 <- res(yield_2080_noirr_SSP3_70)
target_ext_2080_noirr_SSP3_70 <- ext(yield_2080_noirr_SSP3_70) 

#List of rasters to align
rasters_list_2080_noirr_SSP3_70 <- list(soil_moisture_2080_noirr_SSP3_70, market_proximity_2020_SSP3_70, 
                                        road_proximity_2020_SSP3_70, population_2080_noirr_SSP3_70, 
                                        elevation_2020_SSP3_70, rwi_2020_SSP3_70)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2080_noirr_SSP3_70)) {
  rasters_list_2080_noirr_SSP3_70[[i]] <- project(rasters_list_2080_noirr_SSP3_70[[i]], target_crs_2080_noirr_SSP3_70) 
  rasters_list_2080_noirr_SSP3_70[[i]] <- resample(rasters_list_2080_noirr_SSP3_70[[i]], yield_2080_noirr_SSP3_70, method = "bilinear")
  rasters_list_2080_noirr_SSP3_70[[i]] <- crop(rasters_list_2080_noirr_SSP3_70[[i]], target_ext_2080_noirr_SSP3_70) 
  rasters_list_2080_noirr_SSP3_70[[i]] <- mask(rasters_list_2080_noirr_SSP3_70[[i]], yield_2080_noirr_SSP3_70)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2080_noirr_SSP3_70 <- c(yield_2080_noirr_SSP3_70, rasters_list_2080_noirr_SSP3_70[[1]], 
                                        rasters_list_2080_noirr_SSP3_70[[2]], rasters_list_2080_noirr_SSP3_70[[3]],
                                        rasters_list_2080_noirr_SSP3_70[[4]], rasters_list_2080_noirr_SSP3_70[[5]], 
                                        rasters_list_2080_noirr_SSP3_70[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2080_noirr_SSP3_70) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                               "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2080_noirr_SSP3_70 <- as.data.frame(predictor_stack_2080_noirr_SSP3_70, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2080_noirr_SSP3_70)[-c(1,2)]) { 
  predictor_df_2080_noirr_SSP3_70[[var]][is.na(predictor_df_2080_noirr_SSP3_70[[var]])] <- mean(predictor_df_2080_noirr_SSP3_70[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2080_noirr_SSP3_70 <- predict(RFa_model, newdata = predictor_df_2080_noirr_SSP3_70, type = "response")

#Convert predictions to numeric
predictor_df_2080_noirr_SSP3_70$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2080_noirr_SSP3_70))

#Convert Predictions Back to Raster Format
fsi_raster_2080_noirr_SSP3_70 <- rast(yield_2080_noirr_SSP3_70)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2080_noirr_SSP3_70) == ncell(fsi_raster_2080_noirr_SSP3_70)) {  
  values(fsi_raster_2080_noirr_SSP3_70) <- predictor_df_2080_noirr_SSP3_70$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2080_noirr_SSP3_70), "got", nrow(predictor_df_2080_noirr_SSP3_70)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2080_noirr_SSP3_70 <- mask(fsi_raster_2080_noirr_SSP3_70, vect(ethiopia_outline_2080_SSP3_70))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2080_noirr_SSP3_70, "FSI_2080_SSP3_70_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2080_noirr_SSP3_70, main = "Predicted Food Security (2080, SSP3-70, No Irrigation)")
```

ISIMIP3B SSP3 70 2080 irrigation
Ethiopia_SSP3_70_3b_swheat_Irrigation_5km_2080 copy.tif
```{r}
#Load the environmental predictor rasters for 2080 (SSP3-70, With Irrigation)
yield_2080_irr_SSP3_70 <- rast("Ethiopia_SSP3_70_3b_swheat_Irrigation_5km_2080 copy.tif") 
soil_moisture_2080_irr_SSP3_70 <- rast("CLASSIC_SSP3_70_Weighted_Average_Soil_Moisture_5km_2080 copy.tif")
population_2080_irr_SSP3_70 <- rast("population_2080.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP3_70 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP3_70 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP3_70 <- rast("Elevation_5km.tif")
rwi_2020_SSP3_70 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2080_SSP3_70 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2080_SSP3_70))) {
  st_crs(ethiopia_outline_2080_SSP3_70) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2080_irr_SSP3_70 <- crs(yield_2080_irr_SSP3_70)
target_res_2080_irr_SSP3_70 <- res(yield_2080_irr_SSP3_70)
target_ext_2080_irr_SSP3_70 <- ext(yield_2080_irr_SSP3_70) 

#List of rasters to align
rasters_list_2080_irr_SSP3_70 <- list(soil_moisture_2080_irr_SSP3_70, market_proximity_2020_SSP3_70, 
                                      road_proximity_2020_SSP3_70, population_2080_irr_SSP3_70, 
                                      elevation_2020_SSP3_70, rwi_2020_SSP3_70)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2080_irr_SSP3_70)) {
  rasters_list_2080_irr_SSP3_70[[i]] <- project(rasters_list_2080_irr_SSP3_70[[i]], target_crs_2080_irr_SSP3_70) 
  rasters_list_2080_irr_SSP3_70[[i]] <- resample(rasters_list_2080_irr_SSP3_70[[i]], yield_2080_irr_SSP3_70, method = "bilinear")
  rasters_list_2080_irr_SSP3_70[[i]] <- crop(rasters_list_2080_irr_SSP3_70[[i]], target_ext_2080_irr_SSP3_70) 
  rasters_list_2080_irr_SSP3_70[[i]] <- mask(rasters_list_2080_irr_SSP3_70[[i]], yield_2080_irr_SSP3_70)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2080_irr_SSP3_70 <- c(yield_2080_irr_SSP3_70, rasters_list_2080_irr_SSP3_70[[1]], 
                                      rasters_list_2080_irr_SSP3_70[[2]], rasters_list_2080_irr_SSP3_70[[3]],
                                      rasters_list_2080_irr_SSP3_70[[4]], rasters_list_2080_irr_SSP3_70[[5]], 
                                      rasters_list_2080_irr_SSP3_70[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2080_irr_SSP3_70) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2080_irr_SSP3_70 <- as.data.frame(predictor_stack_2080_irr_SSP3_70, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2080_irr_SSP3_70)[-c(1,2)]) { 
  predictor_df_2080_irr_SSP3_70[[var]][is.na(predictor_df_2080_irr_SSP3_70[[var]])] <- mean(predictor_df_2080_irr_SSP3_70[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2080_irr_SSP3_70 <- predict(RFa_model, newdata = predictor_df_2080_irr_SSP3_70, type = "response")

#Convert predictions to numeric
predictor_df_2080_irr_SSP3_70$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2080_irr_SSP3_70))

#Convert Predictions Back to Raster Format
fsi_raster_2080_irr_SSP3_70 <- rast(yield_2080_irr_SSP3_70)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2080_irr_SSP3_70) == ncell(fsi_raster_2080_irr_SSP3_70)) {  
  values(fsi_raster_2080_irr_SSP3_70) <- predictor_df_2080_irr_SSP3_70$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2080_irr_SSP3_70), "got", nrow(predictor_df_2080_irr_SSP3_70)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2080_irr_SSP3_70 <- mask(fsi_raster_2080_irr_SSP3_70, vect(ethiopia_outline_2080_SSP3_70))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2080_irr_SSP3_70, "FSI_2080_SSP3_70_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2080_irr_SSP3_70, main = "Predicted Food Security (2080, SSP3-70, With Irrigation)")
```

ISIMIP3B SSP5 85 2030 no irrigation
```{r}
#Load the environmental predictor rasters for 2030 (SSP5-85, No Irrigation)
yield_2030_noirr_SSP5_85 <- rast("Ethiopia_swheat_SSP5_85_3b_noirrigation_5km_2030 copy.tif") 
soil_moisture_2030_noirr_SSP5_85 <- rast("CLASSIC_SSP5_85_Weighted_Average_Soil_Moisture_5km_2030 copy.tif")
population_2030_noirr_SSP5_85 <- rast("population_2030.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP5_85 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP5_85 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP5_85 <- rast("Elevation_5km.tif")
rwi_2020_SSP5_85 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2030_SSP5_85 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2030_SSP5_85))) {
  st_crs(ethiopia_outline_2030_SSP5_85) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2030_noirr_SSP5_85 <- crs(yield_2030_noirr_SSP5_85)
target_res_2030_noirr_SSP5_85 <- res(yield_2030_noirr_SSP5_85)
target_ext_2030_noirr_SSP5_85 <- ext(yield_2030_noirr_SSP5_85) 

#List of rasters to align
rasters_list_2030_noirr_SSP5_85 <- list(soil_moisture_2030_noirr_SSP5_85, market_proximity_2020_SSP5_85, 
                                        road_proximity_2020_SSP5_85, population_2030_noirr_SSP5_85, 
                                        elevation_2020_SSP5_85, rwi_2020_SSP5_85)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2030_noirr_SSP5_85)) {
  rasters_list_2030_noirr_SSP5_85[[i]] <- project(rasters_list_2030_noirr_SSP5_85[[i]], target_crs_2030_noirr_SSP5_85) 
  rasters_list_2030_noirr_SSP5_85[[i]] <- resample(rasters_list_2030_noirr_SSP5_85[[i]], yield_2030_noirr_SSP5_85, method = "bilinear")
  rasters_list_2030_noirr_SSP5_85[[i]] <- crop(rasters_list_2030_noirr_SSP5_85[[i]], target_ext_2030_noirr_SSP5_85) 
  rasters_list_2030_noirr_SSP5_85[[i]] <- mask(rasters_list_2030_noirr_SSP5_85[[i]], yield_2030_noirr_SSP5_85)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2030_noirr_SSP5_85 <- c(yield_2030_noirr_SSP5_85, rasters_list_2030_noirr_SSP5_85[[1]], 
                                        rasters_list_2030_noirr_SSP5_85[[2]], rasters_list_2030_noirr_SSP5_85[[3]],
                                        rasters_list_2030_noirr_SSP5_85[[4]], rasters_list_2030_noirr_SSP5_85[[5]], 
                                        rasters_list_2030_noirr_SSP5_85[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2030_noirr_SSP5_85) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                               "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2030_noirr_SSP5_85 <- as.data.frame(predictor_stack_2030_noirr_SSP5_85, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2030_noirr_SSP5_85)[-c(1,2)]) { 
  predictor_df_2030_noirr_SSP5_85[[var]][is.na(predictor_df_2030_noirr_SSP5_85[[var]])] <- mean(predictor_df_2030_noirr_SSP5_85[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2030_noirr_SSP5_85 <- predict(RFa_model, newdata = predictor_df_2030_noirr_SSP5_85, type = "response")

#Convert predictions to numeric
predictor_df_2030_noirr_SSP5_85$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2030_noirr_SSP5_85))

#Convert Predictions Back to Raster Format
fsi_raster_2030_noirr_SSP5_85 <- rast(yield_2030_noirr_SSP5_85)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2030_noirr_SSP5_85) == ncell(fsi_raster_2030_noirr_SSP5_85)) {  
  values(fsi_raster_2030_noirr_SSP5_85) <- predictor_df_2030_noirr_SSP5_85$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2030_noirr_SSP5_85), "got", nrow(predictor_df_2030_noirr_SSP5_85)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2030_noirr_SSP5_85 <- mask(fsi_raster_2030_noirr_SSP5_85, vect(ethiopia_outline_2030_SSP5_85))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2030_noirr_SSP5_85, "FSI_2030_SSP5_85_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2030_noirr_SSP5_85, main = "Predicted Food Security (2030, SSP5-85, No Irrigation)")
```

ISIMIP3B SSP5 85 2030 irrigation

```{r}
#Load the environmental predictor rasters for 2030 (SSP5-85, With Irrigation)
yield_2030_irr_SSP5_85 <- rast("Ethiopia_swheat_SSP5_85_3b_Irrigation_5km_2030 copy.tif") 
soil_moisture_2030_irr_SSP5_85 <- rast("CLASSIC_SSP5_85_Weighted_Average_Soil_Moisture_5km_2030 copy.tif")
population_2030_irr_SSP5_85 <- rast("population_2030.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP5_85 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP5_85 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP5_85 <- rast("Elevation_5km.tif")
rwi_2020_SSP5_85 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2030_SSP5_85 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2030_SSP5_85))) {
  st_crs(ethiopia_outline_2030_SSP5_85) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2030_irr_SSP5_85 <- crs(yield_2030_irr_SSP5_85)
target_res_2030_irr_SSP5_85 <- res(yield_2030_irr_SSP5_85)
target_ext_2030_irr_SSP5_85 <- ext(yield_2030_irr_SSP5_85) 

#List of rasters to align
rasters_list_2030_irr_SSP5_85 <- list(soil_moisture_2030_irr_SSP5_85, market_proximity_2020_SSP5_85, 
                                      road_proximity_2020_SSP5_85, population_2030_irr_SSP5_85, 
                                      elevation_2020_SSP5_85, rwi_2020_SSP5_85)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2030_irr_SSP5_85)) {
  rasters_list_2030_irr_SSP5_85[[i]] <- project(rasters_list_2030_irr_SSP5_85[[i]], target_crs_2030_irr_SSP5_85) 
  rasters_list_2030_irr_SSP5_85[[i]] <- resample(rasters_list_2030_irr_SSP5_85[[i]], yield_2030_irr_SSP5_85, method = "bilinear")
  rasters_list_2030_irr_SSP5_85[[i]] <- crop(rasters_list_2030_irr_SSP5_85[[i]], target_ext_2030_irr_SSP5_85) 
  rasters_list_2030_irr_SSP5_85[[i]] <- mask(rasters_list_2030_irr_SSP5_85[[i]], yield_2030_irr_SSP5_85)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2030_irr_SSP5_85 <- c(yield_2030_irr_SSP5_85, rasters_list_2030_irr_SSP5_85[[1]], 
                                      rasters_list_2030_irr_SSP5_85[[2]], rasters_list_2030_irr_SSP5_85[[3]],
                                      rasters_list_2030_irr_SSP5_85[[4]], rasters_list_2030_irr_SSP5_85[[5]], 
                                      rasters_list_2030_irr_SSP5_85[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2030_irr_SSP5_85) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2030_irr_SSP5_85 <- as.data.frame(predictor_stack_2030_irr_SSP5_85, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2030_irr_SSP5_85)[-c(1,2)]) { 
  predictor_df_2030_irr_SSP5_85[[var]][is.na(predictor_df_2030_irr_SSP5_85[[var]])] <- mean(predictor_df_2030_irr_SSP5_85[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2030_irr_SSP5_85 <- predict(RFa_model, newdata = predictor_df_2030_irr_SSP5_85, type = "response")

#Convert predictions to numeric
predictor_df_2030_irr_SSP5_85$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2030_irr_SSP5_85))

#Convert Predictions Back to Raster Format
fsi_raster_2030_irr_SSP5_85 <- rast(yield_2030_irr_SSP5_85)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2030_irr_SSP5_85) == ncell(fsi_raster_2030_irr_SSP5_85)) {  
  values(fsi_raster_2030_irr_SSP5_85) <- predictor_df_2030_irr_SSP5_85$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2030_irr_SSP5_85), "got", nrow(predictor_df_2030_irr_SSP5_85)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2030_irr_SSP5_85 <- mask(fsi_raster_2030_irr_SSP5_85, vect(ethiopia_outline_2030_SSP5_85))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2030_irr_SSP5_85, "FSI_2030_SSP5_85_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2030_irr_SSP5_85, main = "Predicted Food Security (2030, SSP5-85, With Irrigation)")
```

ISIMIP3B SSP5 85 2050 no irrigation
```{r}
#Load the environmental predictor rasters for 2050 (SSP5-85, No Irrigation)
yield_2050_noirr_SSP5_85 <- rast("Ethiopia_SSP5_85_3b_swheat_noirrigation_5km_2050 copy.tif") 
soil_moisture_2050_noirr_SSP5_85 <- rast("CLASSIC_SSP5_85_Weighted_Average_Soil_Moisture_5km_2050 copy.tif")
population_2050_noirr_SSP5_85 <- rast("population_2050.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP5_85 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP5_85 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP5_85 <- rast("Elevation_5km.tif")
rwi_2020_SSP5_85 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2050_SSP5_85 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2050_SSP5_85))) {
  st_crs(ethiopia_outline_2050_SSP5_85) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2050_noirr_SSP5_85 <- crs(yield_2050_noirr_SSP5_85)
target_res_2050_noirr_SSP5_85 <- res(yield_2050_noirr_SSP5_85)
target_ext_2050_noirr_SSP5_85 <- ext(yield_2050_noirr_SSP5_85) 

#List of rasters to align
rasters_list_2050_noirr_SSP5_85 <- list(soil_moisture_2050_noirr_SSP5_85, market_proximity_2020_SSP5_85, 
                                        road_proximity_2020_SSP5_85, population_2050_noirr_SSP5_85, 
                                        elevation_2020_SSP5_85, rwi_2020_SSP5_85)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2050_noirr_SSP5_85)) {
  rasters_list_2050_noirr_SSP5_85[[i]] <- project(rasters_list_2050_noirr_SSP5_85[[i]], target_crs_2050_noirr_SSP5_85) 
  rasters_list_2050_noirr_SSP5_85[[i]] <- resample(rasters_list_2050_noirr_SSP5_85[[i]], yield_2050_noirr_SSP5_85, method = "bilinear")
  rasters_list_2050_noirr_SSP5_85[[i]] <- crop(rasters_list_2050_noirr_SSP5_85[[i]], target_ext_2050_noirr_SSP5_85) 
  rasters_list_2050_noirr_SSP5_85[[i]] <- mask(rasters_list_2050_noirr_SSP5_85[[i]], yield_2050_noirr_SSP5_85)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2050_noirr_SSP5_85 <- c(yield_2050_noirr_SSP5_85, rasters_list_2050_noirr_SSP5_85[[1]], 
                                        rasters_list_2050_noirr_SSP5_85[[2]], rasters_list_2050_noirr_SSP5_85[[3]],
                                        rasters_list_2050_noirr_SSP5_85[[4]], rasters_list_2050_noirr_SSP5_85[[5]], 
                                        rasters_list_2050_noirr_SSP5_85[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2050_noirr_SSP5_85) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                               "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2050_noirr_SSP5_85 <- as.data.frame(predictor_stack_2050_noirr_SSP5_85, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2050_noirr_SSP5_85)[-c(1,2)]) { 
  predictor_df_2050_noirr_SSP5_85[[var]][is.na(predictor_df_2050_noirr_SSP5_85[[var]])] <- mean(predictor_df_2050_noirr_SSP5_85[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2050_noirr_SSP5_85 <- predict(RFa_model, newdata = predictor_df_2050_noirr_SSP5_85, type = "response")

#Convert predictions to numeric
predictor_df_2050_noirr_SSP5_85$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2050_noirr_SSP5_85))

#Convert Predictions Back to Raster Format
fsi_raster_2050_noirr_SSP5_85 <- rast(yield_2050_noirr_SSP5_85)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2050_noirr_SSP5_85) == ncell(fsi_raster_2050_noirr_SSP5_85)) {  
  values(fsi_raster_2050_noirr_SSP5_85) <- predictor_df_2050_noirr_SSP5_85$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2050_noirr_SSP5_85), "got", nrow(predictor_df_2050_noirr_SSP5_85)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2050_noirr_SSP5_85 <- mask(fsi_raster_2050_noirr_SSP5_85, vect(ethiopia_outline_2050_SSP5_85))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2050_noirr_SSP5_85, "FSI_2050_SSP5_85_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2050_noirr_SSP5_85, main = "Predicted Food Security (2050, SSP5-85, No Irrigation)")
```

ISIMIP3B SSP5 85 2050 irrigation
```{r}
#Load the environmental predictor rasters for 2050 (SSP5-85, With Irrigation)
yield_2050_irr_SSP5_85 <- rast("Ethiopia_SSP5_85_3b_swheat_Irrigation_5km_2050 copy.tif") 
soil_moisture_2050_irr_SSP5_85 <- rast("CLASSIC_SSP5_85_Weighted_Average_Soil_Moisture_5km_2050 copy.tif")
population_2050_irr_SSP5_85 <- rast("population_2050.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP5_85 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP5_85 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP5_85 <- rast("Elevation_5km.tif")
rwi_2020_SSP5_85 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2050_SSP5_85 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2050_SSP5_85))) {
  st_crs(ethiopia_outline_2050_SSP5_85) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2050_irr_SSP5_85 <- crs(yield_2050_irr_SSP5_85)
target_res_2050_irr_SSP5_85 <- res(yield_2050_irr_SSP5_85)
target_ext_2050_irr_SSP5_85 <- ext(yield_2050_irr_SSP5_85) 

#List of rasters to align
rasters_list_2050_irr_SSP5_85 <- list(soil_moisture_2050_irr_SSP5_85, market_proximity_2020_SSP5_85, 
                                      road_proximity_2020_SSP5_85, population_2050_irr_SSP5_85, 
                                      elevation_2020_SSP5_85, rwi_2020_SSP5_85)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2050_irr_SSP5_85)) {
  rasters_list_2050_irr_SSP5_85[[i]] <- project(rasters_list_2050_irr_SSP5_85[[i]], target_crs_2050_irr_SSP5_85) 
  rasters_list_2050_irr_SSP5_85[[i]] <- resample(rasters_list_2050_irr_SSP5_85[[i]], yield_2050_irr_SSP5_85, method = "bilinear")
  rasters_list_2050_irr_SSP5_85[[i]] <- crop(rasters_list_2050_irr_SSP5_85[[i]], target_ext_2050_irr_SSP5_85) 
  rasters_list_2050_irr_SSP5_85[[i]] <- mask(rasters_list_2050_irr_SSP5_85[[i]], yield_2050_irr_SSP5_85)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2050_irr_SSP5_85 <- c(yield_2050_irr_SSP5_85, rasters_list_2050_irr_SSP5_85[[1]], 
                                      rasters_list_2050_irr_SSP5_85[[2]], rasters_list_2050_irr_SSP5_85[[3]],
                                      rasters_list_2050_irr_SSP5_85[[4]], rasters_list_2050_irr_SSP5_85[[5]], 
                                      rasters_list_2050_irr_SSP5_85[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2050_irr_SSP5_85) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2050_irr_SSP5_85 <- as.data.frame(predictor_stack_2050_irr_SSP5_85, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2050_irr_SSP5_85)[-c(1,2)]) { 
  predictor_df_2050_irr_SSP5_85[[var]][is.na(predictor_df_2050_irr_SSP5_85[[var]])] <- mean(predictor_df_2050_irr_SSP5_85[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2050_irr_SSP5_85 <- predict(RFa_model, newdata = predictor_df_2050_irr_SSP5_85, type = "response")

#Convert predictions to numeric
predictor_df_2050_irr_SSP5_85$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2050_irr_SSP5_85))

#Convert Predictions Back to Raster Format
fsi_raster_2050_irr_SSP5_85 <- rast(yield_2050_irr_SSP5_85)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2050_irr_SSP5_85) == ncell(fsi_raster_2050_irr_SSP5_85)) {  
  values(fsi_raster_2050_irr_SSP5_85) <- predictor_df_2050_irr_SSP5_85$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2050_irr_SSP5_85), "got", nrow(predictor_df_2050_irr_SSP5_85)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2050_irr_SSP5_85 <- mask(fsi_raster_2050_irr_SSP5_85, vect(ethiopia_outline_2050_SSP5_85))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2050_irr_SSP5_85, "FSI_2050_SSP5_85_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2050_irr_SSP5_85, main = "Predicted Food Security (2050, SSP5-85, With Irrigation)")

```

ISIMIP3B SSP5 85 2080 no irrigation
```{r}
#Load the environmental predictor rasters for 2080 (SSP5-85, No Irrigation)
yield_2080_noirr_SSP5_85 <- rast("Ethiopia_SSP5_85_3b_swheat_noirrigation_5km_2080 copy.tif") 
soil_moisture_2080_noirr_SSP5_85 <- rast("CLASSIC_SSP5_85_Weighted_Average_Soil_Moisture_5km_2080 copy.tif")
population_2080_noirr_SSP5_85 <- rast("population_2080.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP5_85 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP5_85 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP5_85 <- rast("Elevation_5km.tif")
rwi_2020_SSP5_85 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2080_SSP5_85 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2080_SSP5_85))) {
  st_crs(ethiopia_outline_2080_SSP5_85) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2080_noirr_SSP5_85 <- crs(yield_2080_noirr_SSP5_85)
target_res_2080_noirr_SSP5_85 <- res(yield_2080_noirr_SSP5_85)
target_ext_2080_noirr_SSP5_85 <- ext(yield_2080_noirr_SSP5_85) 

#List of rasters to align
rasters_list_2080_noirr_SSP5_85 <- list(soil_moisture_2080_noirr_SSP5_85, market_proximity_2020_SSP5_85, 
                                        road_proximity_2020_SSP5_85, population_2080_noirr_SSP5_85, 
                                        elevation_2020_SSP5_85, rwi_2020_SSP5_85)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2080_noirr_SSP5_85)) {
  rasters_list_2080_noirr_SSP5_85[[i]] <- project(rasters_list_2080_noirr_SSP5_85[[i]], target_crs_2080_noirr_SSP5_85) 
  rasters_list_2080_noirr_SSP5_85[[i]] <- resample(rasters_list_2080_noirr_SSP5_85[[i]], yield_2080_noirr_SSP5_85, method = "bilinear")
  rasters_list_2080_noirr_SSP5_85[[i]] <- crop(rasters_list_2080_noirr_SSP5_85[[i]], target_ext_2080_noirr_SSP5_85) 
  rasters_list_2080_noirr_SSP5_85[[i]] <- mask(rasters_list_2080_noirr_SSP5_85[[i]], yield_2080_noirr_SSP5_85)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2080_noirr_SSP5_85 <- c(yield_2080_noirr_SSP5_85, rasters_list_2080_noirr_SSP5_85[[1]], 
                                        rasters_list_2080_noirr_SSP5_85[[2]], rasters_list_2080_noirr_SSP5_85[[3]],
                                        rasters_list_2080_noirr_SSP5_85[[4]], rasters_list_2080_noirr_SSP5_85[[5]], 
                                        rasters_list_2080_noirr_SSP5_85[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2080_noirr_SSP5_85) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                               "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2080_noirr_SSP5_85 <- as.data.frame(predictor_stack_2080_noirr_SSP5_85, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2080_noirr_SSP5_85)[-c(1,2)]) { 
  predictor_df_2080_noirr_SSP5_85[[var]][is.na(predictor_df_2080_noirr_SSP5_85[[var]])] <- mean(predictor_df_2080_noirr_SSP5_85[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2080_noirr_SSP5_85 <- predict(RFa_model, newdata = predictor_df_2080_noirr_SSP5_85, type = "response")

#Convert predictions to numeric
predictor_df_2080_noirr_SSP5_85$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2080_noirr_SSP5_85))

#Convert Predictions Back to Raster Format
fsi_raster_2080_noirr_SSP5_85 <- rast(yield_2080_noirr_SSP5_85)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2080_noirr_SSP5_85) == ncell(fsi_raster_2080_noirr_SSP5_85)) {  
  values(fsi_raster_2080_noirr_SSP5_85) <- predictor_df_2080_noirr_SSP5_85$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2080_noirr_SSP5_85), "got", nrow(predictor_df_2080_noirr_SSP5_85)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2080_noirr_SSP5_85 <- mask(fsi_raster_2080_noirr_SSP5_85, vect(ethiopia_outline_2080_SSP5_85))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2080_noirr_SSP5_85, "FSI_2080_SSP5_85_noirr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2080_noirr_SSP5_85, main = "Predicted Food Security (2080, SSP5-85, No Irrigation)")
```

ISIMIP3B SSP5 85 2080 irrigation
```{r}
#Load the environmental predictor rasters for 2080 (SSP5-85, With Irrigation)
yield_2080_irr_SSP5_85 <- rast("Ethiopia_SSP5_85_3b_swheat_Irrigation_5km_2080 copy.tif") 
soil_moisture_2080_irr_SSP5_85 <- rast("CLASSIC_SSP5_85_Weighted_Average_Soil_Moisture_5km_2080 copy.tif")
population_2080_irr_SSP5_85 <- rast("population_2080.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP5_85 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP5_85 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP5_85 <- rast("Elevation_5km.tif")
rwi_2020_SSP5_85 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2080_SSP5_85 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2080_SSP5_85))) {
  st_crs(ethiopia_outline_2080_SSP5_85) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2080_irr_SSP5_85 <- crs(yield_2080_irr_SSP5_85)
target_res_2080_irr_SSP5_85 <- res(yield_2080_irr_SSP5_85)
target_ext_2080_irr_SSP5_85 <- ext(yield_2080_irr_SSP5_85) 

#List of rasters to align
rasters_list_2080_irr_SSP5_85 <- list(soil_moisture_2080_irr_SSP5_85, market_proximity_2020_SSP5_85, 
                                      road_proximity_2020_SSP5_85, population_2080_irr_SSP5_85, 
                                      elevation_2020_SSP5_85, rwi_2020_SSP5_85)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2080_irr_SSP5_85)) {
  rasters_list_2080_irr_SSP5_85[[i]] <- project(rasters_list_2080_irr_SSP5_85[[i]], target_crs_2080_irr_SSP5_85) 
  rasters_list_2080_irr_SSP5_85[[i]] <- resample(rasters_list_2080_irr_SSP5_85[[i]], yield_2080_irr_SSP5_85, method = "bilinear")
  rasters_list_2080_irr_SSP5_85[[i]] <- crop(rasters_list_2080_irr_SSP5_85[[i]], target_ext_2080_irr_SSP5_85) 
  rasters_list_2080_irr_SSP5_85[[i]] <- mask(rasters_list_2080_irr_SSP5_85[[i]], yield_2080_irr_SSP5_85)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2080_irr_SSP5_85 <- c(yield_2080_irr_SSP5_85, rasters_list_2080_irr_SSP5_85[[1]], 
                                      rasters_list_2080_irr_SSP5_85[[2]], rasters_list_2080_irr_SSP5_85[[3]],
                                      rasters_list_2080_irr_SSP5_85[[4]], rasters_list_2080_irr_SSP5_85[[5]], 
                                      rasters_list_2080_irr_SSP5_85[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2080_irr_SSP5_85) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2080_irr_SSP5_85 <- as.data.frame(predictor_stack_2080_irr_SSP5_85, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2080_irr_SSP5_85)[-c(1,2)]) { 
  predictor_df_2080_irr_SSP5_85[[var]][is.na(predictor_df_2080_irr_SSP5_85[[var]])] <- mean(predictor_df_2080_irr_SSP5_85[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2080_irr_SSP5_85 <- predict(RFa_model, newdata = predictor_df_2080_irr_SSP5_85, type = "response")

#Convert predictions to numeric
predictor_df_2080_irr_SSP5_85$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2080_irr_SSP5_85))

#Convert Predictions Back to Raster Format
fsi_raster_2080_irr_SSP5_85 <- rast(yield_2080_irr_SSP5_85)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2080_irr_SSP5_85) == ncell(fsi_raster_2080_irr_SSP5_85)) {  
  values(fsi_raster_2080_irr_SSP5_85) <- predictor_df_2080_irr_SSP5_85$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2080_irr_SSP5_85), "got", nrow(predictor_df_2080_irr_SSP5_85)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2080_irr_SSP5_85 <- mask(fsi_raster_2080_irr_SSP5_85, vect(ethiopia_outline_2080_SSP5_85))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2080_irr_SSP5_85, "FSI_2080_SSP5_85_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2080_irr_SSP5_85, main = "Predicted Food Security (2080, SSP5-85, With Irrigation)")
```



```{r}
#Load the predicted food security raster for the scenario (modify accordingly)
fsi_raster_2020_noirr_RCP26 <- rast("FSI_2020_RCP26_noirr.tif")
fsi_raster_2020_irr_RCP26 <- rast("FSI_2020_RCP26_irr.tif")

#Flip the values: 1 → 0, 0 → 1
fsi_raster_2020_noirr_RCP26 <- 1 - fsi_raster_2020_noirr_RCP26
fsi_raster_2020_irr_RCP26 <- 1 - fsi_raster_2020_irr_RCP26

#Convert raster values:
#- 1 (Food Secure) → Gray
#- 0 (Food Insecure) → Red
cols <- c("0" = "gray", "1" = "red")

#Load Ethiopia outline for masking
ethiopia_outline <- st_read("gadm41_ETH_0.shp")

#Load Ethiopia outline for masking
ethiopia_outline <- st_read("gadm41_ETH_0.shp")

#Load administrative boundaries (Level 2)
ethiopia_admin2 <- st_read("gadm41_ETH_2.shp")

#Convert to `terra` vector format
ethiopia_outline_v <- vect(ethiopia_outline)
ethiopia_admin2_v <- vect(ethiopia_admin2)


#Plot: Food Security Prediction (No Irrigation)
par(mar = c(0, 0, 2, 0))  
plot(fsi_raster_2020_noirr_RCP26, col = cols, legend = TRUE, main = "Predicted Food Security (2020, No Irrigation, RCP26)", axes = FALSE, box = FALSE)
#Add Ethiopia national boundary
plot(ethiopia_outline_v, add = TRUE, lwd = 2, border = "black")

#Add Level 2 administrative boundaries
plot(ethiopia_admin2_v, add = TRUE, lwd = 0.5, border = "black")

#Plot: Food Security Prediction (With Irrigation)
par(mar = c(0, 0, 2, 0))  
plot(fsi_raster_2020_irr_RCP26, col = cols, legend = TRUE, main = "Predicted Food Security (2020, Irrigation, RCP26)", axes = FALSE, box = FALSE)
plot(vect(ethiopia_outline), add = TRUE)
#Add Ethiopia national boundary
plot(ethiopia_outline_v, add = TRUE, lwd = 2, border = "black")

#Add Level 2 administrative boundaries
plot(ethiopia_admin2_v, add = TRUE, lwd = 0.5, border = "black")
```

```{r}

#List all predictor raster file paths
raster_files <- c("Ethiopia_wheat_RCP26_NoIrrigation_5km_2020 copy.tif",
                  "CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2020 copy.tif",
                  "population_2020.tif",
                  "Market_Proximity_2020_5km.tif",
                  "Road_Proximity_2020_5km.tif",
                  "Elevation_5km.tif",
                  "RWI_2020_5km.tif")

#Load rasters
yield_2020_noirr_RCP26 <- rast("Ethiopia_wheat_RCP26_NoIrrigation_5km_2020 copy.tif")
soil_moisture_2020_noirr_RCP26 <- rast("CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2020 copy.tif")
population_2020_noirr_RCP26 <- rast("population_2020.tif")
market_proximity_2020_RCP26 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_RCP26 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_RCP26 <- rast("Elevation_5km.tif")
rwi_2020_RCP26 <- rast("RWI_2020_5km.tif")


#Rename layers to match model variable names
names(predictor_stack_2020_noirr_RCP26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")



#Convert Raster Stack to DataFrame for Prediction
predictor_stack_2020_noirr_RCP26 <- as.data.frame(predictor_stack_2020_noirr_RCP26, xy = TRUE, na.rm = FALSE)

#Replace NA values with mean values of respective variables (to avoid missing data issues)
for (var in names(predictor_df_2020_noirr_RCP26)[-c(1,2)]) { 
  predictor_df_2020_noirr_RCP26[[var]][is.na(predictor_df_2020_noirr_RCP26[[var]])] <- mean(predictor_df_2020_noirr_RCP26[[var]], na.rm = TRUE)
}


#Predict Probabilities of Food Insecurity
predicted_prob_fsi_2020_noirr_RCP26 <- predict(RFa_model, newdata = predictor_df_2020_noirr_RCP26, type = "prob")

#Extract probabilities for the "food insecure" class
fsi_pred_prob_2020_noirr_RCP26 <- predicted_prob_fsi_2020_noirr_RCP26[,2] 

#Convert Predictions Back to Raster Format
fsi_prob_raster_2020_noirr_RCP26 <- rast(yield_2020_noirr_RCP26)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2020_noirr_RCP26) == ncell(fsi_prob_raster_2020_noirr_RCP26)) {  
  values(fsi_prob_raster_2020_noirr_RCP26) <- fsi_pred_prob_2020_noirr_RCP26
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_prob_raster_2020_noirr_RCP26), "got", nrow(predictor_df_2020_noirr_RCP26)))
}

#Mask the raster to Ethiopia boundary
fsi_prob_raster_2020_noirr_RCP26 <- mask(fsi_prob_raster_2020_noirr_RCP26, vect(ethiopia_outline))

#Save the Predicted Probability Raster
writeRaster(fsi_prob_raster_2020_noirr_RCP26, "FSI_Prob_2020_RCP26_noirr.tif", overwrite = TRUE)

#Flip the predicted probability values
fsi_prob_raster_2020_noirr_RCP26 <- 1 - fsi_prob_raster_2020_noirr_RCP26

#Plot the Predicted Probability of Food Insecurity with Improved Legend
tm_shape(fsi_prob_raster_2020_noirr_RCP26) +
    tm_raster(title = "Predicted Probability of Food Insecurity", 
              palette = "-RdYlBu", style = "cont", breaks = seq(0, 1, by = 0.1)) +
   tm_shape(ethiopia_outline) + 
    tm_borders(col = "black", lwd = 2) +  
    tm_shape(ethiopia_admin2) + 
    tm_borders(col = "black", lwd = 0.5) 
    tm_layout(main.title = "Predicted Probability of Food Insecurity (2020, RCP26, No Irrigation)", 
              main.title.position = "center", 
              title.size = 1.4, 
              legend.text.size = 1.2, 
              legend.title.size = 1.4,  
              legend.outside = TRUE, 
              legend.outside.position = "right",  
              legend.show = FALSE,  
              frame = FALSE)  + 
    tm_scale_bar(position = c(0.02, 0.02), text.size = 1, breaks = c(0, 100, 200)) +
    tm_compass(north = 0, type = 'arrow', position = c('right', 'bottom'), text.size = 0.9)
```


```{r}

#List all predictor raster file paths
raster_files <- c("Ethiopia_Wheat_RCP26_Irrigation_5km_2020 copy.tif",
                  "CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2020 copy.tif",
                  "population_2020.tif",
                  "Market_Proximity_2020_5km.tif",
                  "Road_Proximity_2020_5km.tif",
                  "Elevation_5km.tif",
                  "RWI_2020_5km.tif")

#Load rasters
yield_2020_irr_RCP26 <- rast("Ethiopia_wheat_RCP26_Irrigation_5km_2020 copy.tif")
soil_moisture_2020_irr_RCP26 <- rast("CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2020 copy.tif")
population_2020_irr_RCP26 <- rast("population_2020.tif")
market_proximity_2020_RCP26 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_RCP26 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_RCP26 <- rast("Elevation_5km.tif")
rwi_2020_RCP26 <- rast("RWI_2020_5km.tif")


#Rename layers to match model variable names
names(predictor_stack_2020_noirr_RCP26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")



#Convert Raster Stack to DataFrame for Prediction
predictor_stack_2020_irr_RCP26 <- as.data.frame(predictor_stack_2020_irr_RCP26, xy = TRUE, na.rm = FALSE)

#Replace NA values with mean values of respective variables (to avoid missing data issues)
for (var in names(predictor_df_2020_irr_RCP26)[-c(1,2)]) { 
  predictor_df_2020_irr_RCP26[[var]][is.na(predictor_df_2020_irr_RCP26[[var]])] <- mean(predictor_df_2020_irr_RCP26[[var]], na.rm = TRUE)
}


#Predict Probabilities of Food Insecurity
predicted_prob_fsi_2020_irr_RCP26 <- predict(RFa_model, newdata = predictor_df_2020_irr_RCP26, type = "prob")

#Extract probabilities for the "food insecure" class
fsi_pred_prob_2020_irr_RCP26 <- predicted_prob_fsi_2020_irr_RCP26[,2] 

#Convert Predictions Back to Raster Format
fsi_prob_raster_2020_irr_RCP26 <- rast(yield_2020_irr_RCP26)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2020_irr_RCP26) == ncell(fsi_prob_raster_2020_irr_RCP26)) {  
  values(fsi_prob_raster_2020_irr_RCP26) <- fsi_pred_prob_2020_irr_RCP26
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_prob_raster_2020_irr_RCP26), "got", nrow(predictor_df_2020_irr_RCP26)))
}

#Mask the raster to Ethiopia boundary
fsi_prob_raster_2020_irr_RCP26 <- mask(fsi_prob_raster_2020_irr_RCP26, vect(ethiopia_outline))

#Save the Predicted Probability Raster
writeRaster(fsi_prob_raster_2020_irr_RCP26, "FSI_Prob_2020_RCP26_irr.tif", overwrite = TRUE)

#Flip the predicted probability values
fsi_prob_raster_2020_irr_RCP26 <- 1 - fsi_prob_raster_2020_irr_RCP26

#Plot the Predicted Probability of Food Insecurity with Improved Legend
tm_shape(fsi_prob_raster_2020_irr_RCP26) +
    tm_raster(title = "Predicted Probability of Food Insecurity", 
              palette = "-RdYlBu", style = "cont", breaks = seq(0, 1, by = 0.1)) +
     tm_shape(ethiopia_outline) + 
    tm_borders(col = "black", lwd = 2) +  
    tm_shape(ethiopia_admin2) + 
    tm_borders(col = "black", lwd = 0.5) 
    tm_layout(main.title = "Predicted Probability of Food Insecurity (2020, RCP26 with Irrigation)", 
              main.title.position = "center", 
              title.size = 1.4, 
              legend.text.size = 1.2, 
              legend.title.size = 1.4,  
              legend.outside = TRUE, 
              legend.outside.position = "right",  
              legend.frame = FALSE,  
              frame = FALSE)  + 
    tm_scale_bar(position = c(0.02, 0.02), text.size = 1, breaks = c(0, 100, 200)) +
    tm_compass(north = 0, type = 'arrow', position = c('right', 'bottom'), text.size = 0.9)
```



```{r}

#Define raster file paths for different scenarios
fsi_raster_no_irrigation <- list(
  "2030 RCP26 No Irrigation"  = "FSI_2030_RCP26_noirr.tif",
  "2050 RCP26 No Irrigation"  = "FSI_2050_RCP26_noirr.tif",
  "2080 RCP26 No Irrigation"  = "FSI_2080_RCP26_noirr.tif",
  "2030 RCP60 No Irrigation"  = "FSI_2030_RCP60_noirr.tif",
  "2050 RCP60 No Irrigation"  = "FSI_2050_RCP60_noirr.tif",
  "2080 RCP60 No Irrigation"  = "FSI_2080_RCP60_noirr.tif"
)

fsi_raster_irrigation <- list(
  "2030 RCP26 With Irrigation" = "FSI_2030_RCP26_irr.tif",
  "2050 RCP26 With Irrigation" = "FSI_2050_RCP26_irr.tif",
  "2080 RCP26 With Irrigation" = "FSI_2080_RCP26_irr.tif",
  "2030 RCP60 With Irrigation" = "FSI_2030_RCP60_irr.tif",
  "2050 RCP60 With Irrigation" = "FSI_2050_RCP60_irr.tif",
  "2080 RCP60 With Irrigation" = "FSI_2080_RCP60_irr.tif"
)


#Load Ethiopia outline
ethiopia_outline <- st_read("gadm41_ETH_0.shp")

#Convert raster values:
#- 0 (Food Secure) → Gray
#- 1 (Food Insecure) → Red
cols <- c("0" = "gray", "1" = "red")

#Plot: No Irrigation Predictions
par(mfrow = c(2, 3))  

for (scenario in names(fsi_raster_no_irrigation)) {
  #Load the raster
  fsi_raster <- rast(fsi_raster_no_irrigation[[scenario]])

      #Flip values (1 → 0, 0 → 1)
  fsi_raster <- 1 - fsi_raster
  
  #Plot
  plot(fsi_raster, col = cols, legend = TRUE, main = paste("No Irrigation\n", scenario))
  
  #Overlay Ethiopia boundary
  plot(vect(ethiopia_outline), add = TRUE)
}

#Reset plot layout
par(mfrow = c(1, 1))

#Plot: With Irrigation Predictions
par(mfrow = c(2, 3))  

for (scenario in names(fsi_raster_irrigation)) {
  #Load the raster
  fsi_raster <- rast(fsi_raster_irrigation[[scenario]])
  
    #Flip values (1 → 0, 0 → 1)
  fsi_raster <- 1 - fsi_raster
  
  #Plot
  plot(fsi_raster, col = cols, legend = TRUE, main = paste("With Irrigation\n", scenario))
  
  #Overlay Ethiopia boundary
  plot(vect(ethiopia_outline), add = TRUE)
}

#Reset plot layout
par(mfrow = c(1, 1))
```

```{r}
#Define raster file paths for different scenarios (RCP)
fsi_raster_no_irrigation <- list(
  "2030_RCP26_No_Irrigation"  = "FSI_2030_RCP26_noirr.tif",
  "2050_RCP26_No_Irrigation"  = "FSI_2050_RCP26_noirr.tif",
  "2080_RCP26_No_Irrigation"  = "FSI_2080_RCP26_noirr.tif",
  "2030_RCP60_No_Irrigation"  = "FSI_2030_RCP60_noirr.tif",
  "2050_RCP60_No_Irrigation"  = "FSI_2050_RCP60_noirr.tif",
  "2080_RCP60_No_Irrigation"  = "FSI_2080_RCP60_noirr.tif"
)

fsi_raster_irrigation <- list(
  "2030_RCP26_With_Irrigation" = "FSI_2030_RCP26_irr.tif",
  "2050_RCP26_With_Irrigation" = "FSI_2050_RCP26_irr.tif",
  "2080_RCP26_With_Irrigation" = "FSI_2080_RCP26_irr.tif",
  "2030_RCP60_With_Irrigation" = "FSI_2030_RCP60_irr.tif",
  "2050_RCP60_With_Irrigation" = "FSI_2050_RCP60_irr.tif",
  "2080_RCP60_With_Irrigation" = "FSI_2080_RCP60_irr.tif"
)

#Load Ethiopia outline and zone boundaries
ethiopia_outline <- st_read("gadm41_ETH_0.shp")  
ethiopia_zones <- st_read("gadm41_ETH_2.shp")  

#Convert raster values:
#- 0 (Food Secure) → Gray
#- 1 (Food Insecure) → Red
cols <- c("0" = "gray", "1" = "red")

#Function to plot and save maps individually
save_fsi_maps_rcp <- function(fsi_raster_list, title_prefix) {
  for (scenario in names(fsi_raster_list)) {
    fsi_raster <- rast(fsi_raster_list[[scenario]])
    fsi_raster <- 1 - fsi_raster  #Flip values (1 → 0, 0 → 1)

    #Define file name
    output_file <- paste0("FSI_Map_", gsub(" ", "_", scenario), ".png")

    #Save PNG
    png(output_file, width = 800, height = 600, res = 150)

    #Plot without axes and box
    plot(fsi_raster, col = cols, legend = TRUE, main = paste(title_prefix, scenario), axes = FALSE, box = FALSE)

    #Overlay Ethiopia national boundary
    plot(vect(ethiopia_outline), add = TRUE, border = "black", lwd = 1.5)

    #Overlay Zone Boundaries
    plot(vect(ethiopia_zones), add = TRUE, border = "black", lwd = 1)

    #Close PNG device
    dev.off()

    cat("Saved:", output_file, "\n")
  }
}

#Save maps for No Irrigation scenarios
cat("Saving No Irrigation Maps...\n")
save_fsi_maps_rcp(fsi_raster_no_irrigation, "No Irrigation")

#Save maps for With Irrigation scenarios
cat("Saving With Irrigation Maps...\n")
save_fsi_maps_rcp(fsi_raster_irrigation, "With Irrigation")
```


```{r}

#Load Ethiopia outline and administrative boundaries
ethiopia_outline <- st_read("gadm41_ETH_0.shp")
ethiopia_admin2 <- st_read("gadm41_ETH_2.shp")

#Define raster file paths for NO IRRIGATION scenarios
predictor_raster_files_noirr <- list(
  "2030 RCP26 No Irrigation"  = "Ethiopia_wheat_RCP26_NoIrrigation_5km_2030 copy.tif",
  "2050 RCP26 No Irrigation"  = "Ethiopia_wheat_RCP26_NoIrrigation_5km_2050 copy.tif",
  "2080 RCP26 No Irrigation"  = "Ethiopia_wheat_RCP26_NoIrrigation_5km_2080 copy.tif",
  "2030 RCP60 No Irrigation"  = "Ethiopia_wheat_RCP60_NoIrrigation_5km_2030 copy.tif",
  "2050 RCP60 No Irrigation"  = "Ethiopia_wheat_RCP60_NoIrrigation_5km_2050 copy.tif",
  "2080 RCP60 No Irrigation"  = "Ethiopia_wheat_RCP60_NoIrrigation_5km_2080 copy.tif"
)


#Define raster file paths for IRRIGATION scenarios, adjusting filenames dynamically
predictor_raster_files_irr <- list(
  "2030 RCP26 With Irrigation"  = "Ethiopia_Wheat_RCP26_Irrigation_5km_2030 copy.tif",
  "2050 RCP26 With Irrigation"  = "Ethiopia_Wheat_Irrigation_5km_2050.tif",
  "2080 RCP26 With Irrigation"  = "Ethiopia_Wheat_Irrigation_5km_2080 copy.tif",
  "2030 RCP60 With Irrigation"  = "Ethiopia_Wheat_RCP60_Irrigation_5km_2030 copy.tif",
  "2050 RCP60 With Irrigation"  = "Ethiopia_Wheat_Irrigation_5km_2050.tif",
  "2080 RCP60 With Irrigation"  = "Ethiopia_RCP60_Wheat_Irrigation_5km_2080 copy.tif")




#Function to align and resample all predictors to match the reference raster
align_raster <- function(target_raster, reference_raster) {
  if (!compareGeom(target_raster, reference_raster, stopOnError = FALSE)) {
    cat("Resampling", names(target_raster), "to match reference raster\n")
    target_raster <- resample(target_raster, reference_raster, method = "bilinear") 
  }
  return(target_raster)
}

#Function to generate predicted probability maps dynamically selecting correct rasters
generate_fsi_probabilities <- function(predictor_raster_list, model, scenario_type) {
  for (scenario in names(predictor_raster_list)) {
    
    cat("Processing:", scenario, "\n")
    
    #Extract year from scenario name
    scenario_year <- gsub(".*?(\\d{4}).*", "\\1", scenario)  #Extracts 2030, 2050, 2080
    
    #Load predictor raster (Wheat Yield)
    predictor_raster <- rast(predictor_raster_list[[scenario]])
    
    #Define dynamically selected raster files
    soil_moisture_file <- paste0("CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_", scenario_year, " copy.tif")
    population_file <- paste0("population_", scenario_year, ".tif")
  

    #Load additional predictors
    soil_moisture_raster <- rast(soil_moisture_file)
    population_raster <- rast(population_file)
    market_proximity_raster <- rast("Market_Proximity_2020_5km.tif")
    road_proximity_raster <- rast("Road_Proximity_2020_5km.tif")
    elevation_raster <- rast("Elevation_5km.tif")
    rwi_raster <- rast("RWI_2020_5km.tif")

    #Align all rasters to the reference (wheat yield raster)
    soil_moisture_raster <- align_raster(soil_moisture_raster, predictor_raster)
    population_raster <- align_raster(population_raster, predictor_raster)
    market_proximity_raster <- align_raster(market_proximity_raster, predictor_raster)
    road_proximity_raster <- align_raster(road_proximity_raster, predictor_raster)
    elevation_raster <- align_raster(elevation_raster, predictor_raster)
    rwi_raster <- align_raster(rwi_raster, predictor_raster)

    #Stack aligned predictors
    predictor_stack <- c(
      predictor_raster,
      soil_moisture_raster,
      population_raster,
      market_proximity_raster,
      road_proximity_raster,
      elevation_raster,
      rwi_raster
    )

    #Rename layers to match model variables
    names(predictor_stack) <- c("Yield", "Soil_Moisture", "Population", 
                                "Market_Proximity", "Road_Proximity", 
                                "Elevation", "RWI")

    #Convert raster to dataframe for prediction
    predictor_df <- as.data.frame(predictor_stack, xy = TRUE, na.rm = FALSE)

    #Replace NA values with variable mean
    for (var in names(predictor_df)[-c(1,2)]) { 
      predictor_df[[var]][is.na(predictor_df[[var]])] <- mean(predictor_df[[var]], na.rm = TRUE)
    }

    #Predict probabilities of food insecurity
    predicted_prob_fsi <- predict(model, newdata = predictor_df, type = "prob")

    #Extract probabilities for food insecurity
    fsi_pred_prob <- predicted_prob_fsi[,2]

        #Flip the probability values so 1 → 0 and 0 → 1
    fsi_pred_prob <- 1 - fsi_pred_prob
    
    #Convert predictions back to raster format
    fsi_prob_raster <- rast(predictor_raster)

    #Assign values if dimensions match
    if (nrow(predictor_df) == ncell(fsi_prob_raster)) {  
      values(fsi_prob_raster) <- fsi_pred_prob
    } else {
      stop(paste("Error: Mismatch between raster cells and predictions for", scenario))
    }

    #Mask to Ethiopia boundary
    fsi_prob_raster <- mask(fsi_prob_raster, vect(ethiopia_outline))

    #Save probability raster
    output_raster_file <- paste0("FSI_Prob_", gsub(" ", "_", scenario), ".tif")
    writeRaster(fsi_prob_raster, output_raster_file, overwrite = TRUE)
    
    cat("Saved:", output_raster_file, "\n")
  }
}

#Run the function for both No Irrigation & Irrigation scenarios
generate_fsi_probabilities(predictor_raster_files_noirr, RFa_model, "NoIrrigation")
generate_fsi_probabilities(predictor_raster_files_irr, RFa_model, "Irrigation")
```

```{r}
#Function to visualize probability maps
generate_fsi_maps <- function(fsi_raster_list, scenario_type) {
  for (scenario in names(fsi_raster_list)) {
    fsi_raster <- rast(fsi_raster_list[[scenario]])
    
    #Plot the Corrected Probability Map
    map_plot <- tm_shape(fsi_raster) +
      tm_raster(title = "Predicted Probability of Food Insecurity", 
                palette = "-RdYlBu", style = "cont", breaks = seq(0, 1, by = 0.1)) +
      tm_shape(ethiopia_outline) + 
      tm_borders(col = "black", lwd = 2) +  
      tm_shape(ethiopia_admin2) + 
      tm_borders(col = "black", lwd = 0.5) +  
      tm_layout(main.title = paste("Food Insecurity:", scenario), 
                main.title.position = "center", 
                title.size = 1.4, 
                legend.text.size = 1.2, 
                legend.title.size = 1.4,  
                legend.outside = TRUE,  
                legend.outside.position = "right",  
                legend.frame = FALSE,  
                frame = FALSE) +  
      tm_scale_bar(position = c(0.02, 0.02), text.size = 1, breaks = c(0, 100, 200)) +
      tm_compass(north = 0, type = 'arrow', position = c('right', 'bottom'), text.size = 0.9)

    #Save as PNG
    output_file <- paste0("FSI_Map_", gsub(" ", "_", scenario), "_", scenario_type, ".png")
    tmap_save(map_plot, filename = output_file, width = 8, height = 6, dpi = 300)
    
    cat("Saved:", output_file, "\n")
  }
}

#Load generated probability rasters for visualization
fsi_prob_rasters_noirr <- list(
  "2030 RCP26 No Irrigation"  = "FSI_Prob_2030_RCP26_No_Irrigation.tif",
  "2050 RCP26 No Irrigation"  = "FSI_Prob_2050_RCP26_No_Irrigation.tif",
  "2080 RCP26 No Irrigation"  = "FSI_Prob_2080_RCP26_No_Irrigation.tif",
  "2030 RCP60 No Irrigation"  = "FSI_Prob_2030_RCP60_No_Irrigation.tif",
  "2050 RCP60 No Irrigation"  = "FSI_Prob_2050_RCP60_No_Irrigation.tif",
  "2080 RCP60 No Irrigation"  = "FSI_Prob_2080_RCP60_No_Irrigation.tif"
)


#Load generated probability rasters for IRRIGATION
fsi_prob_rasters_irr <- list(
  "2030 RCP26 With Irrigation"  = "FSI_Prob_2030_RCP26_With_Irrigation.tif",
  "2050 RCP26 With Irrigation"  = "FSI_Prob_2050_RCP26_With_Irrigation.tif",
  "2080 RCP26 With Irrigation"  = "FSI_Prob_2080_RCP26_With_Irrigation.tif",
  "2030 RCP60 With Irrigation"  = "FSI_Prob_2030_RCP60_With_Irrigation.tif",
  "2050 RCP60 With Irrigation"  = "FSI_Prob_2050_RCP60_With_Irrigation.tif",
  "2080 RCP60 With Irrigation"  = "FSI_Prob_2080_RCP60_With_Irrigation.tif"
)

#Generate visualization maps for NO IRRIGATION
cat("Generating No Irrigation Maps...\n")
generate_fsi_maps(fsi_prob_rasters_noirr, "No_Irrigation")

#Generate visualization maps for IRRIGATION
cat("Generating Irrigation Maps...\n")
generate_fsi_maps(fsi_prob_rasters_irr, "Irrigation")
```



```{r}
#Define raster file paths for different scenarios
fsi_raster_no_irrigation <- list(
  "2030 SSP1-26 No Irrigation"  = "FSI_2030_SSP1_26_noirr.tif",
  "2050 SSP1-26 No Irrigation"  = "FSI_2050_SSP1_26_noirr.tif",
  "2080 SSP1-26 No Irrigation"  = "FSI_2080_SSP1_26_noirr.tif",
  "2030 SSP3-70 No Irrigation"  = "FSI_2030_SSP3_70_noirr.tif",
  "2050 SSP3-70 No Irrigation"  = "FSI_2050_SSP3_70_noirr.tif",
  "2080 SSP3-70 No Irrigation"  = "FSI_2080_SSP3_70_noirr.tif",
  "2030 SSP5-85 No Irrigation"  = "FSI_2030_SSP5_85_noirr.tif",
  "2050 SSP5-85 No Irrigation"  = "FSI_2050_SSP5_85_noirr.tif",
  "2080 SSP5-85 No Irrigation"  = "FSI_2080_SSP5_85_noirr.tif"
)

fsi_raster_irrigation <- list(
  "2030 SSP1-26 With Irrigation" = "FSI_2030_SSP1_26_irr.tif",
  "2050 SSP1-26 With Irrigation" = "FSI_2050_SSP1_26_irr.tif",
  "2080 SSP1-26 With Irrigation" = "FSI_2080_SSP1_26_irr.tif",
  "2030 SSP3-70 With Irrigation" = "FSI_2030_SSP3_70_irr.tif",
  "2050 SSP3-70 With Irrigation" = "FSI_2050_SSP3_70_irr.tif",
  "2080 SSP3-70 With Irrigation" = "FSI_2080_SSP3_70_irr.tif",
  "2030 SSP5-85 With Irrigation" = "FSI_2030_SSP5_85_irr.tif",
  "2050 SSP5-85 With Irrigation" = "FSI_2050_SSP5_85_irr.tif",
  "2080 SSP5-85 With Irrigation" = "FSI_2080_SSP5_85_irr.tif"
)

#Load Ethiopia outline
ethiopia_outline <- st_read("gadm41_ETH_0.shp")

#Convert raster values:
#- 0 (Food Secure) → Gray
#- 1 (Food Insecure) → Red
cols <- c("0" = "gray", "1" = "red")

#Plot function
display_fsi_maps <- function(fsi_raster_list, title_prefix) {
  par(mfrow = c(3, 3))  
  for (scenario in names(fsi_raster_list)) {
    fsi_raster <- rast(fsi_raster_list[[scenario]])
      #Flip values (1 → 0, 0 → 1)
  fsi_raster <- 1 - fsi_raster
    plot(fsi_raster, col = cols, legend = TRUE, main = paste(title_prefix, scenario))
    plot(vect(ethiopia_outline), add = TRUE)
  }
  par(mfrow = c(1, 1)) 

}

#Plot maps
cat("Plotting No Irrigation Scenarios\n")
display_fsi_maps(fsi_raster_no_irrigation, "No Irrigation")

cat("Plotting With Irrigation Scenarios\n")
display_fsi_maps(fsi_raster_irrigation, "With Irrigation")
```

```{r}

#Define raster file paths for different scenarios
fsi_raster_no_irrigation <- list(
  "2030 SSP1-26 No Irrigation"  = "FSI_2030_SSP1_26_noirr.tif",
  "2050 SSP1-26 No Irrigation"  = "FSI_2050_SSP1_26_noirr.tif",
  "2080 SSP1-26 No Irrigation"  = "FSI_2080_SSP1_26_noirr.tif",
  "2030 SSP3-70 No Irrigation"  = "FSI_2030_SSP3_70_noirr.tif",
  "2050 SSP3-70 No Irrigation"  = "FSI_2050_SSP3_70_noirr.tif",
  "2080 SSP3-70 No Irrigation"  = "FSI_2080_SSP3_70_noirr.tif",
  "2030 SSP5-85 No Irrigation"  = "FSI_2030_SSP5_85_noirr.tif",
  "2050 SSP5-85 No Irrigation"  = "FSI_2050_SSP5_85_noirr.tif",
  "2080 SSP5-85 No Irrigation"  = "FSI_2080_SSP5_85_noirr.tif"
)

fsi_raster_irrigation <- list(
  "2030 SSP1-26 With Irrigation" = "FSI_2030_SSP1_26_irr.tif",
  "2050 SSP1-26 With Irrigation" = "FSI_2050_SSP1_26_irr.tif",
  "2080 SSP1-26 With Irrigation" = "FSI_2080_SSP1_26_irr.tif",
  "2030 SSP3-70 With Irrigation" = "FSI_2030_SSP3_70_irr.tif",
  "2050 SSP3-70 With Irrigation" = "FSI_2050_SSP3_70_irr.tif",
  "2080 SSP3-70 With Irrigation" = "FSI_2080_SSP3_70_irr.tif",
  "2030 SSP5-85 With Irrigation" = "FSI_2030_SSP5_85_irr.tif",
  "2050 SSP5-85 With Irrigation" = "FSI_2050_SSP5_85_irr.tif",
  "2080 SSP5-85 With Irrigation" = "FSI_2080_SSP5_85_irr.tif"
)

#Load Ethiopia outline and zone boundaries
ethiopia_outline <- st_read("gadm41_ETH_0.shp")  
ethiopia_zones <- st_read("gadm41_ETH_2.shp")  

#Convert raster values:
#- 0 (Food Secure) → Gray
#- 1 (Food Insecure) → Red
cols <- c("0" = "gray", "1" = "red")

#Plot function with zone borders
display_fsi_maps <- function(fsi_raster_list, title_prefix) {
  par(mfrow = c(3, 3), mar = c(2, 2, 2, 2))  
  for (scenario in names(fsi_raster_list)) {
    fsi_raster <- rast(fsi_raster_list[[scenario]])
    fsi_raster <- 1 - fsi_raster  #Flip values (1 → 0, 0 → 1)
    
    #Plot without axes and box
    plot(fsi_raster, col = cols, legend = TRUE, main = paste(title_prefix, scenario), axes = FALSE, box = FALSE)
    
    #Overlay Ethiopia national boundary
    plot(vect(ethiopia_outline), add = TRUE, border = "black", lwd = 1.5)
    
    #Overlay Zone Boundaries
    plot(vect(ethiopia_zones), add = TRUE, border = "black", lwd = 1)
  }
  par(mfrow = c(1, 1)) 
}

#Plot maps
cat("Plotting No Irrigation Scenarios\n")
display_fsi_maps(fsi_raster_no_irrigation, "No Irrigation")

cat("Plotting With Irrigation Scenarios\n")
display_fsi_maps(fsi_raster_irrigation, "With Irrigation")
```
```{r}

#Define raster file paths for different scenarios
fsi_raster_no_irrigation <- list(
  "2030_SSP1-26_No_Irrigation"  = "FSI_2030_SSP1_26_noirr.tif",
  "2050_SSP1-26_No_Irrigation"  = "FSI_2050_SSP1_26_noirr.tif",
  "2080_SSP1-26_No_Irrigation"  = "FSI_2080_SSP1_26_noirr.tif",
  "2030_SSP3-70_No_Irrigation"  = "FSI_2030_SSP3_70_noirr.tif",
  "2050_SSP3-70_No_Irrigation"  = "FSI_2050_SSP3_70_noirr.tif",
  "2080_SSP3-70_No_Irrigation"  = "FSI_2080_SSP3_70_noirr.tif",
  "2030_SSP5-85_No_Irrigation"  = "FSI_2030_SSP5_85_noirr.tif",
  "2050_SSP5-85_No_Irrigation"  = "FSI_2050_SSP5_85_noirr.tif",
  "2080_SSP5-85_No_Irrigation"  = "FSI_2080_SSP5_85_noirr.tif"
)

fsi_raster_irrigation <- list(
  "2030_SSP1-26_With_Irrigation" = "FSI_2030_SSP1_26_irr.tif",
  "2050_SSP1-26_With_Irrigation" = "FSI_2050_SSP1_26_irr.tif",
  "2080_SSP1-26_With_Irrigation" = "FSI_2080_SSP1_26_irr.tif",
  "2030_SSP3-70_With_Irrigation" = "FSI_2030_SSP3_70_irr.tif",
  "2050_SSP3-70_With_Irrigation" = "FSI_2050_SSP3_70_irr.tif",
  "2080_SSP3-70_With_Irrigation" = "FSI_2080_SSP3_70_irr.tif",
  "2030_SSP5-85_With_Irrigation" = "FSI_2030_SSP5_85_irr.tif",
  "2050_SSP5-85_With_Irrigation" = "FSI_2050_SSP5_85_irr.tif",
  "2080_SSP5-85_With_Irrigation" = "FSI_2080_SSP5_85_irr.tif"
)

#Load Ethiopia outline and zone boundaries
ethiopia_outline <- st_read("gadm41_ETH_0.shp")  
ethiopia_zones <- st_read("gadm41_ETH_2.shp")  

#Convert raster values:
#- 0 (Food Secure) → Gray
#- 1 (Food Insecure) → Red
cols <- c("0" = "gray", "1" = "red")

#Function to plot and save maps individually
save_fsi_maps <- function(fsi_raster_list, title_prefix) {
  for (scenario in names(fsi_raster_list)) {
    fsi_raster <- rast(fsi_raster_list[[scenario]])
    fsi_raster <- 1 - fsi_raster  #Flip values (1 → 0, 0 → 1)

    #Define file name
    output_file <- paste0("FSI_Map_", gsub(" ", "_", scenario), ".png")

    #Save PNG
    png(output_file, width = 800, height = 600, res = 150)

    #Plot without axes and box
    plot(fsi_raster, col = cols, legend = TRUE, main = paste(title_prefix, scenario), axes = FALSE, box = FALSE)

    #Overlay Ethiopia national boundary
    plot(vect(ethiopia_outline), add = TRUE, border = "black", lwd = 1.5)

    #Overlay Zone Boundaries
    plot(vect(ethiopia_zones), add = TRUE, border = "black", lwd = 1)

    #Close PNG device
    dev.off()

    cat("Saved:", output_file, "\n")
  }
}

#Save maps for No Irrigation scenarios
cat("Saving No Irrigation Maps...\n")
save_fsi_maps(fsi_raster_no_irrigation, "No Irrigation")

#Save maps for With Irrigation scenarios
cat("Saving With Irrigation Maps...\n")
save_fsi_maps(fsi_raster_irrigation, "With Irrigation")
```


Generating Predicted Probability Maps:
```{r}

#Load Ethiopia outline and administrative boundaries
ethiopia_outline <- st_read("gadm41_ETH_0.shp")
ethiopia_admin2 <- st_read("gadm41_ETH_2.shp")

#Define raster file paths for NO IRRIGATION scenarios (SSP)
predictor_raster_files_noirr <- list(
  "2030 SSP1-26 No Irrigation"  = "FSI_2030_SSP1_26_noirr.tif",
  "2050 SSP1-26 No Irrigation"  = "FSI_2050_SSP1_26_noirr.tif",
  "2080 SSP1-26 No Irrigation"  = "FSI_2080_SSP1_26_noirr.tif",
  "2030 SSP3-70 No Irrigation"  = "FSI_2030_SSP3_70_noirr.tif",
  "2050 SSP3-70 No Irrigation"  = "FSI_2050_SSP3_70_noirr.tif",
  "2080 SSP3-70 No Irrigation"  = "FSI_2080_SSP3_70_noirr.tif",
  "2030 SSP5-85 No Irrigation"  = "FSI_2030_SSP5_85_noirr.tif",
  "2050 SSP5-85 No Irrigation"  = "FSI_2050_SSP5_85_noirr.tif",
  "2080 SSP5-85 No Irrigation"  = "FSI_2080_SSP5_85_noirr.tif"
)

#Define raster file paths for IRRIGATION scenarios (SSP)
predictor_raster_files_irr <- list(
  "2030 SSP1-26 With Irrigation" = "FSI_2030_SSP1_26_irr.tif",
  "2050 SSP1-26 With Irrigation" = "FSI_2050_SSP1_26_irr.tif",
  "2080 SSP1-26 With Irrigation" = "FSI_2080_SSP1_26_irr.tif",
  "2030 SSP3-70 With Irrigation" = "FSI_2030_SSP3_70_irr.tif",
  "2050 SSP3-70 With Irrigation" = "FSI_2050_SSP3_70_irr.tif",
  "2080 SSP3-70 With Irrigation" = "FSI_2080_SSP3_70_irr.tif",
  "2030 SSP5-85 With Irrigation" = "FSI_2030_SSP5_85_irr.tif",
  "2050 SSP5-85 With Irrigation" = "FSI_2050_SSP5_85_irr.tif",
  "2080 SSP5-85 With Irrigation" = "FSI_2080_SSP5_85_irr.tif"
)

#Function to align and resample all predictors to match the reference raster
align_raster <- function(target_raster, reference_raster) {
  if (!compareGeom(target_raster, reference_raster, stopOnError = FALSE)) {
    cat("Resampling", names(target_raster), "to match reference raster\n")
    target_raster <- resample(target_raster, reference_raster, method = "bilinear")  
  }
  return(target_raster)
}

#Function to generate predicted probability maps dynamically selecting correct rasters
generate_fsi_probabilities <- function(predictor_raster_list, model, scenario_type) {
  for (scenario in names(predictor_raster_list)) {
    
    cat("Processing:", scenario, "\n")
    
    #Extract year and SSP type from scenario name
    scenario_year <- gsub(".*?(\\d{4}).*", "\\1", scenario)  #Extracts 2030, 2050, 2080
    ssp_type <- gsub(".*?(SSP[0-9]-[0-9]+).*", "\\1", scenario)  
    ssp_type <- gsub("-", "_", ssp_type)  

    #Load predictor raster (Food Security Index)
    predictor_raster <- rast(predictor_raster_list[[scenario]])

    #Define dynamically selected raster files with correct SSP structure
    soil_moisture_file <- paste0("CLASSIC_", ssp_type, "_Weighted_Average_Soil_Moisture_5km_", scenario_year, " copy.tif")
    population_file <- paste0("population_", scenario_year, ".tif")

    #Load additional predictors
    soil_moisture_raster <- rast(soil_moisture_file)
    population_raster <- rast(population_file)
    market_proximity_raster <- rast("Market_Proximity_2020_5km.tif")
    road_proximity_raster <- rast("Road_Proximity_2020_5km.tif")
    elevation_raster <- rast("Elevation_5km.tif")
    rwi_raster <- rast("RWI_2020_5km.tif")

    #Align all rasters to the reference (food security raster)
    soil_moisture_raster <- align_raster(soil_moisture_raster, predictor_raster)
    population_raster <- align_raster(population_raster, predictor_raster)
    market_proximity_raster <- align_raster(market_proximity_raster, predictor_raster)
    road_proximity_raster <- align_raster(road_proximity_raster, predictor_raster)
    elevation_raster <- align_raster(elevation_raster, predictor_raster)
    rwi_raster <- align_raster(rwi_raster, predictor_raster)

    #Stack aligned predictors
    predictor_stack <- c(
      predictor_raster,
      soil_moisture_raster,
      population_raster,
      market_proximity_raster,
      road_proximity_raster,
      elevation_raster,
      rwi_raster
    )

    #✅ FIX: Renamed "FSI" → "Yield" to match expected input name
    names(predictor_stack) <- c("Yield", "Soil_Moisture", "Population", 
                                "Market_Proximity", "Road_Proximity", 
                                "Elevation", "RWI")

    #✅ Debugging: Print layer names before prediction
    print("Checking predictor_stack names:")
    print(names(predictor_stack))

    #Convert raster to dataframe for prediction
    predictor_df <- as.data.frame(predictor_stack, xy = TRUE, na.rm = FALSE)

    #Replace NA values with variable mean
    for (var in names(predictor_df)[-c(1,2)]) {  
      predictor_df[[var]][is.na(predictor_df[[var]])] <- mean(predictor_df[[var]], na.rm = TRUE)
    }

    #Predict probabilities of food insecurity
    predicted_prob_fsi <- predict(model, newdata = predictor_df, type = "prob")

    #Extract probabilities for food insecurity
    fsi_pred_prob <- predicted_prob_fsi[,2]  

    #Flip the probability values so 1 → 0 and 0 → 1
    fsi_pred_prob <- 1 - fsi_pred_prob
    
    #Convert predictions back to raster format
    fsi_prob_raster <- rast(predictor_raster)  

    #Assign values if dimensions match
    if (nrow(predictor_df) == ncell(fsi_prob_raster)) {  
      values(fsi_prob_raster) <- fsi_pred_prob
    } else {
      stop(paste("Error: Mismatch between raster cells and predictions for", scenario))
    }

    #Mask to Ethiopia boundary
    fsi_prob_raster <- mask(fsi_prob_raster, vect(ethiopia_outline))

    #Save probability raster
    output_raster_file <- paste0("FSI_Prob_", gsub(" ", "_", scenario), ".tif")
    writeRaster(fsi_prob_raster, output_raster_file, overwrite = TRUE)
    
    cat("Saved:", output_raster_file, "\n")
  }
}

#Run the function for both No Irrigation & Irrigation scenarios
cat("Generating No Irrigation Maps...\n")
generate_fsi_probabilities(predictor_raster_files_noirr, RFa_model, "NoIrrigation")

cat("Generating Irrigation Maps...\n")
generate_fsi_probabilities(predictor_raster_files_irr, RFa_model, "Irrigation")
```
Visualise predicted probability maps
```{r}
#Function to visualize probability maps
generate_fsi_maps <- function(fsi_raster_list, scenario_type) {
  for (scenario in names(fsi_raster_list)) {
    
    #Load raster
    fsi_raster <- rast(fsi_raster_list[[scenario]])
    
    #Create the Map
    map_plot <- tm_shape(fsi_raster) +
      tm_raster(title = "Predicted Probability of Food Insecurity", 
                palette = "-RdYlBu", style = "cont", breaks = seq(0, 1, by = 0.1)) +
      tm_shape(ethiopia_outline) + 
      tm_borders(col = "black", lwd = 2) +  
      tm_shape(ethiopia_admin2) + 
      tm_borders(col = "black", lwd = 0.5) + 
      tm_layout(main.title = paste("Food Insecurity:", scenario), 
                main.title.position = "center", 
                title.size = 1.4, 
                legend.text.size = 1.2, 
                legend.title.size = 1.4,  
                legend.outside = TRUE,  
                legend.outside.position = "right",  
                legend.frame = FALSE,  
                frame = FALSE) +  
      tm_scale_bar(position = c(0.02, 0.02), text.size = 1, breaks = c(0, 100, 200)) +
      tm_compass(north = 0, type = 'arrow', position = c('right', 'bottom'), text.size = 0.9)

    #Save as PNG
    output_file <- paste0("FSI_Map_", gsub(" ", "_", scenario), "_", scenario_type, ".png")
    tmap_save(map_plot, filename = output_file, width = 8, height = 6, dpi = 300)
    
    cat("Saved:", output_file, "\n")
  }
}

#Load generated probability rasters for NO IRRIGATION visualization
fsi_prob_rasters_noirr <- list(
  "2030 SSP1-26 No Irrigation"  = "FSI_Prob_2030_SSP1-26_No_Irrigation.tif",
  "2050 SSP1-26 No Irrigation"  = "FSI_Prob_2050_SSP1-26_No_Irrigation.tif",
  "2080 SSP1-26 No Irrigation"  = "FSI_Prob_2080_SSP1-26_No_Irrigation.tif",
  "2030 SSP3-70 No Irrigation"  = "FSI_Prob_2030_SSP3-70_No_Irrigation.tif",
  "2050 SSP3-70 No Irrigation"  = "FSI_Prob_2050_SSP3-70_No_Irrigation.tif",
  "2080 SSP3-70 No Irrigation"  = "FSI_Prob_2080_SSP3-70_No_Irrigation.tif",
  "2030 SSP5-85 No Irrigation"  = "FSI_Prob_2030_SSP5-85_No_Irrigation.tif",
  "2050 SSP5-85 No Irrigation"  = "FSI_Prob_2050_SSP5-85_No_Irrigation.tif",
  "2080 SSP5-85 No Irrigation"  = "FSI_Prob_2080_SSP5-85_No_Irrigation.tif"
)

#Load generated probability rasters for IRRIGATION visualization
fsi_prob_rasters_irr <- list(
  "2030 SSP1-26 With Irrigation" = "FSI_Prob_2030_SSP1-26_With_Irrigation.tif",
  "2050 SSP1-26 With Irrigation" = "FSI_Prob_2050_SSP1-26_With_Irrigation.tif",
  "2080 SSP1-26 With Irrigation" = "FSI_Prob_2080_SSP1-26_With_Irrigation.tif",
  "2030 SSP3-70 With Irrigation" = "FSI_Prob_2030_SSP3-70_With_Irrigation.tif",
  "2050 SSP3-70 With Irrigation" = "FSI_Prob_2050_SSP3-70_With_Irrigation.tif",
  "2080 SSP3-70 With Irrigation" = "FSI_Prob_2080_SSP3-70_With_Irrigation.tif",
  "2030 SSP5-85 With Irrigation" = "FSI_Prob_2030_SSP5-85_With_Irrigation.tif",
  "2050 SSP5-85 With Irrigation" = "FSI_Prob_2050_SSP5-85_With_Irrigation.tif",
  "2080 SSP5-85 With Irrigation" = "FSI_Prob_2080_SSP5-85_With_Irrigation.tif"
)

#Generate visualization maps for NO IRRIGATION
cat("Generating No Irrigation Maps...\n")
generate_fsi_maps(fsi_prob_rasters_noirr, "No_Irrigation")

#Generate visualization maps for IRRIGATION
cat("Generating Irrigation Maps...\n")
generate_fsi_maps(fsi_prob_rasters_irr, "Irrigation")
```


```{r}
#Load the environmental predictor rasters for 2080 (SSP5-85, With Irrigation)
yield_2020_noirr_RCP26 <- rast("Ethiopia_wheat_RCP26_noirrigation_5km_2020 copy.tif") 
soil_moisture_2020_noirr_RCP26 <- rast("CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2020 copy.tif")
population_2020_noirr_RCP26 <- rast("Population_2020_5km.tif")

#Load static predictors (Market Proximity, Road Proximity, Elevation, RWI)
market_proximity_2020_SSP5_85 <- rast("Market_Proximity_2020_5km.tif")
road_proximity_2020_SSP5_85 <- rast("Road_Proximity_2020_5km.tif")
elevation_2020_SSP5_85 <- rast("Elevation_5km.tif")
rwi_2020_SSP5_85 <- rast("RWI_2020_5km.tif")

#Load Ethiopia outline
ethiopia_outline_2020_noirr_RCP26 <- st_read("gadm41_ETH_0.shp")

#Assign CRS to Ethiopia outline if missing
if (is.na(st_crs(ethiopia_outline_2020_noirr_RCP26))) {
  st_crs(ethiopia_outline_2020_noirr_RCP26) <- "EPSG:4326"
}

#Ensure all rasters have the same CRS, extent, and resolution
target_crs_2020_noirr_RCP26 <- crs(yield_2020_noirr_RCP26)
target_res_2020_noirr_RCP26 <- res(yield_2020_noirr_RCP26)
target_ext_2020_noirr_RCP26 <- ext(yield_2020_noirr_RCP26) 

#List of rasters to align
rasters_list_2020_noirr_RCP26 <- list(soil_moisture_2020_noirr_RCP26, market_proximity_2020_SSP5_85, 
                                      road_proximity_2020_SSP5_85, population_2020_noirr_RCP26, 
                                      elevation_2020_SSP5_85, rwi_2020_SSP5_85)

#Reproject, resample, crop, and mask
for (i in 1:length(rasters_list_2020_noirr_RCP26)) {
  rasters_list_2020_noirr_RCP26[[i]] <- project(rasters_list_2020_noirr_RCP26[[i]], target_crs_2020_noirr_RCP26) 
  rasters_list_2020_noirr_RCP26[[i]] <- resample(rasters_list_2020_noirr_RCP26[[i]], yield_2020_noirr_RCP26, method = "bilinear")
  rasters_list_2020_noirr_RCP26[[i]] <- crop(rasters_list_2020_noirr_RCP26[[i]], target_ext_2020_noirr_RCP26) 
  rasters_list_2020_noirr_RCP26[[i]] <- mask(rasters_list_2020_noirr_RCP26[[i]], yield_2020_noirr_RCP26)
}

#Stack the rasters into a single multi-layer raster
predictor_stack_2020_noirr_RCP26 <- c(yield_2020_noirr_RCP26, rasters_list_2020_noirr_RCP26[[1]], 
                                      rasters_list_2020_noirr_RCP26[[2]], rasters_list_2020_noirr_RCP26[[3]],
                                      rasters_list_2020_noirr_RCP26[[4]], rasters_list_2020_noirr_RCP26[[5]], 
                                      rasters_list_2020_noirr_RCP26[[6]])

#Rename the layers to match the model variable names
names(predictor_stack_2020_noirr_RCP26) <- c("Yield", "Soil_Moisture", "Market_Proximity", "Road_Proximity", 
                                             "Population", "Elevation", "RWI")

#Convert Raster Stack to DataFrame for Prediction
predictor_df_2020_noirr_RCP26 <- as.data.frame(predictor_stack_2020_noirr_RCP26, xy = TRUE, na.rm = FALSE) 

#Ensure All Cells are Retained by Replacing NA Values Instead of Removing Rows
for (var in names(predictor_df_2020_noirr_RCP26)[-c(1,2)]) { 
  predictor_df_2020_noirr_RCP26[[var]][is.na(predictor_df_2020_noirr_RCP26[[var]])] <- mean(predictor_df_2020_noirr_RCP26[[var]], na.rm = TRUE)
}

#Use the Trained Random Forest Model to Predict Food Security
predicted_fsi_2020_noirr_RCP26 <- predict(RFa_model, newdata = predictor_df_2020_noirr_RCP26, type = "response")

#Convert predictions to numeric
predictor_df_2020_noirr_RCP26$FSI_Predicted <- as.numeric(as.character(predicted_fsi_2020_noirr_RCP26))

#Convert Predictions Back to Raster Format
fsi_raster_2020_noirr_RCP26 <- rast(yield_2020_noirr_RCP26)

#Ensure predictions match raster cell count before assigning values
if (nrow(predictor_df_2020_noirr_RCP26) == ncell(fsi_raster_2020_noirr_RCP26)) {  
  values(fsi_raster_2020_noirr_RCP26) <- predictor_df_2020_noirr_RCP26$FSI_Predicted
} else {
  stop(paste("Error: Mismatch between raster cells and predictions. Expected", 
             ncell(fsi_raster_2020_noirr_RCP26), "got", nrow(predictor_df_2020_noirr_RCP26)))
}

#Mask the raster to Ethiopia boundary
fsi_raster_2020_noirr_RCP26 <- mask(fsi_raster_2020_noirr_RCP26, vect(ethiopia_outline_2020_noirr_RCP26))

#Save the Predicted Food Security Raster
writeRaster(fsi_raster_2020_noirr_RCP26, "FSI_2020_noirr_RCP26_irr.tif", overwrite = TRUE)

#Plot the Food Security Prediction
plot(fsi_raster_2020_noirr_RCP26, main = "Predicted Food Security (2080, SSP5-85, With Irrigation)")
```

```{r}
#Load the predicted food security raster for the scenario (modify accordingly)
fsi_raster_2020_noirr_RCP26 <- rast("FSI_2020_noirr_RCP26_irr.tif")


#Convert raster values:
#- 1 (Food Secure) → Green
#- 0 (Food Insecure) → Red
cols <- c("0" = "red", "1" = "gray")

#Load Ethiopia outline for masking
ethiopia_outline <- st_read("gadm41_ETH_0.shp")

#Plot: Food Security Prediction (No Irrigation)
plot(fsi_raster_2020_noirr_RCP26, col = cols, legend = TRUE, main = "Predicted Food Security (2020, No Irrigation, RCP26)")
plot(vect(ethiopia_outline), add = TRUE)
```
```{r}

#Load the food security prediction raster
fsi_raster <- rast("FSI_2020_noirr_RCP26_irr.tif")

#Define predictor categories
predictor_categories <- list(
  "Yield" = "Ethiopia_wheat_RCP26_noirrigation_5km_2020 copy.tif",
  "Environment" = "CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2020 copy.tif",
  "Socio_Economic" = c("RWI_2020_5km.tif", "Road_Proximity_2020_5km.tif", "Market_Proximity_2020_5km.tif", "Population_2020_5km.tif")
)

#Define predictor thresholds
thresholds <- list(
  "Yield" = 0.1522,
  "Environment" = 144.6190,
  "RWI" = -0.6120,
  "Road_Proximity" = 50.7375,
  "Market_Proximity" = 27363.68,
  "Population" = 480.2990
)

#Create a list to store classified rasters
classified_predictor_rasters <- list()

#Process each category
for (category in names(predictor_categories)) {
  #If multiple predictors exist in a category, create a combined raster
  predictor_files <- predictor_categories[[category]]
  
  if (length(predictor_files) > 1) {
    #Initialize an empty raster with the same extent/resolution as the first predictor
    combined_raster <- rast(predictor_files[1])
    combined_raster[] <- 0  

    for (var in predictor_files) {
      #Load each raster
      predictor_raster <- rast(var)

      #Ensure raster values are numeric
      predictor_raster <- as.numeric(predictor_raster)

      #Apply threshold for classification (food insecurity presence = 1, otherwise 0)
      predictor_name <- tools::file_path_sans_ext(basename(var))
      
      #Check if threshold exists for this predictor
      if (!is.null(thresholds[[predictor_name]])) {
        threshold_value <- thresholds[[predictor_name]]
        classified_raster <- predictor_raster >= threshold_value

        #Combine into a single raster (union of all predictors within the category)
        combined_raster <- combined_raster + classified_raster
      }
    }

    #Convert to binary (0 or 1) using correct classify() format
    classified_predictor_rasters[[category]] <- classify(combined_raster, matrix(c(0, 0, 1, 1), ncol = 2, byrow = TRUE))

  } else {
    #Single raster category (Yield or Environment)
    predictor_raster <- rast(predictor_files)
    
    #Ensure raster values are numeric
    predictor_raster <- as.numeric(predictor_raster)
    
    #Check if threshold exists
    if (!is.null(thresholds[[category]])) {
      threshold_value <- thresholds[[category]]
      classified_predictor_rasters[[category]] <- classify(predictor_raster >= threshold_value, matrix(c(0, 0, 1, 1), ncol = 2, byrow = TRUE))
    }
  }

  #Save classified rasters
  output_filename <- paste0("Food_Insecurity_", category, "_5km.tif")
  writeRaster(classified_predictor_rasters[[category]], output_filename, overwrite = TRUE)
}

#Plot all predictor category rasters
par(mfrow = c(2, 2)) 

plot(classified_predictor_rasters[["Yield"]], main = "Food Insecurity: Yield", col = c("white", "black"))
plot(classified_predictor_rasters[["Environment"]], main = "Food Insecurity: Environment", col = c("white", "black"))
plot(classified_predictor_rasters[["Socio_Economic"]], main = "Food Insecurity: Socio-Economic", col = c("white", "black"))

par(mfrow = c(1,1)) 
```
```{r}

#Load the 2020 food security raster (Ensure the file exists)
fsi_raster <- rast("FSI_2020_noirr_RCP26_irr.tif")

#Define predictor file paths (Ensure correct filenames)
predictor_files <- list(
  "Yield" = "Ethiopia_wheat_RCP26_noirrigation_5km_2020 copy.tif",
  "Soil_Moisture" = "CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2020 copy.tif",
  "RWI" = "RWI_2020_5km.tif",
  "Road_Proximity" = "Road_Proximity_2020_5km.tif",
  "Market_Proximity" = "Market_Proximity_2020_5km.tif",
  "Population" = "Population_2020_5km.tif"
)

#Define predictor thresholds (Ensure these are reasonable!)
thresholds <- list(
  "Yield" = 0.1522,
  "Soil_Moisture" = 144.6190,
  "RWI" = -0.6120,
  "Road_Proximity" = 50.7375,
  "Market_Proximity" = 27363.68,
  "Population" = 480.2990
)

#Ensure food security raster values are binary (1 = insecure, 0 = secure)
fsi_raster <- classify(fsi_raster, matrix(c(0, 0, 1, 1), ncol = 2, byrow = TRUE))

#Create a list to store classified rasters
classified_rasters <- list()

#Process each predictor separately
for (var in names(predictor_files)) {
  file_path <- predictor_files[[var]]

  #Load raster and ensure it exists
  if (!file.exists(file_path)) {
    print(paste("Error: File not found ->", file_path))
    next
  }
  
  predictor_raster <- rast(file_path)
  
  #Ensure raster values are numeric
  predictor_raster <- as.numeric(predictor_raster)
  
  #Check if threshold exists for the variable
  if (!is.null(thresholds[[var]])) {
    threshold_value <- thresholds[[var]]
    
    #Classify raster (1 = above threshold, 0 = below)
    classified_raster <- predictor_raster >= threshold_value

    #Apply the food insecurity mask (Only retain areas where FSI_2020 = 1)
    classified_raster <- classified_raster * fsi_raster  

    #Convert logical values to 0/1
    classified_rasters[[var]] <- classify(classified_raster, matrix(c(0, 0, 1, 1), ncol = 2, byrow = TRUE))

    #Save classified raster
    output_filename <- paste0("Food_Insecurity_", var, "_5km_Masked.tif")
    writeRaster(classified_rasters[[var]], output_filename, overwrite = TRUE)
  } else {
    print(paste("Warning: No threshold found for", var))
  }
}

#Plot each predictor separately
par(mfrow = c(2, 3))

for (var in names(classified_rasters)) {
  plot(classified_rasters[[var]], main = paste("Food Insecurity (Masked):", var), col = c("white", "black"))
}

par(mfrow = c(1,1)) 
```

```{r}

#Load the 2020 food security raster (Ensure the file exists)
fsi_raster <- rast("FSI_2020_noirr_RCP26_irr.tif")

#Define predictor file paths
predictor_files <- list(
  "Yield" = "Ethiopia_wheat_RCP26_noirrigation_5km_2020 copy.tif",
  "Soil_Moisture" = "CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2020 copy.tif",
  "RWI" = "RWI_2020_5km.tif",
  "Road_Proximity" = "Road_Proximity_2020_5km.tif",
  "Market_Proximity" = "Market_Proximity_2020_5km.tif",
  "Population" = "Population_2020_5km.tif"
)

#Define updated threshold logic
thresholds <- list(
  "Yield" = list(value = 0.1522, direction = "<"), 
  "Soil_Moisture" = list(value = 144.6190, direction = ">"),   
  "RWI" = list(value = -0.6120, direction = "<"), 
  "Road_Proximity" = list(value = 50.7375, direction = ">"),   
  "Market_Proximity" = list(value = 27363.68, direction = ">"),   
  "Population" = list(value = 480.2990, direction = "<") 
)

#Ensure food security raster values are binary (1 = insecure, 0 = secure)
fsi_raster <- classify(fsi_raster, matrix(c(0, 0, 1, 1), ncol = 2, byrow = TRUE))

#Create a list to store classified rasters
classified_rasters <- list()

#Process each predictor separately
for (var in names(predictor_files)) {
  file_path <- predictor_files[[var]]

  #Load raster and ensure it exists
  if (!file.exists(file_path)) {
    print(paste("Error: File not found ->", file_path))
    next
  }
  
  predictor_raster <- rast(file_path)
  
  #Ensure raster values are numeric
  predictor_raster <- as.numeric(predictor_raster)
  
  #Check if threshold exists for the variable
  if (!is.null(thresholds[[var]])) {
    threshold_value <- thresholds[[var]]$value
    direction <- thresholds[[var]]$direction

    #Apply the correct threshold condition
    if (direction == "<") {
      classified_raster <- predictor_raster < threshold_value
    } else if (direction == ">") {
      classified_raster <- predictor_raster > threshold_value
    } else {
      print(paste("Warning: Invalid direction for", var))
      next
    }

    #Apply the food insecurity mask (Only retain areas where FSI_2020 = 1)
    classified_raster <- classified_raster * fsi_raster  #Keeps only areas where FSI_2020 is 1

    #Convert logical values to 0/1
    classified_rasters[[var]] <- classify(classified_raster, matrix(c(0, 0, 1, 1), ncol = 2, byrow = TRUE))

    #Save classified raster
    output_filename <- paste0("Food_Insecurity_", var, "_5km_Masked.tif")
    writeRaster(classified_rasters[[var]], output_filename, overwrite = TRUE)
  } else {
    print(paste("Warning: No threshold found for", var))
  }
}

#Plot each predictor separately
par(mfrow = c(2, 3))

for (var in names(classified_rasters)) {
  plot(classified_rasters[[var]], main = paste("Food Insecurity (Masked):", var), col = c("white", "black"))
}

#par(mfrow = c(1,1)) 
```

```{r}
#Load the 2020 food security raster (Ensure the file exists)
fsi_raster <- rast("FSI_2020_noirr_RCP26_irr.tif")

#Define predictor file paths
predictor_files <- list(
  "Yield" = "Ethiopia_wheat_RCP26_noirrigation_5km_2020 copy.tif",
  "Soil_Moisture" = "CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2020 copy.tif",
  "RWI" = "RWI_2020_5km.tif",
  "Road_Proximity" = "Road_Proximity_2020_5km.tif",
  "Market_Proximity" = "Market_Proximity_2020_5km.tif",
  "Population" = "Population_2020_5km.tif"
)

#Define updated threshold logic
thresholds <- list(
  "Yield" = list(value = 0.1522, direction = "<"), 
  "Soil_Moisture" = list(value = 144.6190, direction = ">"),   
  "RWI" = list(value = -0.6120, direction = "<"), 
  "Road_Proximity" = list(value = 50.7375, direction = ">"),   
  "Market_Proximity" = list(value = 27363.68, direction = ">"),   
  "Population" = list(value = 480.2990, direction = "<") 
)

#Ensure food security raster values are binary (1 = insecure, 0 = secure)
fsi_raster <- classify(fsi_raster, matrix(c(0, 0, 1, 1), ncol = 2, byrow = TRUE))

#Invert the mask: Retain areas where `FSI_2020 = 0` (food secure)
fsi_mask <- fsi_raster == 0  

#Create a list to store classified rasters
classified_rasters <- list()

#Process each predictor separately
for (var in names(predictor_files)) {
  file_path <- predictor_files[[var]]

  #Load raster and ensure it exists
  if (!file.exists(file_path)) {
    print(paste("Error: File not found ->", file_path))
    next
  }
  
  predictor_raster <- rast(file_path)
  
  #Ensure raster values are numeric
  predictor_raster <- as.numeric(predictor_raster)
  
  #Check if threshold exists for the variable
  if (!is.null(thresholds[[var]])) {
    threshold_value <- thresholds[[var]]$value
    direction <- thresholds[[var]]$direction

    #Apply the correct threshold condition
    if (direction == "<") {
      classified_raster <- predictor_raster < threshold_value
    } else if (direction == ">") {
      classified_raster <- predictor_raster > threshold_value
    } else {
      print(paste("Warning: Invalid direction for", var))
      next
    }

    #Apply the inverted food security mask (Only retain areas where `FSI_2020 = 0`)
    classified_raster <- classified_raster * fsi_mask  

    #Convert logical values to 0/1
    classified_rasters[[var]] <- classify(classified_raster, matrix(c(0, 0, 1, 1), ncol = 2, byrow = TRUE))

    #Save classified raster
    output_filename <- paste0("Food_Secure_", var, "_5km_Masked.tif")
    writeRaster(classified_rasters[[var]], output_filename, overwrite = TRUE)
  } else {
    print(paste("Warning: No threshold found for", var))
  }
}

#Plot each predictor separately
par(mfrow = c(2, 3))

for (var in names(classified_rasters)) {
  plot(classified_rasters[[var]], main = paste("Food Security (Masked):", var), col = c("white", "black"))
}

par(mfrow = c(1,1)) 
```
```{r}

#Load the 2020 food security raster (Ensure the file exists)
fsi_raster <- rast("FSI_2020_noirr_RCP26_irr.tif")

#Define predictor file paths
predictor_files <- list(
  "Yield" = "Ethiopia_wheat_RCP26_noirrigation_5km_2020 copy.tif",
  "Soil_Moisture" = "CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2020 copy.tif",
  "RWI" = "RWI_2020_5km.tif",
  "Road_Proximity" = "Road_Proximity_2020_5km.tif",
  "Market_Proximity" = "Market_Proximity_2020_5km.tif",
  "Population" = "Population_2020_5km.tif"
)

#Define updated threshold logic
thresholds <- list(
  "Yield" = list(value = 0.1522, direction = "<"), 
  "Soil_Moisture" = list(min_value = 30, max_value = 144, range = TRUE),  #Between 75 and 125
  "RWI" = list(value = -0.6120, direction = "<"), 
  "Road_Proximity" = list(value = 50.7375, direction = ">"),   
  "Market_Proximity" = list(value = 27363.68, direction = ">"),   
  "Population" = list(value = 480.2990, direction = "<") 
)

#Ensure food security raster values are binary (1 = insecure, 0 = secure)
fsi_raster <- classify(fsi_raster, matrix(c(0, 0, 1, 1), ncol = 2, byrow = TRUE))

#Create a list to store classified rasters
classified_rasters <- list()

#Process each predictor separately
for (var in names(predictor_files)) {
  file_path <- predictor_files[[var]]

  #Load raster and ensure it exists
  if (!file.exists(file_path)) {
    print(paste("Error: File not found ->", file_path))
    next
  }
  
  predictor_raster <- rast(file_path)
  
  #Ensure raster values are numeric
  predictor_raster <- as.numeric(predictor_raster)
  
  #Check if threshold exists for the variable
  if (!is.null(thresholds[[var]])) {
    
    #Special handling for Soil Moisture range condition
    if (var == "Soil_Moisture") {
      min_value <- thresholds[[var]]$min_value
      max_value <- thresholds[[var]]$max_value
      
      classified_raster <- (predictor_raster >= min_value) & (predictor_raster <= max_value)

    } else {
      #Apply standard threshold conditions
      threshold_value <- thresholds[[var]]$value
      direction <- thresholds[[var]]$direction

      if (direction == "<") {
        classified_raster <- predictor_raster < threshold_value
      } else if (direction == ">") {
        classified_raster <- predictor_raster > threshold_value
      } else {
        print(paste("Warning: Invalid direction for", var))
        next
      }
    }

     #Apply the inverted food security mask (Only retain areas where `FSI_2020 = 0`)
    classified_raster <- classified_raster * fsi_mask  

    #Convert logical values to 0/1
    classified_rasters[[var]] <- classify(classified_raster, matrix(c(0, 0, 1, 1), ncol = 2, byrow = TRUE))

    #Save classified raster
    output_filename <- paste0("Food_Insecurity_", var, "_5km_Masked.tif")
    writeRaster(classified_rasters[[var]], output_filename, overwrite = TRUE)
  } else {
    print(paste("Warning: No threshold found for", var))
  }
}

#Plot each predictor separately
par(mfrow = c(2, 3))

for (var in names(classified_rasters)) {
  plot(classified_rasters[[var]], main = paste("Food Insecurity (Masked):", var), col = c("white", "black"))
}

par(mfrow = c(1,1)) 
```

```{r}

#Define raster file paths to merge
raster_files <- c(
  "Food_Insecurity_Market_Proximity_5km_Masked.tif",
  "Food_Insecurity_Road_Proximity_5km_Masked.tif",
  "Food_Insecurity_RWI_5km_Masked.tif"
)

#Load all rasters
rasters <- lapply(raster_files, rast)

#Merge rasters by taking the maximum value (1 if any raster has 1)
merged_raster <- do.call(mosaic, c(rasters, fun = "max"))

#Save the merged raster
output_filename <- "Food_Insecurity_Combined_5km.tif"
writeRaster(merged_raster, output_filename, overwrite = TRUE)

#Plot the merged raster
plot(merged_raster, main = "Combined Food Insecurity Map", col = c("white", "black"))
```
Contour Desnity:

```{r}

#Load Ethiopia shapefile (now correctly georeferenced)
ethiopia_shape <- st_read("gadm41_ETH_0.shp")  

#Define raster files for contour density mapping
raster_files <- list(
  "Food_Insecurity_Combined" = "Food_Insecurity_Combined_5km.tif",
  "Soil_Moisture" = "Food_Insecurity_Soil_Moisture_5km_Masked.tif",
  "Yield" = "Food_Insecurity_Yield_5km_Masked.tif"
)

#Create contour density plots for each raster
contour_plots <- list()

for (var in names(raster_files)) {
  file_path <- raster_files[[var]]

  #Load raster
  raster_layer <- rast(file_path)

  #Convert raster to dataframe
  points <- as.data.frame(raster_layer, xy = TRUE)
  colnames(points) <- c("Longitude", "Latitude", "Value")

  #Keep only presence locations (food insecurity = 1)
  points <- points[points$Value == 1, ]

  #Ensure there are enough points for KDE
  if (nrow(points) < 10) {
    print(paste("Skipping:", var, "- Not enough data points"))
    next
  }

  #Create density contour plot
  p <- ggplot() +
    geom_sf(data = ethiopia_shape, fill = "gray95", color = "black", size = 0.5) +  
    geom_density2d_filled(data = points, aes(x = Longitude, y = Latitude), bins = 15, alpha = 0.7) + 
    scale_fill_viridis_d(option = "magma") +  
    labs(title = paste("Contour Density Map:", var), x = "Longitude", y = "Latitude") +
    theme_minimal()

  #Store plot
  contour_plots[[var]] <- p
}

#Display plots
contour_plots
```

```{r}
#Load Ethiopia shapefile
ethiopia_shape <- st_read("gadm41_ETH_0.shp")

#Define raster files and target level
raster_files <- list(
  "Food_Insecurity_Combined" = "Food_Insecurity_Combined_5km.tif",
  "Soil_Moisture" = "Food_Insecurity_Soil_Moisture_5km_Masked.tif",
  "Yield" = "Food_Insecurity_Yield_5km_Masked.tif"
)

target_level <- 0.016  #The contour level we want to extract

#Function to extract contour at specific level
extract_contour_boundary <- function(points, target_level) {
  #Create density estimate
  kde <- kde2d(points$Longitude, points$Latitude, n = 100)
  
  #Generate contours
  contours <- contourLines(kde$x, kde$y, kde$z, levels = target_level)
  
  #Convert contours to SF object
  contour_sf <- lapply(contours, function(contour) {
    st_linestring(cbind(contour$x, contour$y))
  })
  
  if (length(contour_sf) > 0) {
    contour_sf <- st_sfc(contour_sf)
    contour_sf <- st_sf(geometry = contour_sf)
    st_crs(contour_sf) <- st_crs(ethiopia_shape)
    return(contour_sf)
  } else {
    return(NULL)
  }
}

#Process each raster and extract contours
contour_boundaries <- list()

for (var in names(raster_files)) {
  #Load and process raster
  raster_layer <- rast(raster_files[[var]])
  points <- as.data.frame(raster_layer, xy = TRUE)
  colnames(points) <- c("Longitude", "Latitude", "Value")
  points <- points[points$Value == 1, ]
  
  #Extract contour boundary
  contour_boundary <- extract_contour_boundary(points, target_level)
  
  if (!is.null(contour_boundary)) {
    contour_boundaries[[var]] <- contour_boundary
    
    #Save contour to shapefile
    output_file <- paste0("contour_", var, "_", target_level, ".shp")
    st_write(contour_boundary, output_file, append = FALSE)
  }
}

#Create visualization of all contours together
ggplot() +
  geom_sf(data = ethiopia_shape, fill = "gray95", color = "black", size = 0.5) +
  geom_sf(data = contour_boundaries[["Food_Insecurity_Combined"]], color = "red", size = 1) +
  geom_sf(data = contour_boundaries[["Soil_Moisture"]], color = "blue", size = 1) +
  geom_sf(data = contour_boundaries[["Yield"]], color = "green", size = 1) +
  labs(title = "Overlaid 0.016 Level Contours",
       subtitle = "Red: Food Insecurity, Blue: Soil Moisture, Green: Yield") +
  theme_minimal()

#Save the plot
ggsave("overlaid_contours.png", width = 10, height = 8)
```
```{r}


#Load Ethiopia shapefile
ethiopia_shape <- st_read("gadm41_ETH_0.shp")

#Define raster files and target level
raster_files <- list(
  "Food_Insecurity_Combined" = "Food_Insecurity_Combined_5km.tif",
  "Soil_Moisture" = "Food_Insecurity_Soil_Moisture_5km_Masked.tif",
  "Yield" = "Food_Insecurity_Yield_5km_Masked.tif"
)

target_level <- 0.016

#Function to extract contour at specific level
extract_contour_boundary <- function(points, target_level) {
  #Create density estimate
  kde <- kde2d(points$Longitude, points$Latitude, n = 100)
  
  #Generate contours
  contours <- contourLines(kde$x, kde$y, kde$z, levels = target_level)
  
  #Convert contours to SF object and create polygons
  contour_sf <- lapply(contours, function(contour) {
    #Close the polygon by adding the first point at the end
    x <- c(contour$x, contour$x[1])
    y <- c(contour$y, contour$y[1])
    st_polygon(list(cbind(x, y)))
  })
  
  if (length(contour_sf) > 0) {
    contour_sf <- st_sfc(contour_sf)
    contour_sf <- st_sf(geometry = contour_sf)
    st_crs(contour_sf) <- st_crs(ethiopia_shape)
    return(contour_sf)
  } else {
    return(NULL)
  }
}

#Process each raster and extract contours
contour_boundaries <- list()

for (var in names(raster_files)) {
  raster_layer <- rast(raster_files[[var]])
  points <- as.data.frame(raster_layer, xy = TRUE)
  colnames(points) <- c("Longitude", "Latitude", "Value")
  points <- points[points$Value == 1, ]
  
  contour_boundary <- extract_contour_boundary(points, target_level)
  
  if (!is.null(contour_boundary)) {
    contour_boundaries[[var]] <- contour_boundary
    output_file <- paste0("contour_", var, "_", target_level, ".shp")
    st_write(contour_boundary, output_file, append = FALSE)
  }
}

#Define a professional color palette with good contrast
colors <- list(
  "Food_Insecurity_Combined" = "#E64B35B3",  
  "Soil_Moisture" = "#4DBBD5B3",          
  "Yield" = "#00A087B3"                
)

#Create visualization with filled polygons and transparency
ggplot() +
  #Base map
  geom_sf(data = ethiopia_shape, fill = "gray95", color = "gray50", size = 0.3) +
  
  #Add each contour layer with fill and transparency
  geom_sf(data = contour_boundaries[["Yield"]], 
          fill = colors[["Yield"]], color = "#00A087", 
          alpha = 0.4, size = 0.5) +
  geom_sf(data = contour_boundaries[["Soil_Moisture"]], 
          fill = colors[["Soil_Moisture"]], color = "#4DBBD5", 
          alpha = 0.4, size = 0.5) +
  geom_sf(data = contour_boundaries[["Food_Insecurity_Combined"]], 
          fill = colors[["Food_Insecurity_Combined"]], color = "#E64B35", 
          alpha = 0.4, size = 0.5) +
  
  #Customize the theme and labels
  labs(title = "High-Density Regions of Food Insecurity Factors in Ethiopia",
       subtitle = "0.016 Level Contours") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 11),
    legend.position = "bottom"
  ) +
  #Add a scale bar and north arrow if needed
  coord_sf()

#Create legend explanation
legend_data <- data.frame(
  Variable = c("Food Insecurity", "Soil Moisture", "Yield"),
  Color = c("#E64B35", "#4DBBD5", "#00A087")
)

#Add legend
print("Legend Information:")
print(legend_data)

#Save the plot with high resolution
ggsave("overlaid_contours_filled.png", width = 10, height = 8, dpi = 300)
```
```{r}

#Load Ethiopia shapefile
ethiopia_shape <- st_read("gadm41_ETH_0.shp")

#Define raster files and target level
raster_files <- list(
  "Food_Insecurity_Combined" = "Food_Insecurity_Combined_5km.tif",
  "Soil_Moisture" = "Food_Insecurity_Soil_Moisture_5km_Masked.tif",
  "Yield" = "Food_Insecurity_Yield_5km_Masked.tif"
)

target_level <- 0.016

#Function to extract contour at specific level
extract_contour_boundary <- function(points, target_level) {
  kde <- kde2d(points$Longitude, points$Latitude, n = 100)
  contours <- contourLines(kde$x, kde$y, kde$z, levels = target_level)
  
  contour_sf <- lapply(contours, function(contour) {
    x <- c(contour$x, contour$x[1])
    y <- c(contour$y, contour$y[1])
    st_polygon(list(cbind(x, y)))
  })
  
  if (length(contour_sf) > 0) {
    contour_sf <- st_sfc(contour_sf)
    contour_sf <- st_sf(geometry = contour_sf)
    st_crs(contour_sf) <- st_crs(ethiopia_shape)
    return(contour_sf)
  } else {
    return(NULL)
  }
}

#Process each raster and extract contours
contour_boundaries <- list()

for (var in names(raster_files)) {
  raster_layer <- rast(raster_files[[var]])
  points <- as.data.frame(raster_layer, xy = TRUE)
  colnames(points) <- c("Longitude", "Latitude", "Value")
  points <- points[points$Value == 1, ]
  
  contour_boundary <- extract_contour_boundary(points, target_level)
  
  if (!is.null(contour_boundary)) {
    contour_boundaries[[var]] <- contour_boundary
    #Add variable name to the sf object
    contour_boundaries[[var]]$Variable <- var
  }
}

#Combine all boundaries into one sf object
all_boundaries <- do.call(rbind, contour_boundaries)

#Define colors and labels
variable_colors <- c(
  "Food_Insecurity_Combined" = "#E64B35B3",
  "Soil_Moisture" = "#4DBBD5B3",
  "Yield" = "#00A087B3"
)

variable_labels <- c(
  "Food_Insecurity_Combined" = "Socio-Economic",
  "Soil_Moisture" = "Environmental",
  "Yield" = "Crop Yield"
)

#Create the plot
ggplot() +
  #Base map
  geom_sf(data = ethiopia_shape, fill = "gray95", color = "gray50", size = 0.3) +
  
  #Add contours with mapped aesthetics for proper legend
  geom_sf(data = all_boundaries, 
          aes(fill = Variable, color = Variable),
          alpha = 0.4, size = 0.5) +
  
  #Custom colors and labels
  scale_fill_manual(
    values = variable_colors,
    labels = variable_labels,
    name = "Variables"
  ) +
  scale_color_manual(
    values = gsub("B3$", "", variable_colors),  
    labels = variable_labels,
    name = "Variables"
  ) +
  
  #Customize the theme and labels
  labs(
    title = "High-Density Regions of Food Insecurity Factors in Ethiopia",
    subtitle = "0.016 Level Contours"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 11),
    legend.position = "right",
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 10),
    legend.box.background = element_rect(color = "gray80", fill = "white"),
    legend.box.margin = margin(6, 6, 6, 6)
  ) +
  coord_sf()

#Save the plot with high resolution
ggsave("overlaid_contours_filled_with_legend.png", width = 12, height = 8, dpi = 300)
```
```{r}


#Load Ethiopia shapefile
ethiopia_shape <- st_read("gadm41_ETH_0.shp")

#Define raster files
raster_files <- list(
  "Socio_Economic" = "Food_Insecurity_Combined_5km.tif",
  "Environmental" = "Food_Insecurity_Soil_Moisture_5km_Masked.tif",
  "Crop_Yield" = "Food_Insecurity_Yield_5km_Masked.tif"
)

#Add population density raster
population_raster <- rast("Population_2020_5km.tif")

#Modified function to create weighted density estimate
weighted_kde2d <- function(x, y, weights, n = 100) {
  #Define the grid
  rx <- range(x)
  ry <- range(y)
  
  #Create evaluation grid
  gx <- seq(rx[1], rx[2], length = n)
  gy <- seq(ry[1], ry[2], length = n)
  
  #Calculate bandwidths using modified Silverman's rule
  hx <- 0.9 * min(sd(x), IQR(x)/1.34) * length(x)^(-0.2)
  hy <- 0.9 * min(sd(y), IQR(y)/1.34) * length(y)^(-0.2)
  
  #Create the density estimate grid
  z <- matrix(0, n, n)
  
  #Normalize weights
  weights <- weights / sum(weights)
  
  #Calculate weighted KDE
  for (i in 1:length(x)) {
    tmp <- outer(dnorm((gx - x[i])/hx)/hx,
                 dnorm((gy - y[i])/hy)/hy)
    z <- z + weights[i] * tmp
  }
  
  return(list(x = gx, y = gy, z = z))
}

#Function to extract weighted contour boundary
extract_weighted_contour <- function(points, population_values, target_level) {
  #Remove NA values
  valid_idx <- !is.na(population_values)
  points <- points[valid_idx, ]
  population_values <- population_values[valid_idx]
  
  #Ensure positive weights
  population_values[population_values < 0] <- 0
  
  #Skip if no valid points
  if (nrow(points) < 3) return(NULL)
  
  #Create weighted density estimate
  kde <- weighted_kde2d(
    points$Longitude, 
    points$Latitude, 
    weights = population_values,
    n = 100
  )
  
  #Generate contours
  contours <- contourLines(kde$x, kde$y, kde$z, levels = target_level)
  
  #Convert to SF object
  contour_sf <- lapply(contours, function(contour) {
    x <- c(contour$x, contour$x[1])
    y <- c(contour$y, contour$y[1])
    st_polygon(list(cbind(x, y)))
  })
  
  if (length(contour_sf) > 0) {
    contour_sf <- st_sfc(contour_sf)
    contour_sf <- st_sf(geometry = contour_sf)
    st_crs(contour_sf) <- st_crs(ethiopia_shape)
    return(contour_sf)
  } else {
    return(NULL)
  }
}

#Process each raster with population weights
contour_boundaries <- list()
target_level <- 0.016

for (var in names(raster_files)) {
  #Load and process raster
  raster_layer <- rast(raster_files[[var]])
  
  #Extract points and values
  points <- as.data.frame(raster_layer, xy = TRUE)
  colnames(points) <- c("Longitude", "Latitude", "Value")
  points <- points[points$Value == 1, ]
  
  #Extract population values for these points
  pop_values <- extract(population_raster, points[, c("Longitude", "Latitude")])
  
  #Extract weighted contour boundary
  contour_boundary <- extract_weighted_contour(points, pop_values[,1], target_level)
  
  if (!is.null(contour_boundary)) {
    contour_boundaries[[var]] <- contour_boundary
    contour_boundaries[[var]]$Variable <- var
  }
}

#Combine all boundaries
all_boundaries <- do.call(rbind, contour_boundaries)

#Define colors and labels
variable_colors <- c(
  "Socio_Economic" = "#E64B35B3",
  "Environmental" = "#4DBBD5B3",
  "Crop_Yield" = "#00A087B3"
)

#Create the visualization
ggplot() +
  geom_sf(data = ethiopia_shape, fill = "gray95", color = "gray50", size = 0.3) +
  geom_sf(data = all_boundaries, 
          aes(fill = Variable, color = Variable),
          alpha = 0.4, size = 0.5) +
  scale_fill_manual(
    values = variable_colors,
    name = "Variables"
  ) +
  scale_color_manual(
    values = gsub("B3$", "", variable_colors),
    name = "Variables"
  ) +
  labs(
    title = "Population-Weighted Food Insecurity Factors in Ethiopia",
    subtitle = "0.016 Level Contours (Weighted by Population Density)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 11),
    legend.position = c(0.95, 0.95),
    legend.justification = c("right", "top"),
    legend.box.background = element_rect(color = "gray80", fill = "white"),
    legend.box.margin = margin(6, 6, 6, 6)
  ) +
  coord_sf()

#Save the plot
ggsave("population_weighted_contours.png", width = 12, height = 8, dpi = 300)
```
```{r}


#Load necessary files
ethiopia_shape <- st_read("gadm41_ETH_0.shp")
population_raster <- rast("Population_2020_5km.tif")

#Define raster files for analysis
raster_files <- list(
  "Market_Access" = "Food_Insecurity_Market_Proximity_5km_Masked.tif",
  "Road_Access" = "Food_Insecurity_Road_Proximity_5km_Masked.tif",
  "Economic_Status" = "Food_Insecurity_RWI_5km_Masked.tif",
  "Soil_Moisture" = "Food_Insecurity_Soil_Moisture_5km_Masked.tif",
  "Yield" = "Food_Insecurity_Yield_5km_Masked.tif"
)

#Function to calculate relative influence
calculate_relative_influence <- function(var_raster, pop_raster) {
  #Ensure same extent and resolution
  pop_raster <- resample(pop_raster, var_raster)
  
  #Convert to dataframe
  df <- as.data.frame(c(var_raster, pop_raster), xy = TRUE)
  colnames(df) <- c("x", "y", "variable", "population")
  
  #Calculate relative influence
  df$relative_influence <- df$variable / (df$population + 1)  
  
  return(df)
}

#Process each variable
relative_influence_plots <- list()
combined_data <- data.frame()

for (var_name in names(raster_files)) {
  #Load variable raster
  var_raster <- rast(raster_files[[var_name]])
  
  #Calculate relative influence
  influence_df <- calculate_relative_influence(var_raster, population_raster)
  influence_df$variable <- var_name
  
  #Add to combined dataset
  combined_data <- rbind(combined_data, influence_df)
  
  #Create plot
  p <- ggplot() +
    geom_sf(data = ethiopia_shape, fill = "gray95", color = "black", size = 0.5) +
    geom_tile(data = influence_df, 
              aes(x = x, y = y, fill = relative_influence),
              alpha = 0.7) +
    scale_fill_viridis_c(option = "magma") +
    labs(title = paste("Relative Influence:", var_name),
         fill = "Relative\nInfluence") +
    theme_minimal()
  
  relative_influence_plots[[var_name]] <- p
}

#Create composite score
combined_data_wide <- combined_data %>%
  pivot_wider(id_cols = c("x", "y"), 
              names_from = "variable", 
              values_from = "relative_influence")

#Calculate dominant variable for each location
combined_data_wide$dominant_var <- colnames(combined_data_wide)[3:7][max.col(combined_data_wide[,3:7])]

#Create dominance map
dominance_plot <- ggplot() +
  geom_sf(data = ethiopia_shape, fill = "gray95", color = "black", size = 0.5) +
  geom_tile(data = combined_data_wide, 
            aes(x = x, y = y, fill = dominant_var),
            alpha = 0.7) +
  scale_fill_brewer(palette = "Set3") +
  labs(title = "Dominant Variable Influence Map",
       fill = "Dominant\nVariable") +
  theme_minimal()

#Display plots
print(dominance_plot)
for (p in relative_influence_plots) {
  print(p)
}

#Save results
ggsave("dominance_map.png", dominance_plot, width = 10, height = 8)
for (var_name in names(relative_influence_plots)) {
  ggsave(paste0("relative_influence_", var_name, ".png"), 
         relative_influence_plots[[var_name]], 
         width = 10, height = 8)
}
```

```{r}


#Load necessary files
ethiopia_shape <- st_read("gadm41_ETH_0.shp")
population_raster <- rast("Population_2020_5km.tif")

#Define socio-economic raster files to be merged
socioeconomic_files <- list(
  "Market_Access" = "Food_Insecurity_Market_Proximity_5km_Masked.tif",
  "Road_Access" = "Food_Insecurity_Road_Proximity_5km_Masked.tif",
  "Economic_Status" = "Food_Insecurity_RWI_5km_Masked.tif"
)

#Define separate environmental files
environmental_files <- list(
  "Soil_Moisture" = "Food_Insecurity_Soil_Moisture_5km_Masked.tif",
  "Yield" = "Food_Insecurity_Yield_5km_Masked.tif"
)

#Function to calculate relative influence
calculate_relative_influence <- function(var_raster, pop_raster) {
  pop_raster <- resample(pop_raster, var_raster)
  df <- as.data.frame(c(var_raster, pop_raster), xy = TRUE)
  colnames(df) <- c("x", "y", "variable", "population")
  df$relative_influence <- df$variable / (df$population + 1)
  return(df)
}

#Load socioeconomic rasters
market_rast <- rast(socioeconomic_files[["Market_Access"]])
road_rast <- rast(socioeconomic_files[["Road_Access"]])
rwi_rast <- rast(socioeconomic_files[["Economic_Status"]])

#Stack the rasters
socio_stack <- c(market_rast, road_rast, rwi_rast)

#Create combined socioeconomic raster using maximum value
combined_socioeconomic <- max(socio_stack)

#Initialize combined data frame
combined_data <- data.frame()

#Process socio-economic data
influence_df_socio <- calculate_relative_influence(combined_socioeconomic, population_raster)
influence_df_socio$variable <- "Socio_Economic"
combined_data <- rbind(combined_data, influence_df_socio)

#Process environmental variables separately
for (var_name in names(environmental_files)) {
  var_raster <- rast(environmental_files[[var_name]])
  influence_df <- calculate_relative_influence(var_raster, population_raster)
  influence_df$variable <- var_name
  combined_data <- rbind(combined_data, influence_df)
}

#Create individual influence plots
relative_influence_plots <- list()
for (var_name in unique(combined_data$variable)) {
  var_data <- subset(combined_data, variable == var_name)
  
  p <- ggplot() +
    geom_sf(data = ethiopia_shape, fill = "gray95", color = "black", size = 0.5) +
    geom_tile(data = var_data, 
              aes(x = x, y = y, fill = relative_influence),
              alpha = 0.7) +
    scale_fill_viridis_c(option = "magma") +
    labs(title = paste("Relative Influence:", gsub("_", " ", var_name)),
         fill = "Relative\nInfluence") +
    theme_minimal()
  
  relative_influence_plots[[var_name]] <- p
}

#Create composite score for dominance map
combined_data_wide <- combined_data %>%
  pivot_wider(id_cols = c("x", "y"), 
              names_from = "variable", 
              values_from = "relative_influence")

#Calculate dominant variable for each location
combined_data_wide$dominant_var <- colnames(combined_data_wide)[3:5][max.col(combined_data_wide[,3:5])]

#Create dominance map with distinct colors
dominance_plot <- ggplot() +
  geom_sf(data = ethiopia_shape, fill = "gray95", color = "black", size = 0.5) +
  geom_tile(data = combined_data_wide, 
            aes(x = x, y = y, fill = dominant_var),
            alpha = 0.7) +
  scale_fill_manual(values = c(
    "Socio_Economic" = "#FF9999", 
    "Soil_Moisture" = "#66CC66",   
    "Yield" = "#6699CC"
  )) +
  labs(title = "Dominant Variable Influence Map",
       fill = "Dominant\nVariable") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 10),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12)
  )

#Display plots
print(dominance_plot)
for (p in relative_influence_plots) {
  print(p)
}

#Save results
ggsave("dominance_map_final.png", dominance_plot, width = 10, height = 8, dpi = 300)
for (var_name in names(relative_influence_plots)) {
  ggsave(
    paste0("relative_influence_", gsub(" ", "_", var_name), ".png"), 
    relative_influence_plots[[var_name]], 
    width = 10, height = 8, dpi = 300
  )
}
```

```{r}

#Load necessary files
ethiopia_shape <- st_read("gadm41_ETH_0.shp")
population_raster <- rast("Population_2020_5km.tif")

#Load and process rasters
socioeconomic_files <- list(
  "Market_Access" = "Food_Insecurity_Market_Proximity_5km_Masked.tif",
  "Road_Access" = "Food_Insecurity_Road_Proximity_5km_Masked.tif",
  "Economic_Status" = "Food_Insecurity_RWI_5km_Masked.tif"
)

environmental_files <- list(
  "Soil_Moisture" = "Food_Insecurity_Soil_Moisture_5km_Masked.tif",
  "Yield" = "Food_Insecurity_Yield_5km_Masked.tif"
)

#Function to create points dataframe from raster
create_points_df <- function(raster, name) {
  df <- as.data.frame(raster, xy = TRUE)
  colnames(df) <- c("x", "y", "value")
  df$variable <- name
  return(df[df$value == 1, ])  #Keep only presence points
}

#Process socioeconomic rasters
market_rast <- rast(socioeconomic_files[["Market_Access"]])
road_rast <- rast(socioeconomic_files[["Road_Access"]])
rwi_rast <- rast(socioeconomic_files[["Economic_Status"]])

#Combine socioeconomic rasters
socio_stack <- c(market_rast, road_rast, rwi_rast)
combined_socioeconomic <- max(socio_stack)

#Create points dataframes
socio_points <- create_points_df(combined_socioeconomic, "Socio_Economic")
soil_points <- create_points_df(rast(environmental_files[["Soil_Moisture"]]), "Soil_Moisture")
yield_points <- create_points_df(rast(environmental_files[["Yield"]]), "Yield")

#Combine all points
all_points <- rbind(socio_points, soil_points, yield_points)

#Create density contour plot
ggplot() +
  geom_sf(data = ethiopia_shape, fill = "gray95", color = "black", size = 0.5) +
  geom_density_2d_filled(data = all_points, 
                        aes(x = x, y = y, fill = stat(level), group = variable),
                        alpha = 0.5,
                        bins = 10) +
  facet_wrap(~variable) +
  scale_fill_viridis_d(option = "magma", direction = -1) +
  labs(title = "High-Density Regions of Food Insecurity Factors in Ethiopia",
       subtitle = "0.015 Level Contours",
       fill = "Density\nLevel") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    plot.subtitle = element_text(size = 12),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 10),
    strip.text = element_text(size = 12, face = "bold")
  )

#Save the plot
ggsave("variable_density_contours.png", width = 15, height = 6, dpi = 300)

#Create combined plot with overlapping contours
ggplot() +
  geom_sf(data = ethiopia_shape, fill = "gray95", color = "black", size = 0.5) +
  geom_density_2d(data = all_points, 
                 aes(x = x, y = y, color = variable),
                 linewidth = 0.75,
                 alpha = 0.6,
                 bins = 8) +
  scale_color_manual(values = c(
    "Socio_Economic" = "#FF9999",
    "Soil_Moisture" = "#66CC66",
    "Yield" = "#6699CC"
  )) +
  labs(title = "Overlapping Influence Regions of Food Insecurity Factors",
       color = "Variable") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 10)
  )

#Save the combined plot
ggsave("combined_influence_contours.png", width = 10, height = 8, dpi = 300)
```

```{r}

#Load necessary files
ethiopia_shape <- st_read("gadm41_ETH_0.shp")
population_raster <- rast("Population_2020_5km.tif")

#Load and process rasters
socioeconomic_files <- list(
  "Market_Access" = "Food_Insecurity_Market_Proximity_5km_Masked.tif",
  "Road_Access" = "Food_Insecurity_Road_Proximity_5km_Masked.tif",
  "Economic_Status" = "Food_Insecurity_RWI_5km_Masked.tif"
)

environmental_files <- list(
  "Soil_Moisture" = "Food_Insecurity_Soil_Moisture_5km_Masked.tif",
  "Yield" = "Food_Insecurity_Yield_5km_Masked.tif"
)

#Function to create points dataframe from raster
create_points_df <- function(raster, name) {
  df <- as.data.frame(raster, xy = TRUE)
  colnames(df) <- c("x", "y", "value")
  df$variable <- name
  return(df[df$value == 1, ])
}

#Process socioeconomic rasters
market_rast <- rast(socioeconomic_files[["Market_Access"]])
road_rast <- rast(socioeconomic_files[["Road_Access"]])
rwi_rast <- rast(socioeconomic_files[["Economic_Status"]])

#Combine socioeconomic rasters
socio_stack <- c(market_rast, road_rast, rwi_rast)
combined_socioeconomic <- max(socio_stack)

#Create points dataframes
socio_points <- create_points_df(combined_socioeconomic, "Socio_Economic")
soil_points <- create_points_df(rast(environmental_files[["Soil_Moisture"]]), "Soil_Moisture")
yield_points <- create_points_df(rast(environmental_files[["Yield"]]), "Yield")

#Combine all points
all_points <- rbind(socio_points, soil_points, yield_points)

#Create separate faceted plot
p1 <- ggplot() +
  geom_sf(data = ethiopia_shape, fill = "gray95", color = "black", size = 0.5) +
  stat_density_2d(data = all_points,
                 aes(x = x, y = y, fill = after_stat(level)),
                 geom = "polygon",
                 bins = 3,
                 contour_var = "ndensity") +
  facet_wrap(~variable) +
  scale_fill_gradientn(
    colors = c("#FFE5E5", "#FFB3B3", "#FF8080"),
    name = "Density\nLevel",
    breaks = c(0.25, 0.5, 0.75),
    labels = c("Low", "Medium", "High"),
    guide = guide_colorbar(
      direction = "horizontal",
      title.position = "top",
      barwidth = 10
    )
  ) +
  labs(title = "High-Density Regions of Food Insecurity Factors in Ethiopia",
       subtitle = "Three-Level Influence Zones") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    plot.subtitle = element_text(size = 12),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 10),
    strip.text = element_text(size = 12, face = "bold"),
    legend.position = "bottom"
  )

#Create combined plot
p2 <- ggplot() +
  geom_sf(data = ethiopia_shape, fill = "gray95", color = "black", size = 0.5) +
  stat_density_2d(data = all_points,
                 aes(x = x, y = y, 
                     fill = variable,
                     alpha = after_stat(level)),
                 geom = "polygon",
                 bins = 3,
                 contour_var = "ndensity") +
  scale_fill_manual(values = c(
    "Socio_Economic" = "#FF9999",
    "Soil_Moisture" = "#66CC66",
    "Yield" = "#6699CC"
  )) +
  scale_alpha(range = c(0.2, 0.6), guide = "none") +
  labs(title = "Overlapping Influence Regions of Food Insecurity Factors",
       subtitle = "Three-Level Density Zones",
       fill = "Variable") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    plot.subtitle = element_text(size = 12),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 10),
    legend.position = "right"
  )

#Save plots
ggsave("variable_density_three_levels.png", p1, width = 15, height = 6, dpi = 300)
ggsave("combined_influence_three_levels.png", p2, width = 10, height = 8, dpi = 300)

```

```{r}


#Load necessary files
ethiopia_shape <- st_read("gadm41_ETH_0.shp")
population_raster <- rast("Population_2020_5km.tif")

#Load and process rasters
socioeconomic_files <- list(
  "Market_Access" = "Food_Insecurity_Market_Proximity_5km_Masked.tif",
  "Road_Access" = "Food_Insecurity_Road_Proximity_5km_Masked.tif",
  "Economic_Status" = "Food_Insecurity_RWI_5km_Masked.tif"
)

environmental_files <- list(
  "Soil_Moisture" = "Food_Insecurity_Soil_Moisture_5km_Masked.tif",
  "Yield" = "Food_Insecurity_Yield_5km_Masked.tif"
)

#Function to create points dataframe from raster
create_points_df <- function(raster, name) {
  df <- as.data.frame(raster, xy = TRUE)
  colnames(df) <- c("x", "y", "value")
  df$variable <- name
  return(df[df$value == 1, ])
}

#Process socioeconomic rasters
market_rast <- rast(socioeconomic_files[["Market_Access"]])
road_rast <- rast(socioeconomic_files[["Road_Access"]])
rwi_rast <- rast(socioeconomic_files[["Economic_Status"]])

#Combine socioeconomic rasters
socio_stack <- c(market_rast, road_rast, rwi_rast)
combined_socioeconomic <- max(socio_stack)

#Create points dataframes
socio_points <- create_points_df(combined_socioeconomic, "Socio_Economic")
soil_points <- create_points_df(rast(environmental_files[["Soil_Moisture"]]), "Soil_Moisture")
yield_points <- create_points_df(rast(environmental_files[["Yield"]]), "Yield")

#Create layered plot
ggplot() +
  #Base map
  geom_sf(data = ethiopia_shape, fill = "white", color = "black", size = 0.5) +
  
  #Add yield layer
  stat_density_2d_filled(data = subset(yield_points, variable == "Yield"),
                        aes(x = x, y = y),
                        alpha = 0.4,
                        bins = 3,
                        fill = "#6699CC",
                        contour_var = "ndensity") +
  
  #Add soil moisture layer
  stat_density_2d_filled(data = subset(soil_points, variable == "Soil_Moisture"),
                        aes(x = x, y = y),
                        alpha = 0.4,
                        bins = 3,
                        fill = "#66CC66",
                        contour_var = "ndensity") +
  
  #Add socio-economic layer
  stat_density_2d_filled(data = subset(socio_points, variable == "Socio_Economic"),
                        aes(x = x, y = y),
                        alpha = 0.4,
                        bins = 3,
                        fill = "#FF9999",
                        contour_var = "ndensity") +
  
  #Add contour lines for definition
  stat_density_2d(data = yield_points,
                 aes(x = x, y = y, color = "Yield"),
                 size = 0.5,
                 alpha = 0.8,
                 bins = 3,
                 contour_var = "ndensity") +
  stat_density_2d(data = soil_points,
                 aes(x = x, y = y, color = "Soil_Moisture"),
                 size = 0.5,
                 alpha = 0.8,
                 bins = 3,
                 contour_var = "ndensity") +
  stat_density_2d(data = socio_points,
                 aes(x = x, y = y, color = "Socio_Economic"),
                 size = 0.5,
                 alpha = 0.8,
                 bins = 3,
                 contour_var = "ndensity") +
  
  #Set colors for contour lines
  scale_color_manual(name = "Variables",
                    values = c(
                      "Yield" = "#2B5C8C",
                      "Soil_Moisture" = "#2B8C2B",
                      "Socio_Economic" = "#8C2B2B"
                    )) +
  
  #Labels and theme
  labs(title = "Overlapping Regions of Food Insecurity Factors in Ethiopia",
       subtitle = "Showing density zones for each variable") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    plot.subtitle = element_text(size = 12),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 10),
    legend.position = "right"
  )

#Save the plot
ggsave("layered_density_map.png", width = 12, height = 8, dpi = 300)
```

```{r}

#Load necessary files
ethiopia_shape <- st_read("gadm41_ETH_0.shp")
population_raster <- rast("Population_2020_5km.tif")

#Load and process rasters
socioeconomic_files <- list(
  "Market_Access" = "Food_Insecurity_Market_Proximity_5km_Masked.tif",
  "Road_Access" = "Food_Insecurity_Road_Proximity_5km_Masked.tif",
  "Economic_Status" = "Food_Insecurity_RWI_5km_Masked.tif"
)

environmental_files <- list(
  "Soil_Moisture" = "Food_Insecurity_Soil_Moisture_5km_Masked.tif",
  "Yield" = "Food_Insecurity_Yield_5km_Masked.tif"
)

#Function to create points dataframe from raster
create_points_df <- function(raster, name) {
  df <- as.data.frame(raster, xy = TRUE)
  colnames(df) <- c("x", "y", "value")
  df$variable <- name
  return(df[df$value == 1, ])
}

#Process rasters
market_rast <- rast(socioeconomic_files[["Market_Access"]])
road_rast <- rast(socioeconomic_files[["Road_Access"]])
rwi_rast <- rast(socioeconomic_files[["Economic_Status"]])
socio_stack <- c(market_rast, road_rast, rwi_rast)
combined_socioeconomic <- max(socio_stack)

#Create points dataframes
socio_points <- create_points_df(combined_socioeconomic, "Socio_Economic")
soil_points <- create_points_df(rast(environmental_files[["Soil_Moisture"]]), "Soil_Moisture")
yield_points <- create_points_df(rast(environmental_files[["Yield"]]), "Yield")

#Create plot
ggplot() +
  #Base map
  geom_sf(data = ethiopia_shape, fill = "white", color = "black", size = 0.5) +
  
  #Add filled areas with single contour level
  #Yield layer
  stat_density_2d(data = subset(yield_points, variable == "Yield"),
                 aes(x = x, y = y),
                 geom = "polygon",
                 fill = "#6699CC",
                 alpha = 0.3,
                 color = "#2B5C8C",
                 size = 0.5,
                 bins = 3) +
  
  #Soil moisture layer
  stat_density_2d(data = subset(soil_points, variable == "Soil_Moisture"),
                 aes(x = x, y = y),
                 geom = "polygon",
                 fill = "#66CC66",
                 alpha = 0.3,
                 color = "#2B8C2B",
                 size = 0.5,
                 bins = 3) +
  
  #Socio-economic layer
  stat_density_2d(data = subset(socio_points, variable == "Socio_Economic"),
                 aes(x = x, y = y),
                 geom = "polygon",
                 fill = "#FF9999",
                 alpha = 0.3,
                 color = "#8C2B2B",
                 size = 0.5,
                 bins = 3) +
  
  #Add legend
  scale_color_manual(name = "Variables",
                    values = c(
                      "Socio_Economic" = "#8C2B2B",
                      "Soil_Moisture" = "#2B8C2B",
                      "Yield" = "#2B5C8C"
                    )) +
  
  #Labels and theme
  labs(title = "Overlapping Regions of Food Insecurity Factors in Ethiopia",
       subtitle = "Showing density zones for each variable") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    plot.subtitle = element_text(size = 12),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 10),
    legend.position = "right",
    panel.background = element_rect(fill = "gray95", color = NA),
    panel.grid = element_line(color = "white")
  )

#Save the plot
ggsave("simple_filled_contours.png", width = 12, height = 8, dpi = 300)
```




```{r}


#Load Ethiopia shapefile
ethiopia_shape <- st_read("gadm41_ETH_0.shp")

#Define raster files
raster_files <- list(
  "Food_Insecurity_Combined" = "Food_Insecurity_Combined_5km.tif",
  "Soil_Moisture" = "Food_Insecurity_Soil_Moisture_5km_Masked.tif",
  "Yield" = "Food_Insecurity_Yield_5km_Masked.tif"
)

#Create a list to store contour data
contour_data_list <- list()

for (var in names(raster_files)) {
  file_path <- raster_files[[var]]

  #Load raster
  raster_layer <- rast(file_path)

  #Convert raster to dataframe
  points <- as.data.frame(raster_layer, xy = TRUE)
  colnames(points) <- c("Longitude", "Latitude", "Value")

  #Keep only presence locations
  points <- points[points$Value == 1, ]

  #Ensure there are enough points
  if (nrow(points) < 10) {
    print(paste("Skipping:", var, "- Not enough data points"))
    next
  }

  #Generate contour density plot and extract contours
  p <- ggplot() +
    geom_sf(data = ethiopia_shape, fill = "gray95", color = "black", size = 0.5) +
    geom_density2d_filled(data = points, aes(x = Longitude, y = Latitude), bins = 15, alpha = 0.7) +
    scale_fill_viridis_d(option = "magma") +
    labs(title = paste("Contour Density Map:", var), x = "Longitude", y = "Latitude") +
    theme_minimal()

  #Extract density levels from ggplot
  density_contours <- ggplot_build(p)$data[[2]]  
  
  #Store contour data in a dataframe
  contour_df <- data.frame(
    Longitude = density_contours$x,
    Latitude = density_contours$y,
    Level = density_contours$level
  )

  #Save as CSV for later conversion to raster
  write.csv(contour_df, paste0("Contour_Density_", var, ".csv"), row.names = FALSE)

  #Store for further processing
  contour_data_list[[var]] <- contour_df
}

print("Contour density data saved as CSV.")
```

```{r}

#Load Ethiopia boundary
ethiopia_shape <- st_read("gadm41_ETH_0.shp")

#Ensure CRS is correctly assigned (EPSG:4326)
if (is.na(st_crs(ethiopia_shape))) {
  print("Assigning EPSG:4326 to Ethiopia shapefile.")
  st_crs(ethiopia_shape) <- 4326
}

#Define contour CSV files
contour_csv_files <- list(
  "Food_Insecurity_Combined" = "Contour_Density_Food_Insecurity_Combined.csv",
  "Soil_Moisture" = "Contour_Density_Soil_Moisture.csv",
  "Yield" = "Contour_Density_Yield.csv"
)

#Create a list to store final raster outputs
contour_rasters <- list()

for (var in names(contour_csv_files)) {
  contour_csv <- contour_csv_files[[var]]

  #Load contour CSV
  contour_df <- read.csv(contour_csv)

  #Convert to SpatVector for rasterization
  contour_vect <- vect(contour_df, geom = c("Longitude", "Latitude"), crs = "EPSG:4326")

  #Create an empty raster (5km resolution) based on Ethiopia's extent
  template_raster <- rast(ethiopia_shape, resolution = 0.05)  #Approx. 5km

  #Rasterize contour points using "Level" values
  contour_raster <- rasterize(contour_vect, template_raster, field = "Level", background = NA)

  #Mask raster to Ethiopia boundary
  contour_raster_masked <- mask(contour_raster, ethiopia_shape)

  #Save raster
  output_filename <- paste0("Contour_Density_", var, "_5km.tif")
  writeRaster(contour_raster_masked, output_filename, overwrite = TRUE)

  #Store raster in list
  contour_rasters[[var]] <- contour_raster_masked
}

print("Contour density rasters saved.")
```
```{r}


#Load Ethiopia boundary
ethiopia_shape <- st_read("gadm41_ETH_0.shp")

#Ensure CRS is assigned (EPSG:4326)
if (is.na(st_crs(ethiopia_shape))) {
  print("Assigning EPSG:4326 to Ethiopia shapefile.")
  st_crs(ethiopia_shape) <- 4326
}

#Define saved contour density raster files
contour_raster_files <- list(
  "Food_Insecurity_Combined" = "Contour_Density_Food_Insecurity_Combined_5km.tif",
  "Soil_Moisture" = "Contour_Density_Soil_Moisture_5km.tif",
  "Yield" = "Contour_Density_Yield_5km.tif"
)

#Lower the threshold value
threshold_value <- 0.012  

#Create a list to store final raster outputs
thresholded_rasters <- list()

for (var in names(contour_raster_files)) {
  file_path <- contour_raster_files[[var]]

  #Load the raster
  contour_raster <- rast(file_path)

  #Apply threshold: Keep only values greater than 0.012
  thresholded_raster <- classify(contour_raster, matrix(c(-Inf, threshold_value, 0, threshold_value, Inf, 1), ncol = 3, byrow = TRUE))

  #Mask raster to Ethiopia boundary
  thresholded_raster_masked <- mask(thresholded_raster, ethiopia_shape)

  #Apply focal smoothing with a larger 5x5 kernel
  smoothed_raster <- focal(thresholded_raster_masked, w = matrix(1, 5, 5), fun = mean, na.rm = TRUE)

  #Reapply the threshold to remove low-density pixels after smoothing
  smoothed_raster <- classify(smoothed_raster, matrix(c(-Inf, threshold_value, 0, threshold_value, Inf, 1), ncol = 3, byrow = TRUE))

  #Save the improved smoothed raster
  output_filename <- paste0("Improved_Smoothed_High_Density_", var, "_5km.tif")
  writeRaster(smoothed_raster, output_filename, overwrite = TRUE)

  #Store in list
  thresholded_rasters[[var]] <- smoothed_raster
}

print("Improved thresholded rasters saved (values > 0.012).")

#Plot the results
par(mfrow = c(2, 2))  

for (var in names(thresholded_rasters)) {
  plot(thresholded_rasters[[var]], main = paste("Smoothed High-Density Contour:", var), col = c("white", "red"))
}

par(mfrow = c(1, 1)) 
```
```{r}


#Load Ethiopia boundary
ethiopia_shape <- st_read("gadm41_ETH_0.shp")

#Ensure CRS is assigned (EPSG:4326)
if (is.na(st_crs(ethiopia_shape))) {
  print("Assigning EPSG:4326 to Ethiopia shapefile.")
  st_crs(ethiopia_shape) <- 4326
}

#Define saved contour density raster files
contour_raster_files <- list(
  "Food_Insecurity_Combined" = "Contour_Density_Food_Insecurity_Combined_5km.tif",
  "Soil_Moisture" = "Contour_Density_Soil_Moisture_5km.tif",
  "Yield" = "Contour_Density_Yield_5km.tif"
)

#Set threshold to 0.016
threshold_value <- 0.016  

#Create a list to store final raster outputs
thresholded_rasters <- list()

for (var in names(contour_raster_files)) {
  file_path <- contour_raster_files[[var]]

  #Load the raster
  contour_raster <- rast(file_path)

  #Apply threshold: Keep only values greater than 0.016
  thresholded_raster <- classify(contour_raster, matrix(c(-Inf, threshold_value, 0, threshold_value, Inf, 1), ncol = 3, byrow = TRUE))

  #Mask raster to Ethiopia boundary
  thresholded_raster_masked <- mask(thresholded_raster, ethiopia_shape)

  #Apply focal smoothing with a larger 5x5 kernel
  smoothed_raster <- focal(thresholded_raster_masked, w = matrix(1, 5, 5), fun = mean, na.rm = TRUE)

  #Reapply the threshold to remove low-density pixels after smoothing
  smoothed_raster <- classify(smoothed_raster, matrix(c(-Inf, threshold_value, 0, threshold_value, Inf, 1), ncol = 3, byrow = TRUE))

  #Save the improved smoothed raster
  output_filename <- paste0("Final_Smoothed_High_Density_", var, "_5km.tif")
  writeRaster(smoothed_raster, output_filename, overwrite = TRUE)

  #Store in list
  thresholded_rasters[[var]] <- smoothed_raster
}

print("Final thresholded rasters saved (values > 0.016).")

#Plot the results
par(mfrow = c(2, 2))  

for (var in names(thresholded_rasters)) {
  plot(thresholded_rasters[[var]], main = paste("Final Smoothed High-Density Contour:", var), col = c("white", "red"))
}

par(mfrow = c(1, 1)) 
```

```{r}


#Load Ethiopia boundary
ethiopia_shape <- st_read("gadm41_ETH_0.shp")

#Define raster files for contour density mapping
raster_files <- list(
  "Food_Insecurity_Combined" = "Food_Insecurity_Combined_5km.tif",
  "Soil_Moisture" = "Food_Insecurity_Soil_Moisture_5km_Masked.tif",
  "Yield" = "Food_Insecurity_Yield_5km_Masked.tif"
)

#Define the threshold contour level
contour_level <- 0.016

#Create and save contour shapefiles
for (var in names(raster_files)) {
  file_path <- raster_files[[var]]

  #Load raster
  raster_layer <- rast(file_path)

  #Extract contour lines at the 0.016 level
  contour_lines <- as.contour(raster_layer, levels = contour_level)

  #Convert to sf object for saving as shapefile
  contour_sf <- st_as_sf(contour_lines)

  #Ensure CRS matches Ethiopia shapefile
  st_crs(contour_sf) <- st_crs(ethiopia_shape)

  #Save as shapefile
  output_filename <- paste0("Contour_Boundary_", var, ".shp")
  st_write(contour_sf, output_filename, delete_dsn = TRUE)

  print(paste("Saved contour boundary shapefile for:", var))
}

print("All contour boundary shapefiles saved successfully.")
```

```{r}

#Load Ethiopia boundary
ethiopia_shape <- st_read("gadm41_ETH_0.shp")

#Ensure CRS is assigned (EPSG:4326) if missing
if (is.na(st_crs(ethiopia_shape))) {
  print("Assigning EPSG:4326 to Ethiopia shapefile.")
  st_crs(ethiopia_shape) <- 4326
}

#Define raster files for contour extraction
raster_files <- list(
  "Food_Insecurity_Combined" = "Food_Insecurity_Combined_5km.tif",
  "Soil_Moisture" = "Food_Insecurity_Soil_Moisture_5km_Masked.tif",
  "Yield" = "Food_Insecurity_Yield_5km_Masked.tif"
)

#Define the threshold contour level
contour_level <- 0.016

#Process each raster and save contours
for (var in names(raster_files)) {
  file_path <- raster_files[[var]]

  #Load raster
  raster_layer <- rast(file_path)

  #Ensure raster has a CRS before extracting contours
  if (is.na(crs(raster_layer))) {
    print(paste("Assigning EPSG:4326 to raster for", var))
    crs(raster_layer) <- "EPSG:4326"
  }

  #Extract contour lines at 0.016 level
  contour_lines <- as.contour(raster_layer, levels = contour_level)

  #Convert to sf object
  contour_sf <- st_as_sf(contour_lines)

  #Ensure CRS matches Ethiopia boundary
  st_crs(contour_sf) <- st_crs(ethiopia_shape)

  #Save contour as shapefile
  output_filename <- paste0("Contour_Boundary_", var, ".shp")
  st_write(contour_sf, output_filename, delete_layer = TRUE, append = FALSE)

  print(paste("Saved contour boundary shapefile for:", var))
}

print("All contour boundary shapefiles saved successfully.")
```
```{r}
#Define output for boundary coordinate extraction
boundary_coordinates <- list()

for (var in names(raster_files)) {
  contour_shapefile <- paste0("Contour_Boundary_", var, ".shp")

  if (!file.exists(contour_shapefile)) {
    print(paste("Error: Contour shapefile not found for", var))
    next
  }

  #Load contour shapefile
  contour_sf <- st_read(contour_shapefile)

  #Extract intersecting Ethiopia boundary coordinates
  intersected_boundary <- st_intersection(ethiopia_shape, contour_sf)

  #Convert to dataframe
  boundary_df <- as.data.frame(st_coordinates(intersected_boundary))

  #Save coordinates to CSV
  write.csv(boundary_df, paste0("Boundary_Coordinates_", var, ".csv"), row.names = FALSE)

  #Store for reference
  boundary_coordinates[[var]] <- boundary_df

  print(paste("Extracted and saved boundary coordinates for:", var))
}

print("All Ethiopia boundary coordinates corresponding to contours have been saved.")
```

```{r}

#Load Ethiopia boundary shapefile
ethiopia_shape <- st_read("gadm41_ETH_0.shp")

#Assign CRS if missing
if (is.na(st_crs(ethiopia_shape))) {
  print("⚠ Warning: CRS missing for Ethiopia shapefile - Assigning EPSG:4326")
  st_crs(ethiopia_shape) <- 4326
}

#Define saved contour boundary shapefiles
contour_shapefiles <- list(
  "Food_Insecurity_Combined" = "Contour_Boundary_Food_Insecurity_Combined.shp",
  "Soil_Moisture" = "Contour_Boundary_Soil_Moisture.shp",
  "Yield" = "Contour_Boundary_Yield.shp"
)

#Create an empty list to store loaded shapefiles
loaded_shapefiles <- list()

#Load and plot each contour boundary shapefile
for (var in names(contour_shapefiles)) {
  shapefile_path <- contour_shapefiles[[var]]

}
  if (!file.exists(shapefile_path)) {
    print(paste("❌ Error: Shapefile not found for", var))
    next
  }

  #Load contour shapefile
  contour_sf <- st_read(shapefile_path)

  #Ensure CRS is assigned (if missing, assign EPSG:4326)
  if (is.na(st_crs(contour_sf))) {
    print(paste("⚠ Warning: CRS missing for", var, "- Assigning EPSG:4326"))
    st_crs(contour_sf) <- 4326
  }

  to match Ethiopia CRS (if needed)
  if (st_crs(contour_sf) != st_crs(ethiopia_shape)) {
    print(paste("🔄 Reprojecting", var, "to match Ethiopia boundary CRS"))
    contour_sf <- st_transform(contour_sf, st_crs(ethiopia_shape))
  }

  #Store the loaded shapefile
  loaded_shapefiles[[var]] <- contour_sf

  #Plot the shapefile
  p <- ggplot() +
    geom_sf(data = ethiopia_shape, fill = "gray95", color = "black") + 
    geom_sf(data = contour_sf, color = "red", size = 0.7) +  
    labs(title = paste("Contour Boundary:", var), x = "Longitude", y = "Latitude") +
    theme_minimal()

  print(p)
}

print("All contour boundary shapefiles have been loaded and plotted successfully.")
```


```{r}

#Load Ethiopia shapefile (ensure CRS is set)
ethiopia_shape <- st_read("gadm41_ETH_0.shp")

#Assign missing CRS if necessary
if (is.na(st_crs(ethiopia_shape))) {
  print("Assigning EPSG:4326 (WGS84) to Ethiopia shapefile.")
  st_crs(ethiopia_shape) <- 4326
}

#Define raster files for KDE density mapping
raster_files <- list(
  "Food_Insecurity_Combined" = "Food_Insecurity_Combined_5km.tif",
  "Soil_Moisture" = "Food_Insecurity_Soil_Moisture_5km_Masked.tif",
  "Yield" = "Food_Insecurity_Yield_5km_Masked.tif"
)

#Process each raster and generate KDE
kde_rasters <- list()

for (var in names(raster_files)) {
  file_path <- raster_files[[var]]

  #Load raster
  raster_layer <- rast(file_path)

  #Convert raster to dataframe
  points <- as.data.frame(raster_layer, xy = TRUE)
  colnames(points) <- c("Longitude", "Latitude", "Value")

  #Keep only presence locations (food insecurity = 1)
  points <- points[points$Value == 1, ]

  #Ensure there are enough points for KDE
  if (nrow(points) < 10) {
    print(paste("Skipping:", var, "- Not enough data points"))
    next
  }

  #Convert data frame to SpatVector
  points_vect <- vect(points, geom = c("Longitude", "Latitude"), crs = "EPSG:4326")

  #Rasterize points
  density_raster <- rasterize(points_vect, raster_layer, fun = "count", background = 0)

  #Normalize KDE values between 0-1
  density_raster <- (density_raster - min(values(density_raster))) / (max(values(density_raster)) - min(values(density_raster)))

  #Crop and mask KDE raster to Ethiopia boundary
  density_raster_cropped <- mask(crop(density_raster, ethiopia_shape), ethiopia_shape)

  #Save KDE raster as TIFF
  output_filename <- paste0("KDE_", var, "_5km.tif")
  writeRaster(density_raster_cropped, output_filename, overwrite = TRUE)

  #Store for reference
  kde_rasters[[var]] <- density_raster_cropped
}

#Plot KDE Rasters
par(mfrow = c(2, 2))

for (var in names(kde_rasters)) {
  plot(kde_rasters[[var]], main = paste("KDE Raster (", var, ")", sep = ""), col = rev(heat.colors(100)))
}

par(mfrow = c(1, 1)) 
```

```{r}


#Load KDE Raster
kde_raster <- rast("KDE_Food_Insecurity_Combined_5km.tif") 

#Apply threshold (keep only values > 0.016)
high_density_raster <- classify(kde_raster, matrix(c(-Inf, 0.016, 0, 0.016, Inf, 1), ncol = 3, byrow = TRUE))

#Save new high-density raster
writeRaster(high_density_raster, "High_Density_Food_Insecurity_Combined_5km.tif", overwrite = TRUE)

#Plot to check
plot(high_density_raster, main = "High-Density Food Insecurity (>0.016)", col = c("white", "red"))


#Load Ethiopia boundary
ethiopia_shape <- st_read("gadm41_ETH_0.shp")

#Load high-density raster
high_density_raster <- rast("High_Density_Food_Insecurity_Combined_5km.tif")

#Convert raster to dataframe for ggplot
raster_df <- as.data.frame(high_density_raster, xy = TRUE)
colnames(raster_df) <- c("Longitude", "Latitude", "Value")

#Keep only high-density areas (Value == 1) and remove NAs
raster_df <- raster_df[!is.na(raster_df$Value) & raster_df$Value == 1, ]

#Create map
ggplot() +
  geom_sf(data = ethiopia_shape, fill = "gray95", color = "black", size = 0.4) +
  geom_raster(data = raster_df, aes(x = Longitude, y = Latitude), fill = "red", alpha = 0.6) +
  labs(title = "High-Density Food Insecurity Areas", x = "Longitude", y = "Latitude") +
  theme_minimal()
```


```{r}

#Define KDE raster files (generated from previous contour density analysis)
kde_raster_files <- list(
  "Food_Insecurity_Combined" = "KDE_Food_Insecurity_Combined_5km_Final_Circular_Smooth.tif",
  "Soil_Moisture" = "KDE_Food_Insecurity_Soil_Moisture_5km_Final_Circular_Smooth.tif",
  "Yield" = "KDE_Food_Insecurity_Yield_5km_Final_Circular_Smooth.tif"
)

#Define threshold value for high-density areas
threshold_value <- 0.016

#Process each KDE raster and save new high-density rasters
high_density_rasters <- list()

for (var in names(kde_raster_files)) {
  file_path <- kde_raster_files[[var]]

  #Load KDE raster
  kde_raster <- rast(file_path)

  #Threshold raster: Keep only areas above 0.016
  high_density_raster <- classify(kde_raster, matrix(c(-Inf, threshold_value, 0, threshold_value, Inf, 1), ncol = 3, byrow = TRUE))

 to 5km resolution (if needed)
  high_density_raster <- resample(high_density_raster, kde_raster, method = "near")

  #Save new high-density raster
  output_filename <- paste0("High_Density_", var, "_5km.tif")
  writeRaster(high_density_raster, output_filename, overwrite = TRUE)

  #Store for reference
  high_density_rasters[[var]] <- high_density_raster
}

#Plot high-density areas
par(mfrow = c(2, 2))

for (var in names(high_density_rasters)) {
  plot(high_density_rasters[[var]], main = paste("High Density Areas (", var, ")", sep = ""), col = c("white", "black"))
}

par(mfrow = c(1, 1)) 
```

```{r}

#Modified function to calculate local variable importance
calculate_local_importance <- function(model, predictor_stack) {
  #Initialize output rasters for each category
  env_importance <- rast(predictor_stack[[1]])
  crop_importance <- rast(predictor_stack[[1]])
  socio_importance <- rast(predictor_stack[[1]])
  
  #Define variable groups
  env_vars <- c("Soil_Moisture")
  crop_vars <- c("Yield")
  socio_vars <- c("Market_Proximity", "Road_Proximity", "RWI")
  
  #Get variable importance from the random forest model
  var_imp <- importance(model)
  
  #Calculate normalized importance scores for each group
  group_importance <- list(
    env = mean(var_imp[env_vars, "MeanDecreaseAccuracy"]),
    crop = mean(var_imp[crop_vars, "MeanDecreaseAccuracy"]),
    socio = mean(var_imp[socio_vars, "MeanDecreaseAccuracy"])
  )
  
  #Calculate local importance for each cell
  values(env_importance) <- values(predictor_stack[[env_vars]]) * group_importance$env
  values(crop_importance) <- values(predictor_stack[[crop_vars]]) * group_importance$crop
  
  #For socioeconomic, take the mean of multiple variables
  socio_values <- mean(
    sapply(socio_vars, function(var) {
      values(predictor_stack[[var]])
    })
  ) * group_importance$socio
  values(socio_importance) <- socio_values
  
  #Normalize values
  stack <- c(env_importance, crop_importance, socio_importance)
  total <- sum(stack)
  
  env_importance <- env_importance / total
  crop_importance <- crop_importance / total
  socio_importance <- socio_importance / total
  
  return(list(
    environmental = env_importance,
    crop = crop_importance,
    socioeconomic = socio_importance
  ))
}

#Calculate local importance
local_importance <- calculate_local_importance(RFa_model, predictor_stack_2020_noirr_RCP26)

#Create RGB composite
rgb_importance <- c(local_importance$environmental, 
                   local_importance$crop,
                   local_importance$socioeconomic)
names(rgb_importance) <- c("Environmental", "Crop", "Socioeconomic")


#Plot the composite map with NA handling
tmap_mode("plot")

tm_shape(rgb_importance) +
  tm_rgb(r = "Environmental", 
         g = "Crop", 
         b = "Socioeconomic", 
         stretch.max = quantile(values(rgb_importance), 0.99, na.rm = TRUE)) +
  tm_shape(ethiopia_outline_2020_noirr_RCP26) +
  tm_borders() +
  tm_layout(title = "Variable Importance Map",
            legend.position = c("right", "bottom"),
            legend.title.size = 0.8,
            legend.text.size = 0.6) +
  tm_add_legend(type = "fill",
                col = c("red", "green", "blue"),
                labels = c("Environmental", "Crop", "Socioeconomic"),
                title = "Variable Groups")

#Alternative plotting method using base R if tmap still gives issues
if(!exists("plot_success")) {
  plotRGB(rgb_importance, 
          r = 1, g = 2, b = 3,
          stretch = "lin",
          main = "Variable Importance Map")
  
  #Add Ethiopia outline
  plot(vect(ethiopia_outline_2020_noirr_RCP26), add = TRUE)
  
  #Add legend
  legend("bottomright",
         legend = c("Environmental", "Crop", "Socioeconomic"),
         fill = c("red", "green", "blue"),
         title = "Variable Groups",
         cex = 0.8)
}

#Save the output
writeRaster(rgb_importance, "variable_importance_map.tif", overwrite = TRUE)

#Print variable importance scores for verification
print("Variable Importance Scores:")
print(importance(RFa_model))
```

```{r}


#Modified function to calculate local importance
calculate_local_importance <- function(model, predictor_stack) {
  #Initialize output rasters for each category
  env_importance <- rast(predictor_stack[[1]])
  crop_importance <- rast(predictor_stack[[1]])
  socio_importance <- rast(predictor_stack[[1]])
  
  #Define variable groups
  env_vars <- c("Soil_Moisture")
  crop_vars <- c("Yield")
  socio_vars <- c("Market_Proximity", "Road_Proximity", "RWI")
  
  #Get variable importance from the random forest model
  var_imp <- importance(model)
  
  #Calculate normalized importance scores for each group
  group_importance <- list(
    env = mean(var_imp[env_vars, "MeanDecreaseAccuracy"]),
    crop = mean(var_imp[crop_vars, "MeanDecreaseAccuracy"]),
    socio = mean(var_imp[socio_vars, "MeanDecreaseAccuracy"])
  )
  
  #Print group importance scores for verification
  print("Group Importance Scores:")
  print(group_importance)
  
  #Calculate local importance for each cell
  values(env_importance) <- scale(values(predictor_stack[[env_vars]])) * group_importance$env
  values(crop_importance) <- scale(values(predictor_stack[[crop_vars]])) * group_importance$crop
  
  #For socioeconomic, take the mean of scaled variables
  socio_scaled <- sapply(socio_vars, function(var) {
    scale(values(predictor_stack[[var]]))
  })
  socio_values <- rowMeans(socio_scaled, na.rm = TRUE) * group_importance$socio
  values(socio_importance) <- socio_values
  
  #Convert to data frame for ggplot
  env_df <- as.data.frame(env_importance, xy = TRUE)
  crop_df <- as.data.frame(crop_importance, xy = TRUE)
  socio_df <- as.data.frame(socio_importance, xy = TRUE)
  
  #Combine the data
  plot_data <- data.frame(
    x = env_df$x,
    y = env_df$y,
    env = env_df[[3]],
    crop = crop_df[[3]],
    socio = socio_df[[3]]
  )
  
  #Normalize values between 0 and 1
  plot_data$env <- (plot_data$env - min(plot_data$env, na.rm = TRUE)) / 
    (max(plot_data$env, na.rm = TRUE) - min(plot_data$env, na.rm = TRUE))
  plot_data$crop <- (plot_data$crop - min(plot_data$crop, na.rm = TRUE)) / 
    (max(plot_data$crop, na.rm = TRUE) - min(plot_data$crop, na.rm = TRUE))
  plot_data$socio <- (plot_data$socio - min(plot_data$socio, na.rm = TRUE)) / 
    (max(plot_data$socio, na.rm = TRUE) - min(plot_data$socio, na.rm = TRUE))
  
  return(plot_data)
}

#Calculate importance and create plot data
plot_data <- calculate_local_importance(RFa_model, predictor_stack_2020_noirr_RCP26)

#Convert Ethiopia outline to sf object if needed
ethiopia_sf <- st_as_sf(ethiopia_outline_2020_noirr_RCP26)

#Create the plot
ggplot() +
  geom_raster(data = plot_data, 
              aes(x = x, y = y, 
                  fill = rgb(env, crop, socio))) +
  geom_sf(data = ethiopia_sf, fill = NA, color = "black") +
  scale_fill_identity() +
  theme_minimal() +
  labs(title = "Variable Importance Map") +
  theme(plot.title = element_text(hjust = 0.5)) +
  #Add custom legend
  annotate("rect", xmin = max(plot_data$x, na.rm=TRUE) - 1, 
           xmax = max(plot_data$x, na.rm=TRUE),
           ymin = min(plot_data$y, na.rm=TRUE),
           ymax = min(plot_data$y, na.rm=TRUE) + 1,
           fill = "white", color = "black") +
  annotate("text", x = max(plot_data$x, na.rm=TRUE) - 0.5,
           y = c(min(plot_data$y, na.rm=TRUE) + 0.8,
                 min(plot_data$y, na.rm=TRUE) + 0.5,
                 min(plot_data$y, na.rm=TRUE) + 0.2),
           label = c("Environmental (Red)",
                    "Crop (Green)",
                    "Socioeconomic (Blue)"))

#Save the plot
ggsave("variable_importance_map.png", width = 10, height = 8)
```

```{r}


#Modified plotting code
ggplot() +
  #Base map layer
  geom_raster(data = plot_data, 
              aes(x = x, y = y, 
                  fill = rgb(env, crop, socio))) +
  #Country outline
  geom_sf(data = ethiopia_sf, fill = NA, color = "black", linewidth = 0.5) +
  
  #Improved scales and formatting
  scale_fill_identity() +
  scale_x_continuous(breaks = seq(34, 48, by = 2)) +
  scale_y_continuous(breaks = seq(4, 14, by = 2)) +
  
  #Enhanced layout
  coord_sf(expand = FALSE) +
  
  #Improved labels and title
  labs(
    title = "Variable Importance in Food Insecurity Prediction",
    subtitle = "Ethiopia, 2020",
    x = "Longitude",
    y = "Latitude"
  ) +
  
  #Custom theme
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    plot.margin = margin(1, 1, 1, 1, "cm")
  ) +
  
  #Simplified legend using annotate
  annotate("rect", xmin = 44, xmax = 44.5, 
           ymin = c(4, 5, 6), ymax = c(4.5, 5.5, 6.5),
           fill = c("red", "green", "blue")) +
  annotate("text", x = 45, y = c(4.25, 5.25, 6.25),
           label = c("Environmental", "Crop Yield", "Socioeconomic"),
           hjust = 0) +
  
  #Add title for the legend
  annotate("text", x = 44, y = 7,
           label = "Variable Importance",
           fontface = "bold") +
  
  #Add color mixing explanation
  annotate("text", x = 44, y = 13, 
           label = "Color Mixing Guide:\nPurple: Environmental + Socioeconomic\nYellow: Crop + Environmental\nCyan: Crop + Socioeconomic",
           size = 3, hjust = 0)

#Save the improved plot
ggsave("improved_variable_importance_map.png", 
       width = 12, height = 10, 
       dpi = 300)
```

```{r}



#Modified function to calculate local importance and return a data frame
calculate_local_importance <- function(model, predictor_stack) {
  #Define variable groups
  env_vars <- "Soil_Moisture"
  crop_vars <- "Yield"
  socio_vars <- c("Market_Proximity", "Road_Proximity", "RWI")
  
  #Get variable importance from the random forest model
  var_imp <- importance(model)
  
  #Calculate normalized importance scores for each group
  group_importance <- list(
    env = mean(var_imp[env_vars, "MeanDecreaseAccuracy"]),
    crop = mean(var_imp[crop_vars, "MeanDecreaseAccuracy"]),
    socio = mean(var_imp[socio_vars, "MeanDecreaseAccuracy"])
  )
  
  #Print group importance for verification
  print("Group importance scores:")
  print(group_importance)
  
  #Convert to data frame with coordinates
  env_df <- as.data.frame(predictor_stack[[env_vars]], xy = TRUE)
  crop_df <- as.data.frame(predictor_stack[[crop_vars]], xy = TRUE)
  
  #Handle socioeconomic variables
  socio_dfs <- lapply(socio_vars, function(var) {
    df <- as.data.frame(predictor_stack[[var]], xy = TRUE)
    df[,3] 
  })
  
  #Calculate mean of socioeconomic variables
  socio_matrix <- do.call(cbind, socio_dfs)
  socio_mean <- rowMeans(socio_matrix, na.rm = TRUE)
  
  #Create the final data frame
  plot_data <- data.frame(
    x = env_df[,1],
    y = env_df[,2],
    env = scale(env_df[,3]) * group_importance$env,
    crop = scale(crop_df[,3]) * group_importance$crop,
    socio = scale(socio_mean) * group_importance$socio
  )
  
  #Print dimensions for debugging
  print("Dimensions of plot_data:")
  print(dim(plot_data))
  
  #Normalize values between 0 and 1 for each variable
  plot_data$env <- (plot_data$env - min(plot_data$env, na.rm = TRUE)) / 
    (max(plot_data$env, na.rm = TRUE) - min(plot_data$env, na.rm = TRUE))
  plot_data$crop <- (plot_data$crop - min(plot_data$crop, na.rm = TRUE)) / 
    (max(plot_data$crop, na.rm = TRUE) - min(plot_data$crop, na.rm = TRUE))
  plot_data$socio <- (plot_data$socio - min(plot_data$socio, na.rm = TRUE)) / 
    (max(plot_data$socio, na.rm = TRUE) - min(plot_data$socio, na.rm = TRUE))
  
  #Long format for ggplot
  plot_data_long <- tidyr::pivot_longer(
    plot_data,
    cols = c(env, crop, socio),
    names_to = "variable",
    values_to = "value"
  )
  
  #Rename variables for clarity
  plot_data_long$variable <- factor(
    plot_data_long$variable,
    levels = c("env", "crop", "socio"),
    labels = c("Environmental", "Crop Yield", "Socio-Economic")
  )
  
  return(plot_data_long)
}

#Calculate importance and create plot data
plot_data_long <- calculate_local_importance(RFa_model, predictor_stack_2020_noirr_RCP26)

#Create the plot
ggplot() +
  #Add Ethiopia background
  geom_sf(data = ethiopia_sf, fill = "grey95", color = "black", linewidth = 0.5) +
  
  #Add contours for each variable
  geom_contour_filled(data = plot_data_long,
                      aes(x = x, y = y, z = value, fill = variable),
                      alpha = 0.5,
                      breaks = seq(0.6, 1, by = 0.1)) +
  
  #Customize colors
  scale_fill_manual(values = c("Environmental" = "#FF9999",
                              "Crop Yield" = "#99FF99",
                              "Socio-Economic" = "#9999FF")) +
  
  #Formatting
  labs(title = "High-Density Regions of Food Insecurity Factors in Ethiopia",
       subtitle = "Showing regions where variables have strongest influence",
       x = "Longitude",
       y = "Latitude",
       fill = "Variables") +
  
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    plot.margin = margin(1, 1, 1, 1, "cm")
  ) +
  coord_sf(expand = FALSE)

#Save the plot
ggsave("variable_importance_contours.png", 
       width = 12, height = 8, 
       dpi = 300)
```

```{r}

#Keep the same calculate_local_importance function up to the plotting code

#Create the plot with overlapping contours
ggplot() +
  #Add Ethiopia background
  geom_sf(data = ethiopia_sf, fill = "grey95", color = "black", linewidth = 0.5) +
  
  #Add separate contours for each variable with stat_contour
  stat_contour(data = filter(plot_data_long, variable == "Environmental"),
               aes(x = x, y = y, z = value),
               breaks = seq(0.3, 1, by = 0.15),
               fill = "#FF9999",
               geom = "polygon",
               alpha = 0.3) +
  
  stat_contour(data = filter(plot_data_long, variable == "Crop Yield"),
               aes(x = x, y = y, z = value),
               breaks = seq(0.3, 1, by = 0.15),
               fill = "#99FF99",
               geom = "polygon",
               alpha = 0.3) +
  
  stat_contour(data = filter(plot_data_long, variable == "Socio-Economic"),
               aes(x = x, y = y, z = value),
               breaks = seq(0.3, 1, by = 0.15),
               fill = "#9999FF",
               geom = "polygon",
               alpha = 0.3) +
  
  #Add contour lines
  stat_contour(data = plot_data_long,
               aes(x = x, y = y, z = value, color = variable),
               breaks = seq(0.3, 1, by = 0.15),
               size = 0.3,
               alpha = 0.5) +
  
  #Customize colors
  scale_fill_manual(values = c("Environmental" = "#FF9999",
                              "Crop Yield" = "#99FF99",
                              "Socio-Economic" = "#9999FF")) +
  scale_color_manual(values = c("Environmental" = "#FF0000",
                               "Crop Yield" = "#00FF00",
                               "Socio-Economic" = "#0000FF")) +
  
  #Formatting
  labs(title = "High-Density Regions of Food Insecurity Factors in Ethiopia",
       subtitle = "0.15 Level Contours",
       x = "Longitude",
       y = "Latitude",
       color = "Variables") +
  
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    plot.margin = margin(1, 1, 1, 1, "cm")
  ) +
  coord_sf(expand = FALSE) +
  guides(color = "none") #Remove the color legend since we have fill

#Save the plot
ggsave("variable_importance_contours_revised.png", 
       width = 12, height = 8, 
       dpi = 300)
```
```{r}


#Load the data
eth_popn <- raster("Population_2020_5km.tif")
fsi_map <- raster("FSI_2020_noirr_RCP26_irr.tif")

#Load and set CRS for Ethiopia boundary
eth_border <- st_read("gadm41_ETH_0.shp")
#Set the CRS to WGS 84 (EPSG:4326) which is typically used for GADM data
eth_border <- st_set_crs(eth_border, 4326)

#Transform Ethiopia border to match population raster's projection
eth_border <- st_transform(eth_border, crs(eth_popn))

#Ensure rasters are in the same projection (using compareCRS instead of direct comparison)
if (!compareCRS(crs(fsi_map), crs(eth_popn))) {
    fsi_map <- projectRaster(fsi_map, eth_popn)
}

#Mask both rasters to Ethiopia boundary
eth_extent <- st_bbox(eth_border)
eth_popn <- crop(eth_popn, eth_extent)
eth_popn <- mask(eth_popn, eth_border)
fsi_map <- crop(fsi_map, eth_extent)
fsi_map <- mask(fsi_map, eth_border)

#Create population at risk layer
#Since FSI map has 0 for food insecure areas, we need to invert it to get risk areas
risk_mask <- fsi_map
risk_mask[risk_mask == 1] <- 0  #food secure areas become 0
risk_mask[risk_mask == 0] <- 1  #food insecure areas become 1

#Calculate population at risk
pop_at_risk <- eth_popn * risk_mask
pop_at_risk[pop_at_risk == 0] <- NA

#Create the visualization
map <- tm_shape(pop_at_risk) +
    tm_raster(style = "fisher", 
              title = "Population at Risk\nof Food Insecurity",
              palette = "Reds",
              n = 5) +
    tm_shape(eth_border) +
    tm_borders(col = "black", lwd = 1.5) +
    tm_scale_bar(position = c("left", "bottom")) +
    tm_compass(position = c("right", "top")) +
    tm_layout(frame = FALSE,
              legend.outside = TRUE,
              legend.title.size = 1,
              main.title = "Ethiopia: Population at Risk of Food Insecurity (2020)",
              main.title.size = 1)

#Save the map
tmap_save(map, filename = "ethiopia_food_insecurity_risk.png")

#Calculate total population at risk
total_pop <- cellStats(eth_popn, 'sum')
total_at_risk <- cellStats(pop_at_risk, 'sum', na.rm = TRUE)
risk_percentage <- (total_at_risk/total_pop) * 100

print(paste0("Total population: ", format(total_pop, big.mark=",")))
print(paste0("Population at risk: ", format(total_at_risk, big.mark=",")))
print(paste0("Percentage at risk: ", round(risk_percentage, 1), "%"))
```
```{r}


#Get variable importance from existing model
var_imp <- importance(RFa_model)
var_imp_df <- as.data.frame(var_imp)
var_imp_df$Variable <- rownames(var_imp_df)

#Calculate percentage contribution
total_importance <- sum(var_imp_df$MeanDecreaseAccuracy)
var_imp_df$Contribution <- (var_imp_df$MeanDecreaseAccuracy / total_importance) * 100

#Create importance plot
imp_plot <- ggplot(var_imp_df, aes(x = reorder(Variable, MeanDecreaseAccuracy), 
                                  y = MeanDecreaseAccuracy)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  theme_minimal() +
  labs(x = "Variables",
       y = "Mean Decrease in Accuracy",
       title = "Variable Importance in Food Insecurity Prediction") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 12))

#Save the importance plot
ggsave("variable_importance.png", imp_plot, width = 10, height = 6)

#Create contribution percentage plot
contrib_plot <- ggplot(var_imp_df, aes(x = reorder(Variable, Contribution), 
                                      y = Contribution)) +
  geom_bar(stat = "identity", fill = "darkred") +
  coord_flip() +
  theme_minimal() +
  labs(x = "Variables",
       y = "Contribution to Model (%)",
       title = "Relative Contribution of Variables to Food Insecurity Prediction") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 12))

#Save the contribution plot
ggsave("variable_contribution.png", contrib_plot, width = 10, height = 6)

#Create summary table
summary_table <- var_imp_df[order(-var_imp_df$MeanDecreaseAccuracy), 
                           c("Variable", "MeanDecreaseAccuracy", "Contribution")]
colnames(summary_table) <- c("Variable", "Importance Score", "Contribution (%)")

#Print formatted summary
print("\nVariable Importance Summary:")
print(summary_table, digits = 3)

#Get top predictors
top_predictors <- rownames(var_imp)[order(var_imp[,3], decreasing = TRUE)[1:3]]
print(paste("\nTop 3 most important predictors:", paste(top_predictors, collapse = ", ")))

#Print detailed analysis of top predictors
print("\nDetailed Analysis of Top Predictors:")
top_summary <- summary_table[summary_table$Variable %in% top_predictors,]
for(i in 1:nrow(top_summary)) {
    print(paste0(
        top_summary$Variable[i], ":\n",
        "  Importance Score: ", round(top_summary$`Importance Score`[i], 3), "\n",
        "  Contribution: ", round(top_summary$`Contribution (%)`[i], 1), "%"
    ))
}
```

```{r}


#Create dataframe from your results
var_imp_df <- data.frame(
  Variable = c("Soil_Moisture", "Yield", "Market_Proximity", "Elevation", "RWI", "Road_Proximity", "Population"),
  Importance_Score = c(69.52703, 47.65100, 36.40774, 35.90980, 32.98122, 31.86048, 31.56875),
  Contribution = c(24.31814, 16.66666, 12.73416, 12.56000, 11.53569, 11.14369, 11.04165)
)

#Create grouped dataframe
grouped_imp_df <- data.frame(
  Variable = c("Soil_Moisture", "Yield", "Socio-economic", "Elevation", "Population"),
  Importance_Score = c(
    69.52703,  #Soil Moisture
    47.65100,  #Yield
    sum(c(36.40774, 32.98122, 31.86048)),  #Market_Proximity + RWI + Road_Proximity
    35.90980,  #Elevation
    31.56875   #Population
  )
)

#Calculate new contribution percentages
grouped_imp_df$Contribution <- (grouped_imp_df$Importance_Score / sum(grouped_imp_df$Importance_Score)) * 100

#Create importance plot for grouped variables
grouped_plot <- ggplot(grouped_imp_df, 
                      aes(x = reorder(Variable, Importance_Score), 
                          y = Importance_Score)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  theme_minimal() +
  labs(x = "Variables",
       y = "Importance Score",
       title = "Variable Importance in Food Insecurity Prediction\n(Socio-economic Factors Grouped)") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 12))

#Save the grouped plot
ggsave("grouped_variable_importance.png", grouped_plot, width = 10, height = 6)

#Create contribution plot for grouped variables
grouped_contrib_plot <- ggplot(grouped_imp_df, 
                             aes(x = reorder(Variable, Contribution), 
                                 y = Contribution)) +
  geom_bar(stat = "identity", fill = "darkred") +
  coord_flip() +
  theme_minimal() +
  labs(x = "Variables",
       y = "Contribution to Model (%)",
       title = "Relative Contribution of Variables to Food Insecurity Prediction\n(Socio-economic Factors Grouped)") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 12))

#Save the grouped contribution plot
ggsave("grouped_variable_contribution.png", grouped_contrib_plot, width = 10, height = 6)

#Print summary of grouped variables
print("\nGrouped Variable Importance Summary:")
grouped_summary <- grouped_imp_df[order(-grouped_imp_df$Importance_Score), 
                                c("Variable", "Importance_Score", "Contribution")]
colnames(grouped_summary) <- c("Variable", "Importance Score", "Contribution (%)")
print(grouped_summary, digits = 3)

#Print detailed analysis of socio-economic components
socio_economic_components <- data.frame(
  Component = c("Market Proximity", "RWI", "Road Proximity"),
  Score = c(36.40774, 32.98122, 31.86048),
  Contribution = c(12.73416, 11.53569, 11.14369)
)

print("\nSocio-economic Components Breakdown:")
print(socio_economic_components, digits = 3)

#Calculate total socio-economic contribution
total_socio_economic <- sum(socio_economic_components$Score)
total_contribution <- sum(socio_economic_components$Contribution)

print(paste("\nTotal Socio-economic Importance Score:", round(total_socio_economic, 2)))
print(paste("Total Socio-economic Contribution:", round(total_contribution, 2), "%"))
```

```{r}

#Load predictor rasters
soil_moisture <- raster("CLM45_RPC_26_Weighted_Average_Soil_Moisture_5km_2020 copy.tif")
yield <- raster("Ethiopia_wheat_RCP26_noirrigation_5km_2020 copy.tif")
market_prox <- raster("Market_Proximity_2020_5km.tif")
rwi <- raster("RWI_2020_5km.tif")
road_prox <- raster("Road_Proximity_2020_5km.tif")

#Load and set CRS for Ethiopia boundary
eth_border <- st_read("gadm41_ETH_0.shp")
eth_border <- st_set_crs(eth_border, 4326)
eth_border <- st_transform(eth_border, crs(soil_moisture))

#Print CRS information for verification
print("Soil Moisture CRS:")
print(crs(soil_moisture))
print("Ethiopia Border CRS:")
print(st_crs(eth_border))

#Ensure all rasters have the same extent and resolution
yield <- resample(yield, soil_moisture)
market_prox <- resample(market_prox, soil_moisture)
rwi <- resample(rwi, soil_moisture)
road_prox <- resample(road_prox, soil_moisture)

#Calculate combined socio-economic score
#First normalize each component to 0-1 scale
market_norm <- (market_prox - minValue(market_prox)) / (maxValue(market_prox) - minValue(market_prox))
rwi_norm <- (rwi - minValue(rwi)) / (maxValue(rwi) - minValue(rwi))
road_norm <- (road_prox - minValue(road_prox)) / (maxValue(road_prox) - minValue(road_prox))

#Weight the socio-economic components based on their relative importance
socio_economic <- (market_norm * 36.40774 + 
                   rwi_norm * 32.98122 + 
                   road_norm * 31.86048) / 101.24944

#Normalize soil moisture and yield
soil_moisture_norm <- (soil_moisture - minValue(soil_moisture)) / (maxValue(soil_moisture) - minValue(soil_moisture))
yield_norm <- (yield - minValue(yield)) / (maxValue(yield) - minValue(yield))

#Create dominant predictor raster
soil_moisture_weighted <- soil_moisture_norm * 69.52703
yield_weighted <- yield_norm * 47.65100
socio_economic_weighted <- socio_economic * 101.24944

#Stack the weighted predictors
predictor_stack <- stack(soil_moisture_weighted, yield_weighted, socio_economic_weighted)
names(predictor_stack) <- c("Soil Moisture", "Yield", "Socio-economic")

#Find which predictor has highest value at each pixel
dominant_predictor <- which.max(predictor_stack)

#Create a color-coded map
dominant_predictor <- ratify(dominant_predictor)
rat <- levels(dominant_predictor)[[1]]
rat$predictor <- c("Soil Moisture", "Yield", "Socio-economic")
levels(dominant_predictor) <- rat

#Create the map with updated tmap v4 syntax and improved colors
ethiopia_map <- tm_shape(dominant_predictor) +
    tm_raster(col.scale = tm_scale_categorical(values = c("#4575B4", "#74C476", "#D73027")), \
              col.legend = tm_legend(title = "Dominant Predictor of\nFood Insecurity")) +
    tm_shape(eth_border) +
    tm_borders(col = "black", lwd = 1.5) +
    tm_scalebar(position = c("left", "bottom")) +
    tm_compass(position = c("right", "top")) +
    tm_title("Dominant Predictors of Food Insecurity in Ethiopia") +
    tm_layout(frame = FALSE,
              legend.outside = TRUE,
              legend.position = c("right", "center"))

#Save the map
tmap_save(ethiopia_map, filename = "dominant_predictors_map.png", width = 10, height = 8)

#Calculate area percentages using cell counts instead of area
#Get frequency of each predictor class
freq_table <- freq(dominant_predictor)

#Calculate percentages
total_cells <- sum(freq_table[,2], na.rm = TRUE)
percentages <- (freq_table[,2] / total_cells) * 100


#Print debug information
print("Frequency table:")
print(freq_table)
print("\nRat table:")
print(rat)

#Create data frame with results, matching the frequency table values with predictor names
results_df <- data.frame(
    Value = freq_table[,1],
    Cells = freq_table[,2]
)

#Add predictor names based on the values
results_df$Predictor <- rat$predictor[results_df$Value]

#Remove NA rows if any
results_df <- results_df[!is.na(results_df$Value), ]

#Calculate percentages
total_cells <- sum(results_df$Cells, na.rm = TRUE)
results_df$Percentage <- (results_df$Cells / total_cells) * 100

#Print results
print("\nPercentage of area dominated by each predictor:")
for(i in 1:nrow(results_df)) {
    print(paste(results_df$Predictor[i], ":", 
                round(results_df$Percentage[i], 2), "%",
                "(", format(results_df$Cells[i], big.mark=","), "cells )"))
}

#Create pie chart


pie_chart <- ggplot(results_df, aes(x="", y=Percentage, fill=Predictor)) +
    geom_bar(stat="identity", width=1) +
    coord_polar("y", start=0) +
    scale_fill_manual(values=c("#4575B4", "#74C476", "#D73027")) +
    theme_void() +
    labs(title="Distribution of Dominant Predictors",
         fill="Predictor") +
    theme(plot.title = element_text(hjust=0.5))

#Save the pie chart
ggsave("predictor_distribution_pie.png", pie_chart, width=8, height=6)
```

```{r}


#We already have our weighted predictors:
#soil_moisture_weighted, yield_weighted, socio_economic_weighted

#Create threshold values for each predictor (e.g., top 75% of values)
soil_threshold <- quantile(soil_moisture_weighted, 0.75, na.rm=TRUE)
yield_threshold <- quantile(yield_weighted, 0.75, na.rm=TRUE)
socio_threshold <- quantile(socio_economic_weighted, 0.75, na.rm=TRUE)

#Create binary layers for each predictor
soil_vuln <- soil_moisture_weighted > soil_threshold
yield_vuln <- yield_weighted > yield_threshold
socio_vuln <- socio_economic_weighted > socio_threshold

#Print the unique values in our vulnerability raster to see what combinations exist
print("Unique vulnerability values:")
print(unique(vulnerability[]))

#Create comprehensive labels and colors for all possible combinations (0-7)
vulnerability_colors <- c(
    "#FFFFFF",  #White for no vulnerability (0)
    "#FF9999",  #Light red for Environmental (1)
    "#99B3FF",  #Light blue for Crop (2)
    "#CC79A7",  #Purple for Environmental + Crop (3)
    "#FFFF99",  #Light yellow for Socioeconomic (4)
    "#FF7F0E",  #Orange for Environmental + Socioeconomic (5)
    "#2CA02C",  #Green for Crop + Socioeconomic (6)
    "#808080"   #Grey for Triple vulnerability (7)
)

vulnerability_labels <- c(
    "No Vulnerability",
    "Environmental Vulnerability",
    "Crop Vulnerability",
    "Environmental + Crop",
    "Socioeconomic Vulnerability",
    "Environmental + Socioeconomic",
    "Crop + Socioeconomic",
    "Triple Vulnerability"
)

#Create the map with updated tmap v4 syntax
vulnerability_map <- tm_shape(vulnerability) +
    tm_raster(col.scale = tm_scale_categorical(values = vulnerability_colors,
                                              labels = vulnerability_labels),
              col.legend = tm_legend(title = "Vulnerability Types")) +
    tm_shape(eth_border) +
    tm_borders(col = "black", lwd = 1.5) +
    tm_scalebar(position = c("left", "bottom")) +
    tm_compass(position = c("right", "top")) +
    tm_title("Layered Vulnerability Map of Ethiopia") +
    tm_layout(frame = FALSE,
              legend.outside = TRUE,
              legend.position = c("right", "center"))

#Save the map
tmap_save(vulnerability_map, 
          filename = "ethiopia_vulnerability_layers.png", 
          width = 10, 
          height = 8)

#Calculate area percentages for each vulnerability type
vuln_freq <- freq(vulnerability)
print("\nFrequency table:")
print(vuln_freq)

#Create summary table with proper indexing
summary_df <- data.frame(
    Value = vuln_freq[,1],
    Cells = vuln_freq[,2]
)
summary_df$Vulnerability <- vulnerability_labels[summary_df$Value + 1]  #Add 1 because R indexing starts at 1
summary_df$Percentage <- (summary_df$Cells / sum(summary_df$Cells, na.rm=TRUE)) * 100

#Remove NA rows if any
summary_df <- summary_df[!is.na(summary_df$Value), ]

#Print sorted summary
print("\nVulnerability Type Distribution:")
sorted_summary <- summary_df[order(-summary_df$Percentage), ]
for(i in 1:nrow(sorted_summary)) {
    print(paste(sorted_summary$Vulnerability[i], ":", 
                round(sorted_summary$Percentage[i], 2), "%",
                "(", format(sorted_summary$Cells[i], big.mark=","), "cells )"))
}

#Create pie chart of vulnerability distribution

#Remove "No Vulnerability" category for the pie chart if desired
pie_data <- summary_df[summary_df$Value > 0, ]

pie_chart <- ggplot(pie_data, aes(x="", y=Percentage, fill=Vulnerability)) +
    geom_bar(stat="identity", width=1) +
    coord_polar("y", start=0) +
    scale_fill_manual(values=vulnerability_colors[-1]) +
    theme_void() +
    labs(title="Distribution of Vulnerability Types",
         fill="Vulnerability Type") +
    theme(plot.title = element_text(hjust=0.5))

#Save the pie chart
ggsave("vulnerability_distribution_pie.png", pie_chart, width=10, height=8)
```


```{r}


#We already have our weighted predictors:
#soil_moisture_weighted, yield_weighted, socio_economic_weighted

#Create threshold values for each predictor
#For soil_moisture and yield, we want the BOTTOM 25% (most vulnerable)
#For socio-economic, we keep top 25% as higher values indicate vulnerability
soil_threshold <- quantile(soil_moisture_weighted, 0.25, na.rm=TRUE)  
yield_threshold <- quantile(yield_weighted, 0.25, na.rm=TRUE)   
socio_threshold <- quantile(socio_economic_weighted, 0.75, na.rm=TRUE)

#Create binary layers for each predictor
#Inverse logic for soil_moisture and yield
soil_vuln <- soil_moisture_weighted < soil_threshold  
yield_vuln <- yield_weighted < yield_threshold  
socio_vuln <- socio_economic_weighted > socio_threshold

#Create vulnerability classes (1-7 representing different combinations)
vulnerability <- soil_vuln * 1 + yield_vuln * 2 + socio_vuln * 4

#Create a color palette for different vulnerability combinations
vulnerability_colors <- c(
    "#FFFFFF",  #White for no vulnerability (0)
    "#FF9999",  #Light red for Environmental (1)
    "#99B3FF",  #Light blue for Crop (2)
    "#CC79A7",  #Purple for Environmental + Crop (3)
    "#FFFF99",  #Light yellow for Socioeconomic (4)
    "#FF7F0E",  #Orange for Environmental + Socioeconomic (5)
    "#2CA02C",  #Green for Crop + Socioeconomic (6)
    "#808080"   #Grey for Triple vulnerability (7)
)

vulnerability_labels <- c(
    "No Vulnerability",
    "Environmental Vulnerability",
    "Crop Vulnerability",
    "Environmental + Crop",
    "Socioeconomic Vulnerability",
    "Environmental + Socioeconomic",
    "Crop + Socioeconomic",
    "Triple Vulnerability"
)

#Create the map with updated tmap v4 syntax
vulnerability_map <- tm_shape(vulnerability) +
    tm_raster(col.scale = tm_scale_categorical(values = vulnerability_colors,
                                              labels = vulnerability_labels),
              col.legend = tm_legend(title = "Vulnerability Types")) +
    tm_shape(eth_border) +
    tm_borders(col = "black", lwd = 1.5) +
    tm_scalebar(position = c("left", "bottom")) +
    tm_compass(position = c("right", "top")) +
    tm_title("Layered Vulnerability Map of Ethiopia\n(Low Soil Moisture & Low Yield)") +
    tm_layout(frame = FALSE,
              legend.outside = TRUE,
              legend.position = c("right", "center"))

#Save the map
tmap_save(vulnerability_map, 
          filename = "ethiopia_vulnerability_layers_inverted.png", 
          width = 10, 
          height = 8)

#Calculate area percentages
vuln_freq <- freq(vulnerability)
print("\nFrequency table:")
print(vuln_freq)

#Create summary table
summary_df <- data.frame(
    Value = vuln_freq[,1],
    Cells = vuln_freq[,2]
)
summary_df$Vulnerability <- vulnerability_labels[summary_df$Value + 1]  #Add 1 because R indexing starts at 1
summary_df$Percentage <- (summary_df$Cells / sum(summary_df$Cells, na.rm=TRUE)) * 100

#Remove NA rows if any
summary_df <- summary_df[!is.na(summary_df$Value), ]

#Print sorted summary
print("\nVulnerability Type Distribution:")
sorted_summary <- summary_df[order(-summary_df$Percentage), ]
for(i in 1:nrow(sorted_summary)) {
    print(paste(sorted_summary$Vulnerability[i], ":", 
                round(sorted_summary$Percentage[i], 2), "%",
                "(", format(sorted_summary$Cells[i], big.mark=","), "cells )"))
}
```

```{r}


#Create a new color palette with more distinct, professional colors
vulnerability_colors <- c(
    "#FFFFFF",  #White for no vulnerability
    "#FED976",  #Light orange for Environmental (single)
    "#74ADD1",  #Medium blue for Crop (single)
    "#9970AB",  #Purple for Environmental + Crop
    "#F0E442",  #Yellow for Socioeconomic (single)
    "#D73027",  #Red for Environmental + Socioeconomic
    "#4DAF4A",  #Green for Crop + Socioeconomic
    "#252525"   #Dark grey for Triple vulnerability
)

#Create the map with improved styling
vulnerability_map <- tm_shape(vulnerability) +
    tm_raster(col.scale = tm_scale_categorical(
        values = vulnerability_colors,
        labels = vulnerability_labels),
        col.legend = tm_legend(
            title = "Types of Food Insecurity Risk",
            format = "text")) +
    tm_shape(eth_border) +
    tm_borders(col = "black", lwd = 1.5) +
    tm_scalebar(
        position = c("left", "bottom"),
        breaks = c(0, 50, 100, 150),
        text.size = 0.8) +
    tm_compass(
        position = c("right", "top"),
        size = 2) +
    tm_title("Food Insecurity Risk Factors in Ethiopia\nBased on Environmental, Crop, and Socioeconomic Vulnerabilities") +
    tm_layout(
        frame = FALSE,
        legend.outside = TRUE,
        legend.position = c("right", "center"),
        legend.title.size = 1.2,
        legend.text.size = 0.8,
        title.size = 1.4,
        title.position = c("center", "top"),
        inner.margins = c(0.05, 0.05, 0.05, 0.05),
        legend.frame = TRUE,
        legend.bg.color = "white",
        legend.bg.alpha = 0.8,
        asp = NA) +
    tm_credits(
        text = "Source: Analysis based on soil moisture, crop yield, and socioeconomic data (2020)",
        position = c("left", "bottom"),
        size = 0.6)

#Save high-resolution map for publication
tmap_save(vulnerability_map, 
          filename = "ethiopia_vulnerability_publication.png",
          width = 10,
          height = 8,
          dpi = 300)

#Calculate and print summary statistics
vuln_freq <- freq(vulnerability)
total_cells <- sum(vuln_freq[,2], na.rm=TRUE)
percentages <- (vuln_freq[,2] / total_cells) * 100

#Create summary table
summary_df <- data.frame(
    Risk_Category = vulnerability_labels[vuln_freq[,1] + 1],
    Cells = vuln_freq[,2],
    Percentage = percentages
)

#Remove NA rows and sort by percentage
summary_df <- summary_df[!is.na(summary_df$Risk_Category), ]
summary_df <- summary_df[order(-summary_df$Percentage), ]

#Print summary
print("\nRisk Category Distribution:")
for(i in 1:nrow(summary_df)) {
    print(paste(summary_df$Risk_Category[i], ":", 
                round(summary_df$Percentage[i], 2), "%",
                "(", format(summary_df$Cells[i], big.mark=","), "cells )"))
}
```

```{r}


#Create a new color palette matching the example
vulnerability_colors <- c(
    "#FFFFFF",  #White for no vulnerability
    "#FFB6C1",  #Pink for Environmental
    "#A6CAF0",  #Light blue for Crop
    "#B19CD9",  #Light purple for Environmental + Crop
    "#FFFF99",  #Light yellow for Socioeconomic
    "#FFB366",  #Orange for Environmental + Socioeconomic
    "#90EE90",  #Light green for Crop + Socioeconomic
    "#808080"   #Grey for Triple vulnerability
)

#Create the map with improved styling
vulnerability_map <- tm_shape(vulnerability) +
    tm_raster(col.scale = tm_scale_categorical(
        values = vulnerability_colors,
        labels = vulnerability_labels),
        col.legend = tm_legend(
            title = "Types of Food Insecurity Risk",
            format = "text")) +
    tm_shape(eth_border) +
    tm_borders(col = "black", lwd = 1.5) +
    tm_scalebar(
        position = c("left", "bottom"),
        breaks = c(0, 50, 100, 150),
        text.size = 0.8) +
    tm_compass(
        position = c("right", "top"),
        size = 2) +
    tm_layout(
        frame = FALSE,
        legend.outside = FALSE, 
        legend.position = c("right", "bottom"),  
        legend.title.size = 0.8,
        legend.text.size = 0.6,
        title.size = 1,
        inner.margins = c(0.02, 0.02, 0.02, 0.02),
        legend.frame = TRUE,
        legend.bg.color = "white",
        legend.bg.alpha = 0.8,
        asp = NA) +
    tm_title("Layered Vulnerability Map of Ethiopia") +
    tm_credits(
        text = "Source: Analysis based on soil moisture, crop yield, and socioeconomic data (2020)",
        position = c("left", "bottom"),
        size = 0.6)

#Save high-resolution map for publication
tmap_save(vulnerability_map, 
          filename = "ethiopia_vulnerability_publication.png",
          width = 10,
          height = 8,
          dpi = 300)
```
```{r}


#Update color palette with darker yellow
vulnerability_colors <- c(
    "#FFFFFF",  #White for no vulnerability
    "#FFB6C1",  #Pink for Environmental
    "#A6CAF0",  #Light blue for Crop
    "#B19CD9",  #Light purple for Environmental + Crop
    "#FFE066",  #Darker yellow for Socioeconomic (changed from FFFF99)
    "#FFB366",  #Orange for Environmental + Socioeconomic
    "#90EE90",  #Light green for Crop + Socioeconomic
    "#808080"   #Grey for Triple vulnerability
)

#Create the map with switched compass and legend positions
vulnerability_map <- tm_shape(vulnerability) +
    tm_raster(col.scale = tm_scale_categorical(
        values = vulnerability_colors,
        labels = vulnerability_labels),
        col.legend = tm_legend(
            title = "Types of Food Insecurity Risk",
            format = "text")) +
    tm_shape(eth_border) +
    tm_borders(col = "black", lwd = 1.5) +
    tm_scalebar(
        position = c("left", "bottom"),
        breaks = c(0, 50, 100, 150),
        text.size = 0.8) +
    tm_compass(
        position = c("right", "bottom"),  
        size = 2) +
    tm_layout(
        frame = FALSE,
        legend.outside = FALSE,
        legend.position = c("right", "top"),  
        legend.title.size = 0.8,
        legend.text.size = 0.6,
        title.size = 1,
        inner.margins = c(0.02, 0.02, 0.02, 0.02),
        legend.frame = TRUE,
        legend.bg.color = "white",
        legend.bg.alpha = 0.8,
        asp = NA) +
    tm_title("Layered Vulnerability Map of Ethiopia") +
    tm_credits(
        text = "Source: Analysis based on soil moisture, crop yield, and socioeconomic data (2020)",
        position = c("left", "bottom"),
        size = 0.6)

#Save high-resolution map
tmap_save(vulnerability_map, 
          filename = "ethiopia_vulnerability_publication.png",
          width = 10,
          height = 8,
          dpi = 300)
```

FINAL MAP CODE
```{r}

#Update color palette with darker yellow
vulnerability_colors <- c(
    "#FFFFFF",  #White for no vulnerability
    "#FFB6C1",  #Pink for Environmental
    "#A6CAF0",  #Light blue for Crop
    "#B19CD9",  #Light purple for Environmental + Crop
    "#FFE066",  #Darker yellow for Socioeconomic (changed from FFFF99)
    "#FFB366",  #Orange for Environmental + Socioeconomic
    "#90EE90",  #Light green for Crop + Socioeconomic
    "#808080"   #Grey for Triple vulnerability
)

#Create the map with switched compass and legend positions
vulnerability_map <- tm_shape(vulnerability) +
    tm_raster(col.scale = tm_scale_categorical(
        values = vulnerability_colors,
        labels = vulnerability_labels),
        col.legend = tm_legend(
            title = "Types of Food Insecurity Risk",
            format = "text")) +
    tm_shape(eth_border) +
    tm_borders(col = "black", lwd = 1.5) +
    tm_scalebar(
        position = c("left", "bottom"),
        breaks = c(0, 50, 100, 150),
        text.size = 0.8) +
    tm_compass(
        position = c("right", "bottom"),  
        size = 2) +
    tm_layout(
        frame = FALSE,
        legend.outside = FALSE,
        legend.position = c("right", "top"),  
        legend.title.size = 0.8,
        legend.text.size = 0.6,
        title.size = 1,
        inner.margins = c(0.02, 0.02, 0.02, 0.02),
        legend.frame = TRUE,
        legend.bg.color = "white",
        legend.bg.alpha = 0.8,
        asp = NA) +
    tm_title("Layered Vulnerability Map of Ethiopia")

#Save high-resolution map
tmap_save(vulnerability_map, 
          filename = "ethiopia_vulnerability_publication1.png",
          width = 10,
          height = 8,
          dpi = 300)
```



```{r}

#Create a function to generate circle data
generate_circle <- function(center_x, center_y, radius, points=100) {
  theta <- seq(0, 2*pi, length.out=points)
  data.frame(
    x = center_x + radius*cos(theta),
    y = center_y + radius*sin(theta)
  )
}

#Generate circle data
environmental_circle <- generate_circle(0, 0.2, 1)
crop_circle <- generate_circle(-0.8, -0.6, 1)
socioeconomic_circle <- generate_circle(0.8, -0.6, 1)

#Create the plot
severity_paradigm <- ggplot() +
  #Add circles
  geom_polygon(data=environmental_circle, aes(x=x, y=y), fill="#FFB6C1", alpha=0.5) +
  geom_polygon(data=crop_circle, aes(x=x, y=y), fill="#A6CAF0", alpha=0.5) +
  geom_polygon(data=socioeconomic_circle, aes(x=x, y=y), fill="#FFE066", alpha=0.5) +
  
  #Add labels for main areas
  annotate("text", x=0, y=0.8, label="Environmental\nVulnerability", size=4) +
  annotate("text", x=-0.8, y=-1.2, label="Crop\nVulnerability", size=4) +
  annotate("text", x=0.8, y=-1.2, label="Socioeconomic\nVulnerability", size=4) +
  
  #Add labels for overlapping areas
  annotate("text", x=-0.4, y=-0.2, label="Environmental\n+ Crop", size=3) +
  annotate("text", x=0.4, y=-0.2, label="Environmental\n+ Socioeconomic", size=3) +
  annotate("text", x=0, y=-0.8, label="Crop +\nSocioeconomic", size=3) +
  annotate("text", x=0, y=-0.4, label="Triple\nVulnerability", size=3) +
  
  #Add title
  ggtitle("Severity Paradigm") +
  
  #Customize theme
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  #Set aspect ratio and limits
  coord_fixed(xlim = c(-2, 2), ylim = c(-2, 2))

#Add a legend for single, double, and triple vulnerability
legend_data <- data.frame(
  x = rep(1.5, 3),
  y = c(1.5, 1.2, 0.9),
  label = c("Single layer vulnerability", 
            "Double layer vulnerability",
            "Triple layer vulnerability")
)

severity_paradigm <- severity_paradigm +
  geom_text(data = legend_data, aes(x = x, y = y, label = label),
            hjust = 0, size = 3) +
  geom_segment(data = legend_data,
               aes(x = 1.3, xend = 1.4,
                   y = y, yend = y))

#Save the plot
ggsave("severity_paradigm.png", severity_paradigm, 
       width = 10, height = 8, dpi = 300)
```

```{r}

#Create a function to generate circle data
generate_circle <- function(center_x, center_y, radius, points=100) {
  theta <- seq(0, 2*pi, length.out=points)
  data.frame(
    x = center_x + radius*cos(theta),
    y = center_y + radius*sin(theta)
  )
}

#Define exact colors from the map
map_colors <- list(
    env = "#FFB6C1",      #Environmental (pink)
    crop = "#A6CAF0",     #Crop (light blue)
    socio = "#FFE066",    #Socioeconomic (yellow)
    env_crop = "#B19CD9", #Environmental + Crop (purple)
    env_socio = "#FFB366",#Environmental + Socioeconomic (orange)
    crop_socio = "#90EE90",#Crop + Socioeconomic (green)
    triple = "#808080"    #Triple vulnerability (grey)
)

#Generate circle data
environmental_circle <- generate_circle(0, 0.2, 1)
crop_circle <- generate_circle(-0.8, -0.6, 1)
socioeconomic_circle <- generate_circle(0.8, -0.6, 1)

#Create the plot with exact colors
severity_paradigm <- ggplot() +
  #Add circles with exact colors from map
  geom_polygon(data=environmental_circle, aes(x=x, y=y), 
               fill=map_colors$env, alpha=1) +
  geom_polygon(data=crop_circle, aes(x=x, y=y), 
               fill=map_colors$crop, alpha=1) +
  geom_polygon(data=socioeconomic_circle, aes(x=x, y=y), 
               fill=map_colors$socio, alpha=1) +
  
  #Add borders
  geom_polygon(data=environmental_circle, aes(x=x, y=y), 
               fill=NA, color="black", size=0.5) +
  geom_polygon(data=crop_circle, aes(x=x, y=y), 
               fill=NA, color="black", size=0.5) +
  geom_polygon(data=socioeconomic_circle, aes(x=x, y=y), 
               fill=NA, color="black", size=0.5) +
  
  #Add labels for main areas
  annotate("text", x=0, y=0.8, label="Environmental\nVulnerability", size=4) +
  annotate("text", x=-0.8, y=-1.2, label="Crop\nVulnerability", size=4) +
  annotate("text", x=0.8, y=-1.2, label="Socioeconomic\nVulnerability", size=4) +
  
  #Add labels for overlapping areas with colors matching the overlaps
  annotate("text", x=-0.4, y=-0.2, label="Environmental\n+ Crop", 
           size=3, color=map_colors$env_crop) +
  annotate("text", x=0.4, y=-0.2, label="Environmental\n+ Socioeconomic", 
           size=3, color=map_colors$env_socio) +
  annotate("text", x=0, y=-0.8, label="Crop +\nSocioeconomic", 
           size=3, color=map_colors$crop_socio) +
  annotate("text", x=0, y=-0.4, label="Triple\nVulnerability", 
           size=3, color=map_colors$triple) +
  
  #Add title
  ggtitle("Severity Paradigm") +
  
  #Customize theme
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  #Set aspect ratio and limits
  coord_fixed(xlim = c(-2, 2), ylim = c(-2, 2))

#Add legend for vulnerability layers
legend_data <- data.frame(
  x = rep(1.5, 3),
  y = c(1.5, 1.2, 0.9),
  label = c("Single layer vulnerability", 
            "Double layer vulnerability",
            "Triple layer vulnerability")
)

severity_paradigm <- severity_paradigm +
  geom_text(data = legend_data, aes(x = x, y = y, label = label),
            hjust = 0, size = 3) +
  geom_segment(data = legend_data,
               aes(x = 1.3, xend = 1.4,
                   y = y, yend = y))

#Save the plot with white background
ggsave("severity_paradigm_exact_colors.png", severity_paradigm, 
       width = 10, height = 8, dpi = 300,
       bg = "white")
```


```{r}

#Define exact colors as used in the map
map_colors <- list(
    env = "#FFB6C1",    #Environmental (pink)
    crop = "#A6CAF0",   #Crop (blue)
    socio = "#FFE066",  #Socioeconomic (yellow)
    env_crop = "#B19CD9",      #Environmental + Crop (purple)
    env_socio = "#FFB366",     #Environmental + Socioeconomic (orange)
    crop_socio = "#90EE90",    #Crop + Socioeconomic (green)
    triple = "#808080"         #Triple vulnerability (grey)
)

#Create circle coordinates
circle_points <- 100
theta <- seq(0, 2*pi, length.out = circle_points)

#Create three circles
create_circle <- function(center_x, center_y, r = 1) {
    data.frame(
        x = center_x + r * cos(theta),
        y = center_y + r * sin(theta)
    )
}

#Position circles
env_circle <- create_circle(0, 1.2)
crop_circle <- create_circle(-1, -0.6)
socio_circle <- create_circle(1, -0.6)

#Create the plot
severity_paradigm <- ggplot() +
    #Base circles
    geom_polygon(data = env_circle, aes(x, y), fill = map_colors$env) +
    geom_polygon(data = crop_circle, aes(x, y), fill = map_colors$crop) +
    geom_polygon(data = socio_circle, aes(x, y), fill = map_colors$socio) +
    
    #Add labels for main areas
    annotate("text", x = 0, y = 1.2, label = "Environmental\nVulnerability", size = 4) +
    annotate("text", x = -1, y = -1, label = "Crop\nVulnerability", size = 4) +
    annotate("text", x = 1, y = -1, label = "Socioeconomic\nVulnerability", size = 4) +
    
    #Add labels for overlapping areas with exact colors
    annotate("text", x = -0.5, y = 0.3, label = "Environmental\n+ Crop", 
             size = 3, color = map_colors$env_crop) +
    annotate("text", x = 0.5, y = 0.3, label = "Environmental\n+ Socioeconomic", 
             size = 3, color = map_colors$env_socio) +
    annotate("text", x = 0, y = -0.8, label = "Crop +\nSocioeconomic", 
             size = 3, color = map_colors$crop_socio) +
    annotate("text", x = 0, y = 0, label = "Triple\nVulnerability", 
             size = 3, color = map_colors$triple) +
    
    #Add title and customize theme
    ggtitle("Severity Paradigm") +
    theme_void() +
    theme(
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        plot.margin = margin(20, 20, 20, 20)
    ) +
    
    #Fix aspect ratio and set limits
    coord_fixed(xlim = c(-2, 2), ylim = c(-2, 2))

#Add legend for vulnerability layers
legend_df <- data.frame(
    x = 1.5,
    y = c(1.8, 1.5, 1.2),
    label = c("Single layer vulnerability",
              "Double layer vulnerability",
              "Triple layer vulnerability")
)

severity_paradigm <- severity_paradigm +
    geom_segment(data = legend_df,
                aes(x = 1.3, xend = 1.4, y = y, yend = y),
                color = "black") +
    geom_text(data = legend_df,
              aes(x = x, y = y, label = label),
              hjust = 0, size = 3)

#Save the plot with white background
ggsave("severity_paradigm_fixed.png", severity_paradigm,
       width = 10, height = 8, dpi = 300,
       bg = "white")
```

```{r}

#Create a euler diagram with specified overlaps
#The numbers represent the size of each set and their intersections
fit <- euler(c("Environmental" = 20,
               "Crop" = 20,
               "Socioeconomic" = 20,
               "Environmental&Crop" = 8,
               "Environmental&Socioeconomic" = 8,
               "Crop&Socioeconomic" = 8,
               "Environmental&Crop&Socioeconomic" = 4))

#Plot with exact colors from your map
plot(fit,
     fills = c("#FFB6C1", "#A6CAF0", "#FFE066"),  #Light pink, Light blue, Light yellow
     edges = TRUE,
     quantities = FALSE,
     labels = c("Environmental\nVulnerability", 
                "Crop\nVulnerability", 
                "Socioeconomic\nVulnerability"),
     main = "Severity Paradigm",
     legend = list(
       labels = c("Single layer vulnerability",
                 "Double layer vulnerability",
                 "Triple layer vulnerability")
     ))

#Save the plot
dev.copy(png, "severity_paradigm_euler.png", 
         width = 800, height = 800, 
         res = 100)
dev.off()

#Create another version with adjusted transparency
plot(fit,
     fills = c("#FFB6C1", "#A6CAF0", "#FFE066"),
     edges = TRUE,
     quantities = FALSE,
     alpha = 0.7, 
     labels = c("Environmental\nVulnerability", 
                "Crop\nVulnerability", 
                "Socioeconomic\nVulnerability"),
     main = "Severity Paradigm")

#Save second version
dev.copy(png, "severity_paradigm_euler_transparent.png", 
         width = 800, height = 800, 
         res = 100)
dev.off()

#Display overlap statistics
print(fit)
```

```{r}

#Define exact colors from your map
colors <- c(
    "#FFB6C1",  #Environmental (pink)
    "#A6CAF0",  #Crop (light blue)
    "#FFE066"   #Socioeconomic (yellow)
)

#Create the Venn diagram
venn.plot <- draw.triple.venn(
    area1 = 100,
    area2 = 100,
    area3 = 100,
    n12 = 40,    #Overlap between Environmental and Crop
    n23 = 40,    #Overlap between Crop and Socioeconomic
    n13 = 40,    #Overlap between Environmental and Socioeconomic
    n123 = 20,   #Triple overlap
    category = c("Environmental\nVulnerability", 
                "Crop\nVulnerability", 
                "Socioeconomic\nVulnerability"),
    fill = colors,
    col = "black",  
    lwd = 2,        
    lty = "solid",    
    alpha = 0.7,   
    label.col = c("black", "black", "black"),
    cex = 1.5,      
    cat.cex = 1.5,    
    cat.col = c("black", "black", "black"),
    cat.dist = 0.08,  
    cat.pos = c(-20, 20, 270), 
    euler.d = TRUE,
    scaled = TRUE
)

#Add title
grid.text("Severity Paradigm", x = 0.5, y = 0.95, gp = gpar(fontsize = 20))

#Add legend
grid.text("Single layer vulnerability", x = 0.85, y = 0.7, gp = gpar(fontsize = 12))
grid.text("Double layer vulnerability", x = 0.85, y = 0.65, gp = gpar(fontsize = 12))
grid.text("Triple layer vulnerability", x = 0.85, y = 0.6, gp = gpar(fontsize = 12))

#Save with white background
png("severity_paradigm_final.png", 
    width = 3000, 
    height = 3000, 
    res = 300,
    bg = "white")
grid.draw(venn.plot)
dev.off()
```

```{r}

#Get Ethiopia country and admin1 (state) boundaries
ethiopia <- ne_countries(country = "Ethiopia", scale = "medium", returnclass = "sf")
ethiopia_states <- ne_states(country = "Ethiopia", returnclass = "sf")

#Create the map
ggplot() +
  #Add state boundaries
  geom_sf(data = ethiopia_states, 
          fill = "lightyellow", 
          color = "black") +
  #Add country outline
  geom_sf(data = ethiopia, 
          fill = NA, 
          color = "black") +
  #Add scale bar with correct location parameter
  annotation_scale(
    location = "bl",  
    width_hint = 0.5
  ) +
  #Customize the theme
  theme_minimal() +
  #Set the map extent
  coord_sf(xlim = c(33, 48), 
          ylim = c(3, 15)) +
  #Add title
  labs(title = "Ethiopia Administrative Regions")
```

```{r}

#Get Africa continent data
africa <- ne_countries(continent = "Africa", scale = "medium", returnclass = "sf")

#Create the map
ggplot() +
  #Add country boundaries
  geom_sf(data = africa, 
          fill = "bisque3", 
          color = "black") +
  #Customize the theme
  theme_minimal() +
  #Add title
  labs(title = "Africa") +
  #Remove unnecessary grid lines
  theme(panel.grid = element_blank())
```

```{r}

#Load the data
eth_popn <- raster("Population_2020_5km.tif")
fsi_map <- raster("FSI_2020_noirr_RCP26_irr.tif")

#Load Ethiopia zones (admin level 2)
eth_zones <- st_read("gadm41_ETH_2.shp")  
eth_zones <- st_set_crs(eth_zones, 4326)
eth_zones <- st_transform(eth_zones, crs(eth_popn))

#Ensure rasters are in the same projection
if (!compareCRS(crs(fsi_map), crs(eth_popn))) {
    fsi_map <- projectRaster(fsi_map, eth_popn)
}

#Create population at risk layer
risk_mask <- fsi_map
risk_mask[risk_mask == 1] <- 0
risk_mask[risk_mask == 0] <- 1
pop_at_risk <- eth_popn * risk_mask

#Calculate zonal statistics
calculate_zone_stats <- function(zone) {
    #Convert the geometry to SpatialPolygons
    zone_sp <- as(zone, "Spatial")
    
    #Mask the rasters with the zone boundary
    zone_mask <- mask(pop_at_risk, zone_sp)
    zone_pop <- mask(eth_popn, zone_sp)
    
    total_pop <- cellStats(zone_pop, 'sum', na.rm = TRUE)
    pop_risk <- cellStats(zone_mask, 'sum', na.rm = TRUE)
    
    return(c(total_pop, pop_risk))
}

#Apply calculation to each zone
zone_stats <- eth_zones %>%
    mutate(
        stats = map(geometry, calculate_zone_stats),
        total_pop = map_dbl(stats, ~.[1]),
        pop_at_risk = map_dbl(stats, ~.[2]),
        risk_percentage = (pop_at_risk / total_pop) * 100
    )

#Create the visualization
map <- tm_shape(zone_stats) +
    tm_fill(
        col = "risk_percentage",
        style = "fisher",
        title = "% Population at Risk\nof Food Insecurity",
        palette = "Reds",
        n = 5
    ) +
    tm_borders(col = "black", lwd = 0.5) +
    tm_scale_bar(position = c("left", "bottom")) +
    tm_compass(position = c("right", "top")) +
    tm_layout(
        frame = FALSE,
        legend.outside = TRUE,
        legend.title.size = 1,
        main.title = "Ethiopia: Population at Risk of Food Insecurity by Zone (2020)",
        main.title.size = 1
    )

#Save the map
tmap_save(map, filename = "ethiopia_food_insecurity_risk_by_zone.png")

#Print summary statistics
print("Summary Statistics by Zone:")
summary_stats <- zone_stats %>%
    arrange(desc(risk_percentage)) %>%
    select(NAME_2, total_pop, pop_at_risk, risk_percentage)

print(summary_stats)
```
Final map edit:
```{r}

#Load zone shapefile
eth_zones <- st_read("gadm41_ETH_2.shp")

#Create template raster at 5km resolution
template_raster <- rast(extent(eth_zones), resolution = 0.05, crs = crs(eth_zones))

#Create individual vulnerability layers
env_raster <- rast(template_raster)
crop_raster <- rast(template_raster)
socio_raster <- rast(template_raster)

#Define circle parameters in geographic coordinates
env_center <- c(38, 9)   
crop_center <- c(37, 7)
socio_center <- c(39, 7)
radius <- 2  

#Function to create circular masks
create_circle_mask <- function(raster, center, radius) {
    xy <- xyFromCell(raster, 1:ncell(raster))
    dist <- sqrt((xy[,1] - center[1])^2 + (xy[,2] - center[2])^2)
    values(raster) <- as.integer(dist <= radius)
    return(raster)
}

#Create vulnerability layers
env_layer <- create_circle_mask(env_raster, env_center, radius)
crop_layer <- create_circle_mask(crop_raster, crop_center, radius)
socio_layer <- create_circle_mask(socio_raster, socio_center, radius)

#Combine layers to create vulnerability classification (0-7)
vulnerability <- env_layer * 1 + crop_layer * 2 + socio_layer * 4

#Define colors for each vulnerability class
vulnerability_colors <- c(
    "0" = "#FFFFFF",  #No vulnerability
    "1" = "#FFB6C1",  #Environmental only
    "2" = "#A6CAF0",  #Crop only
    "3" = "#B19CD9",  #Environmental + Crop
    "4" = "#FFE066",  #Socioeconomic only
    "5" = "#FFB366",  #Environmental + Socioeconomic
    "6" = "#90EE90",  #Crop + Socioeconomic
    "7" = "#808080"   #Triple vulnerability
)

#Calculate dominant vulnerability class for each zone
zonal_vulnerability <- terra::extract(vulnerability, vect(eth_zones), fun=modal)

#Add dominant vulnerability class to zones
eth_zones$dominant_vuln <- zonal_vulnerability[,2]

#Create the map
ggplot() +
    geom_sf(data = eth_zones, aes(fill = as.factor(dominant_vuln))) +
    scale_fill_manual(
        values = vulnerability_colors,
        name = "Dominant Vulnerability",
        labels = c("None", "Environmental", "Crop", "Env + Crop",
                  "Socioeconomic", "Env + Socio", "Crop + Socio", "Triple")
    ) +
    theme_minimal() +
    labs(title = "Dominant Vulnerability by Zone") +
    theme(
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        legend.position = "right"
    )

#Save the vulnerability raster
writeRaster(vulnerability, "vulnerability_classification_5km.tif", overwrite=TRUE)

#Save the plot
ggsave("vulnerability_by_zone.png", width = 12, height = 8, dpi = 300)

#Print summary statistics
vuln_summary <- eth_zones %>%
    group_by(dominant_vuln) %>%
    summarise(
        count = n(),
        percentage = n() / nrow(eth_zones) * 100
    )

print("Vulnerability distribution by zone:")
print(vuln_summary)
```
```{r}

#Create the plot as before
#[Your existing plot code remains the same up to the ggsave line]

#Instead of using ggsave, we'll create a raster version:

#First, create a blank raster with desired dimensions
raster_width <- 1000  
raster_height <- 800
r <- raster(ncols=raster_width, nrows=raster_height, 
            xmn=-2, xmx=2, ymn=-2, ymx=2,  
            crs="+proj=utm +zone=37 +datum=WGS84")  

#Convert ggplot to raster
#First save plot to a temporary png file
tmp_file <- tempfile(fileext = ".png")
ggsave(tmp_file, severity_paradigm, 
       width = 10, height = 8, units = "in", 
       dpi = 300, bg = "white")

#Read the png as a raster
r_plot <- raster(tmp_file)

#Set proper extent and projection if needed
extent(r_plot) <- extent(r)
crs(r_plot) <- crs(r)

#Save as GeoTIFF
writeRaster(r_plot, 
            filename="severity_paradigm.tif", 
            format="GTiff", 
            overwrite=TRUE)

#Clean up temporary file
file.remove(tmp_file)
```
```{r}

#Convert the vulnerability raster to a terra SpatRaster if it's not already
#If vulnerability is a raster package RasterLayer
vulnerability_terra <- rast(vulnerability)

#Create a reference raster with 5km resolution
reference_raster <- rast("Elevation_5km.tif")

#Ensure both rasters have the same CRS
crs(vulnerability_terra) <- crs(reference_raster)

#Resample the vulnerability raster to match the reference raster
vulnerability_5km <- resample(vulnerability_terra, reference_raster, method = "near")

#Load Ethiopia boundary
ethiopia_boundary <- vect("gadm41_ETH_2.shp")

#Mask to Ethiopia boundary
vulnerability_5km_masked <- mask(vulnerability_5km, ethiopia_boundary)

#Save the raster
writeRaster(vulnerability_5km_masked, 
            "ethiopia_vulnerability_5km.tif", 
            overwrite = TRUE)

#Verify the raster
print(vulnerability_5km_masked)
plot(vulnerability_5km_masked)
```

```{r}
#Load the vulnerability raster and zones
vulnerability_raster <- rast("ethiopia_vulnerability_5km.tif")
ethiopia_zones <- st_read("gadm41_ETH_2.shp")

#Define color mapping (matching the previous visualization)
color_map <- c(
    "0" = "#FFFFFF",   #White for no vulnerability
    "1" = "#FFB6C1",   #Pink for Environmental
    "2" = "#A6CAF0",   #Light blue for Crop
    "3" = "#B19CD9",   #Light purple for Environmental + Crop
    "4" = "#FFE066",   #Darker yellow for Socioeconomic
    "5" = "#FFB366",   #Orange for Environmental + Socioeconomic
    "6" = "#90EE90",   #Light green for Crop + Socioeconomic
    "7" = "#808080"    #Grey for Triple vulnerability
)

#Function to find the most frequent value in a raster for a given zone
find_dominant_vulnerability <- function(zone, raster) {
    #Crop and mask raster to the specific zone
    zone_raster <- mask(crop(raster, zone), zone)
    
    #Get frequency of values
    freq_table <- freq(zone_raster)
    
    #Find the value with the highest frequency (excluding NA)
    dominant_value <- freq_table$value[which.max(freq_table$count)]
    
    return(dominant_value)
}

#Apply the function to each zone
zone_results <- ethiopia_zones %>%
    rowwise() %>%
    mutate(
        dominant_vulnerability = find_dominant_vulnerability(vect(geometry), vulnerability_raster),
        dominant_color = color_map[as.character(dominant_vulnerability)]
    )

#Create a plot to visualize results

ggplot() +
    geom_sf(data = zone_results, 
            aes(fill = dominant_color)) +
    scale_fill_identity() +
    theme_minimal() +
    labs(title = "Dominant Vulnerability Type by Zone")

#Save the results
write_sf(zone_results, "ethiopia_zones_vulnerability.shp")

#Print summary
print(zone_results %>% 
          group_by(dominant_vulnerability) %>% 
          summarise(num_zones = n()))
```

By Zone excluding 'no vulnerability'
```{r}

#Load the vulnerability raster and zones
vulnerability_raster <- rast("ethiopia_vulnerability_5km.tif")
ethiopia_zones <- st_read("gadm41_ETH_2.shp")

#Define color mapping (matching the previous visualization)
color_map <- c(
    "1" = "#FFB6C1",   #Pink for Environmental
    "2" = "#A6CAF0",   #Light blue for Crop
    "3" = "#B19CD9",   #Light purple for Environmental + Crop
    "4" = "#FFE066",   #Darker yellow for Socioeconomic
    "5" = "#FFB366",   #Orange for Environmental + Socioeconomic
    "6" = "#90EE90",   #Light green for Crop + Socioeconomic
    "7" = "#808080"    #Grey for Triple vulnerability
)

#Function to find the most frequent value in a raster for a given zone, excluding 0
find_dominant_vulnerability <- function(zone, raster) {
    #Crop and mask raster to the specific zone
    zone_raster <- mask(crop(raster, zone), zone)
    
    #Get frequency of values, excluding 0
    freq_table <- freq(zone_raster)
    freq_table <- freq_table[freq_table$value != 0, ]
    
    #Find the value with the highest frequency 
    if(nrow(freq_table) > 0) {
        dominant_value <- freq_table$value[which.max(freq_table$count)]
    } else {
        dominant_value <- NA
    }
    
    return(dominant_value)
}

#Apply the function to each zone
zone_results <- ethiopia_zones %>%
    rowwise() %>%
    mutate(
        dominant_vulnerability = find_dominant_vulnerability(vect(geometry), vulnerability_raster),
        dominant_color = color_map[as.character(dominant_vulnerability)]
    )

#Create a plot to visualize results

ggplot() +
    geom_sf(data = zone_results, 
            aes(fill = dominant_color)) +
    scale_fill_identity() +
    theme_minimal() +
    labs(title = "Dominant Vulnerability Type by Zone\n(Excluding No Vulnerability)")

#Redefine color map
color_map <- c(
    "1" = "#FFB6C1",   #Pink for Environmental
    "2" = "#A6CAF0",   #Light blue for Crop
    "3" = "#B19CD9",   #Light purple for Environmental + Crop
    "4" = "#FFE066",   #Darker yellow for Socioeconomic
    "5" = "#FFB366",   #Orange for Environmental + Socioeconomic
    "6" = "#90EE90",   #Light green for Crop + Socioeconomic
    "7" = "#808080"    #Grey for Triple vulnerability
)

#Create the plot
vulnerability_plot <- ggplot() +
    geom_sf(data = zone_results, 
            aes(fill = dominant_color)) +
    scale_fill_identity() +
    theme_minimal() +
    labs(title = "Dominant Vulnerability Type by Zone\n(Excluding No Vulnerability)") +
    theme(
        plot.title = element_text(hjust = 0.5, size = 14),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank()
    )

#Save the plot
ggsave("dominant_vulnerability_by_zone.png", 
       plot = vulnerability_plot,
       width = 10, 
       height = 8, 
       dpi = 300,
       bg = "white")

#Save the results
write_sf(zone_results, "ethiopia_zones_vulnerability_excluding_zero.shp")

#Print summary
summary_table <- zone_results %>% 
    filter(!is.na(dominant_vulnerability)) %>%
    group_by(dominant_vulnerability) %>% 
    summarise(
        num_zones = n(),
        percentage = (n() / nrow(zone_results)) * 100
    )

print("Vulnerability Type Distribution:")
print(summary_table)


```

```{r}

#Load vulnerability raster and zones
vulnerability_raster <- rast("ethiopia_vulnerability_5km.tif")
ethiopia_zones <- st_read("gadm41_ETH_2.shp")

#Ensure CRS is consistent
ethiopia_zones <- st_set_crs(ethiopia_zones, 4326)
crs(vulnerability_raster) <- "EPSG:4326"

#Define color mapping
color_map <- c(
    "1" = "#FFB6C1",   #Pink for Environmental
    "2" = "#A6CAF0",   #Light blue for Crop
    "3" = "#B19CD9",   #Light purple for Environmental + Crop
    "4" = "#FFE066",   #Darker yellow for Socioeconomic
    "5" = "#FFB366",   #Orange for Environmental + Socioeconomic
    "6" = "#90EE90",   #Light green for Crop + Socioeconomic
    "7" = "#808080"    #Grey for Triple vulnerability
)

#Function to calculate vulnerability proportions for a zone
calculate_zone_vulnerability <- function(zone, raster) {
    #Crop and mask raster to the specific zone
    zone_raster <- mask(crop(raster, zone), zone)
    
    #Get frequency of values, excluding 0
    freq_table <- freq(zone_raster)
    freq_table <- freq_table[freq_table$value != 0, ]
    
    #Calculate proportions
    total_cells <- sum(freq_table$count)
    freq_table$proportion <- freq_table$count / total_cells
    
    #Convert to dataframe with consistent structure
    vulnerability_props <- data.frame(
        vulnerability = as.character(freq_table$value),
        proportion = freq_table$proportion
    )
    
    return(vulnerability_props)
}

#Calculate zone centroids
zone_centroids <- st_centroid(ethiopia_zones)

#Apply vulnerability calculation
zone_vulnerability_props <- ethiopia_zones %>%
    mutate(
        centroid_x = st_coordinates(zone_centroids)[,'X'],
        centroid_y = st_coordinates(zone_centroids)[,'Y']
    ) %>%
    rowwise() %>%
    mutate(
        vulnerability_breakdown = list(
            calculate_zone_vulnerability(vect(geometry), vulnerability_raster)
        )
    )

#Prepare data for plotting
plot_data <- zone_vulnerability_props %>%
    unnest(vulnerability_breakdown) %>%
    mutate(
        color = color_map[vulnerability],
        start_angle = cumsum(c(0, proportion[-n()])) * 2 * pi,
        end_angle = cumsum(proportion) * 2 * pi
    )

#Create the plot
ggplot() +
    #Base map of zones
    geom_sf(data = ethiopia_zones, 
            fill = NA, 
            color = "black") +
    
    #Add pie charts for each zone
    geom_arc_bar(data = plot_data,
                 aes(x0 = centroid_x, 
                     y0 = centroid_y, 
                     r0 = 0, 
                     r = 0.1, 
                     start = start_angle, 
                     end = end_angle,
                     fill = color)) +
    
    scale_fill_identity() +
    theme_minimal() +
    labs(title = "Vulnerability Proportions by Zone") +
    theme(
        plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.ticks = element_blank()
    )

#Save the plot
ggsave("vulnerability_proportions_by_zone.png", 
       width = 12, 
       height = 10, 
       dpi = 300)

#Print summary of vulnerability proportions
summary_vulnerability <- plot_data %>%
    group_by(vulnerability) %>%
    summarise(
        total_proportion = sum(proportion),
        num_zones_affected = n_distinct(NAME_2)
    )

print(summary_vulnerability)
```
```{r}


#Load vulnerability raster and zones
vulnerability_raster <- rast("ethiopia_vulnerability_5km.tif")
ethiopia_zones <- st_read("gadm41_ETH_2.shp")

#Ensure CRS is consistent
ethiopia_zones <- st_set_crs(ethiopia_zones, 4326)
crs(vulnerability_raster) <- "EPSG:4326"

#Define color mapping
color_map <- c(
    "1" = "#FFB6C1",   #Pink for Environmental
    "2" = "#A6CAF0",   #Light blue for Crop
    "3" = "#B19CD9",   #Light purple for Environmental + Crop
    "4" = "#FFE066",   #Darker yellow for Socioeconomic
    "5" = "#FFB366",   #Orange for Environmental + Socioeconomic
    "6" = "#90EE90",   #Light green for Crop + Socioeconomic
    "7" = "#808080"    #Grey for Triple vulnerability
)

#Function to calculate vulnerability proportions for a zone
calculate_zone_vulnerability <- function(zone, raster) {
    #Crop and mask raster to the specific zone
    zone_raster <- mask(crop(raster, zone), zone)
    
    #Get frequency of values, excluding 0
    freq_table <- freq(zone_raster)
    freq_table <- freq_table[freq_table$value != 0, ]
    
    #Calculate proportions
    total_cells <- sum(freq_table$count)
    freq_table$proportion <- freq_table$count / total_cells
    
    #Convert to dataframe with consistent structure
    vulnerability_props <- data.frame(
        vulnerability = as.character(freq_table$value),
        proportion = freq_table$proportion
    )
    
    return(vulnerability_props)
}

#Calculate zone centroids
zone_centroids <- st_centroid(ethiopia_zones)

#Apply vulnerability calculation
zone_vulnerability_props <- ethiopia_zones %>%
    mutate(
        centroid_x = st_coordinates(zone_centroids)[,'X'],
        centroid_y = st_coordinates(zone_centroids)[,'Y']
    ) %>%
    rowwise() %>%
    mutate(
        vulnerability_breakdown = list(
            calculate_zone_vulnerability(vect(geometry), vulnerability_raster)
        )
    )

#Prepare data for plotting
plot_data <- zone_vulnerability_props %>%
    unnest(vulnerability_breakdown) %>%
    group_by(centroid_x, centroid_y) %>%
    mutate(
        color = color_map[vulnerability],
        start_angle = cumsum(c(0, proportion[-n()])) * 2 * pi,
        end_angle = cumsum(proportion) * 2 * pi
    ) %>%
    ungroup()

#Create the plot
ggplot() +
    #Base map of zones
    geom_sf(data = ethiopia_zones, 
            fill = NA, 
            color = "gray50") +
    
    #Add pie charts for each zone
    geom_arc_bar(data = plot_data,
                 aes(x0 = centroid_x, 
                     y0 = centroid_y, 
                     r0 = 0, 
                     r = 0.25,  
                     start = start_angle, 
                     end = end_angle,
                     fill = color),
                 color = "white",  
                 size = 0.5) +  
    
    scale_fill_identity() +
    theme_minimal() +
    labs(title = "Vulnerability Proportions by Zone") +
    theme(
        plot.title = element_text(hjust = 0.5, size = 16),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank()
    ) +
    coord_sf(expand = FALSE) 

#Save the plot
ggsave("vulnerability_proportions_by_zone.png", 
       width = 12, 
       height = 10, 
       dpi = 300)

#Print summary of vulnerability proportions
summary_vulnerability <- plot_data %>%
    group_by(vulnerability) %>%
    summarise(
        total_proportion = sum(proportion),
        color = first(color)
    )

print(summary_vulnerability)
```

```{r}

#Load vulnerability raster and zones
vulnerability_raster <- rast("ethiopia_vulnerability_5km.tif")
ethiopia_zones <- st_read("gadm41_ETH_2.shp")

#Ensure CRS is consistent
ethiopia_zones <- st_set_crs(ethiopia_zones, 4326)
crs(vulnerability_raster) <- "EPSG:4326"

#Define color mapping
color_map <- c(
    "1" = "#FFB6C1",   #Pink for Environmental
    "2" = "#A6CAF0",   #Light blue for Crop
    "3" = "#B19CD9",   #Light purple for Environmental + Crop
    "4" = "#FFE066",   #Darker yellow for Socioeconomic
    "5" = "#FFB366",   #Orange for Environmental + Socioeconomic
    "6" = "#90EE90",   #Light green for Crop + Socioeconomic
    "7" = "#808080"    #Grey for Triple vulnerability
)

#Function to calculate vulnerability proportions for a zone
calculate_zone_vulnerability <- function(zone, raster) {
    #Crop and mask raster to the specific zone
    zone_raster <- mask(crop(raster, zone), zone)
    
    #Get frequency of values, excluding 0
    freq_table <- freq(zone_raster)
    freq_table <- freq_table[freq_table$value != 0, ]
    
    #Calculate proportions
    total_cells <- sum(freq_table$count)
    freq_table$proportion <- freq_table$count / total_cells
    
    #Convert to dataframe with consistent structure
    vulnerability_props <- data.frame(
        vulnerability = as.character(freq_table$value),
        proportion = freq_table$proportion
    )
    
    return(vulnerability_props)
}

#Calculate zone centroids
zone_centroids <- st_centroid(ethiopia_zones)

#Apply vulnerability calculation
zone_vulnerability_props <- ethiopia_zones %>%
    mutate(
        centroid_x = st_coordinates(zone_centroids)[,'X'],
        centroid_y = st_coordinates(zone_centroids)[,'Y']
    ) %>%
    rowwise() %>%
    mutate(
        vulnerability_breakdown = list(
            calculate_zone_vulnerability(vect(geometry), vulnerability_raster)
        )
    )

#Prepare data for plotting
plot_data <- zone_vulnerability_props %>%
    unnest(vulnerability_breakdown) %>%
    group_by(centroid_x, centroid_y) %>%
    mutate(
        color = color_map[vulnerability],
        start_angle = cumsum(c(0, proportion[-n()])) * 2 * pi,
        end_angle = cumsum(proportion) * 2 * pi
    ) %>%
    ungroup()

#Create the plot
ggplot() +
    #Base map of zones
    geom_sf(data = ethiopia_zones, 
            fill = NA, 
            color = "gray50") +
    
    #Add pie charts for each zone
    geom_arc_bar(data = plot_data,
                 aes(x0 = centroid_x, 
                     y0 = centroid_y, 
                     r0 = 0, 
                     r = 0.4, 
                     start = start_angle, 
                     end = end_angle,
                     fill = color),
                 color = "white", 
                 size = 0.5) + 
    
    scale_fill_identity() +
    theme_minimal() +
    labs(title = "Vulnerability Proportions by Zone") +
    theme(
        plot.title = element_text(hjust = 0.5, size = 16),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank()
    ) +
    coord_sf(expand = FALSE)  #Tighter map fit

#Save the plot
ggsave("vulnerability_proportions_by_zone.png", 
       width = 12, 
       height = 10, 
       dpi = 300)

#Print summary of vulnerability proportions
summary_vulnerability <- plot_data %>%
    group_by(vulnerability) %>%
    summarise(
        total_proportion = sum(proportion),
        color = first(color)
    )

print(summary_vulnerability)

```

By <zone excluding 'no vulnerability'
```{r}


#Load the vulnerability raster and zones
vulnerability_raster <- rast("ethiopia_vulnerability_5km.tif")
ethiopia_zones <- st_read("gadm41_ETH_3.shp")

#Define color mapping (matching the previous visualization)
color_map <- c(
    "1" = "#FFB6C1",   #Pink for Environmental
    "2" = "#A6CAF0",   #Light blue for Crop
    "3" = "#B19CD9",   #Light purple for Environmental + Crop
    "4" = "#FFE066",   #Darker yellow for Socioeconomic
    "5" = "#FFB366",   #Orange for Environmental + Socioeconomic
    "6" = "#90EE90",   #Light green for Crop + Socioeconomic
    "7" = "#808080"    #Grey for Triple vulnerability
)

#Function to find the most frequent value in a raster for a given zone, excluding 0
find_dominant_vulnerability <- function(zone, raster) {
    #Crop and mask raster to the specific zone
    zone_raster <- mask(crop(raster, zone), zone)
    
    #Get frequency of values, excluding 0
    freq_table <- freq(zone_raster)
    freq_table <- freq_table[freq_table$value != 0, ]
    
    #Find the value with the highest frequency 
    if(nrow(freq_table) > 0) {
        dominant_value <- freq_table$value[which.max(freq_table$count)]
    } else {
        dominant_value <- NA
    }
    
    return(dominant_value)
}

#Apply the function to each zone
zone_results <- ethiopia_zones %>%
    rowwise() %>%
    mutate(
        dominant_vulnerability = find_dominant_vulnerability(vect(geometry), vulnerability_raster),
        dominant_color = color_map[as.character(dominant_vulnerability)]
    )

#Create a plot to visualize results

ggplot() +
    geom_sf(data = zone_results, 
            aes(fill = dominant_color)) +
    scale_fill_identity() +
    theme_minimal() +
    labs(title = "Dominant Vulnerability Type by Zone\n(Excluding No Vulnerability)")

#Redefine color map
color_map <- c(
    "1" = "#FFB6C1",   #Pink for Environmental
    "2" = "#A6CAF0",   #Light blue for Crop
    "3" = "#B19CD9",   #Light purple for Environmental + Crop
    "4" = "#FFE066",   #Darker yellow for Socioeconomic
    "5" = "#FFB366",   #Orange for Environmental + Socioeconomic
    "6" = "#90EE90",   #Light green for Crop + Socioeconomic
    "7" = "#808080"    #Grey for Triple vulnerability
)

#Create the plot
vulnerability_plot <- ggplot() +
    geom_sf(data = zone_results, 
            aes(fill = dominant_color)) +
    scale_fill_identity() +
    theme_minimal() +
    labs(title = "Dominant Vulnerability Type by Zone\n(Excluding No Vulnerability)") +
    theme(
        plot.title = element_text(hjust = 0.5, size = 14),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank()
    )

#Save the plot
ggsave("dominant_vulnerability_by_zone.png", 
       plot = vulnerability_plot,
       width = 10, 
       height = 8, 
       dpi = 300,
       bg = "white")

#Save the results
write_sf(zone_results, "ethiopia_<zones_vulnerability_excluding_zero.shp")

#Print summary
summary_table <- zone_results %>% 
    filter(!is.na(dominant_vulnerability)) %>%
    group_by(dominant_vulnerability) %>% 
    summarise(
        num_zones = n(),
        percentage = (n() / nrow(zone_results)) * 100
    )

print("Vulnerability Type Distribution:")
print(summary_table)


```

Ethiopia Boundries:
```{r}

#Read shapefiles for each administrative level
ethiopia_0 <- st_read("gadm41_ETH_0.shp")
ethiopia_1 <- st_read("gadm41_ETH_1.shp")
ethiopia_2 <- st_read("gadm41_ETH_2.shp")
ethiopia_3 <- st_read("gadm41_ETH_3.shp")

#Ensure all are in the same CRS
ethiopia_0 <- st_set_crs(ethiopia_0, 4326)
ethiopia_1 <- st_set_crs(ethiopia_1, 4326)
ethiopia_2 <- st_set_crs(ethiopia_2, 4326)
ethiopia_3 <- st_set_crs(ethiopia_3, 4326)

#Create the plot
ggplot() +
    #Level 3 (Woredas) - light green
    geom_sf(data = ethiopia_3, 
            fill = NA, 
            color = "darkgreen", 
            linewidth = 0.1) +
    
    #Level 2 (Zones) - blue
    geom_sf(data = ethiopia_2, 
            fill = NA, 
            color = "blue", 
            linewidth = 0.3) +
    
    #Level 1 (Regions) - red
    geom_sf(data = ethiopia_1, 
            fill = NA, 
            color = "red", 
            linewidth = 0.5) +
    
    #Level 0 (Country Border) - thick black
    geom_sf(data = ethiopia_0, 
            fill = NA, 
            color = "black", 
            linewidth = 1) +
    
    theme_minimal() +
    labs(title = "Ethiopia Administrative Boundaries",
         subtitle = "Levels 0-3") +
    theme(
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank()
    )

#Save the plot
ggsave("ethiopia_admin_boundaries.png", 
       width = 10, 
       height = 12, 
       dpi = 300)
```

```{r}

#Read shapefiles for each administrative level
ethiopia_0 <- st_read("gadm41_ETH_0.shp")
ethiopia_1 <- st_read("gadm41_ETH_1.shp")
ethiopia_2 <- st_read("gadm41_ETH_2.shp")
ethiopia_3 <- st_read("gadm41_ETH_3.shp")

#Ensure all are in the same CRS
ethiopia_0 <- st_set_crs(ethiopia_0, 4326)
ethiopia_1 <- st_set_crs(ethiopia_1, 4326)
ethiopia_2 <- st_set_crs(ethiopia_2, 4326)
ethiopia_3 <- st_set_crs(ethiopia_3, 4326)

#Create the plot
ggplot() +
    #Level 3 (Woredas) - light green
    geom_sf(data = ethiopia_3, 
            fill = NA, 
            color = "darkgreen", 
            linewidth = 0.1) +
    
    #Level 2 (Zones) - blue
    geom_sf(data = ethiopia_2, 
            fill = NA, 
            color = "blue", 
            linewidth = 0.3) +
    
    #Level 1 (Regions) - red
    geom_sf(data = ethiopia_1, 
            fill = NA, 
            color = "red", 
            linewidth = 0.5) +
    
    #Level 0 (Country Border) - thick black
    geom_sf(data = ethiopia_0, 
            fill = NA, 
            color = "black", 
            linewidth = 1) +
    
    #Add scale bar
    annotation_scale(
        location = "bl", 
        width_hint = 0.5, 
        pad_y = unit(0.1, "cm")  
    ) +
    
    #Add north arrow
    annotation_north_arrow(
        location = "tr",  
        which_north = "true",
        pad_x = unit(0.5, "cm"),
        pad_y = unit(0.5, "cm"),
        style = north_arrow_fancy_orienteering
    ) +
    
    theme_minimal() +
    labs(title = "Ethiopia Administrative Boundaries",
         subtitle = "Levels 0-3") +
    theme(
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank()
    )

#Save the plot
ggsave("ethiopia_admin_boundaries.png", 
       width = 10, 
       height = 12, 
       dpi = 300)
```

```{r}

#Load the Level 2 administrative boundary shapefile
ethiopia_admin2 <- st_read("gadm41_ETH_2.shp")

#Create a transparent map using ggplot2
ethiopia_plot <- ggplot() +
  geom_sf(data = ethiopia_admin2, color = "black", fill = NA, size = 0.3) +  
  theme_void() + 
  theme(panel.background = element_rect(fill = "transparent", color = NA))  

#Save as transparent PNG
ggsave("ethiopia_admin2_transparent.png", plot = ethiopia_plot, 
       bg = "transparent", width = 8, height = 6, dpi = 300)
```